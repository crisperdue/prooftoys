<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">

  <title>ProofToys Proof Builder</title>

   <!-- TODO: deploy with yui-min.js rather than yui.js -->
  <script src="http://yui.yahooapis.com/3.4.0/build/yui/yui.js"></script>
  <!-- For debugging add explicit reference to source file(s) here -->

  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

h1 { color: black }

h2 {
  color: black;
  text-align: left;
}

h2, h3 {
  margin-bottom: .5em;
}

body {
  /* Allow space for the bottom panel. */
  margin-bottom: 4em;
}

a.nav {
  display: block;
  font-style: italic;
  margin: .3em 1.5em .3em 1em;
  text-decoration: none;
  text-indent: -1em;
}

a.nav:before {
  content: "‚ä¶ ";
}

</style>

<!-- Links by default open a new window/tab -->
<base target=_blank>
  
</head>
<body class=yui3-skin-sam
 style="margin: 1em 4em 1em 1em; text-align: left; font-family: sans-serif">

<h1 style="margin-bottom: .2em">Prooftoys</h2>

<div style="margin-bottom: 1em">
<center><i>Web-based tools for mathematical problem-solving.</i></center>
</div>

<table>
<tr>
<td style="vertical-align: top; padding-top: 7em" width=20%>

<a class=nav href="http://code.google.com/p/jlogic">
 Project site</a>
<a class=nav href="?">
 Using the interactive proof builder</a>
<a class=nav href="http://code.google.com/p/jlogic/source/checkout">
 Source code</a>
<a class=nav href="http://code.google.com/p/jlogic/wiki/AboutTheLogic">
 About the logic</a>

<td>
<h2>Introduction</h2>

<h3>The mission</h3>
Prooftoys is an open-source initiative to use the Web to bring
user-friendly full-fledged logical reasoning tools to anyone who works
with math.

<h3>The engine</h3>
The Prooftoys inference engine
uses <a href="http://en.wikipedia.org/wiki/Higher-order_logic">higher-order
logic</a>, which means it can reason about functions and predicates,
which themselves can have functions and predicates as inputs and
outputs.  This gives it the power to help you develop as much of
mathematics as you wish.  The engine runs directly in your web browser
for best responsiveness, interactivity, and convenient access to
servers in the Internet cloud.
<p>
The engine implements Peter Andrews' Q<sub>0</sub>, a simple and
elegant version of higher-order logic with a small and understandable
kernel.  On this base it
builds <a href="http://en.wikipedia.org/wiki/Natural_deduction">natural
deduction</a>-style reasoning and a variety high-level inference rules
that make it easy to build high-level proofs.
<p>
The engine is safely programmable, and you can create new high-level
inference rules without compromising correctness.

<h3>The user interface</h3>
<p>
Prooftoys has a highly interactive user interface for building proofs
and solving mathematical problems directly through a web browser.  You
can select steps, expressions, and locations in steps by pointing and
clicking, and apply any predefined or extended public inference rule.
<p>
When displaying an existing proof, the user interface lets the reader
drill down into the details of high-level inference steps to follow
how they were carried out, to understand a proof in more detail.  It
also provides extra information and visual highlighting to show
exactly how each inference rule was applied to its target step or
steps.

<h2>Sample proofs</h2>
<p>
Selecting a theorem or inference rule below displays an example of
usage of the rule or theorem.  Axioms and theorems often have
parameters, and rules of inference have inputs that themselves must be
proved steps.
<p>Some of the theorems and derived rules of inference you can see
here are intermediate results, but they help to demonstrate the core
concepts and how proofs are built from them.  Examples of some
practical rules of inference are also here, such as universal
generalization (addForall), universal instantiation (instForall), and
reasoning by cases (cases).

<p>
<i>Proof displays are supported in recent versions of Firefox and Chrome.</i>

<p id=selectDiv style="margin: 1.5em">
<b>Select a rule or theorem to prove:</b>

<div id=proofs></div>

<div style="margin: 1.5em 0em .5em 1.5em">
<b>Or interactively create your own proof below:</b>
</div>
<div id=proofEditor></div>

<div id=proofErrors></div>

<p><b>About the logic.</b>  This page can derive many of the theorems
and examples of rules of inference of Chapter 5 of Peter Andrews'
book,
<a href="http://gtps.math.cmu.edu/tttp.html" target="_blank">
An Introduction to Mathematical Logic and Type Theory: To Truth
Through Proof</a>.  The order of theorems is essentially the same as
in the book.  Some of the numbered theorems have been given names here
in the hope of helping me remember which is which.  His logic is
summarized in
<a href="http://plato.stanford.edu/entries/type-theory-church/#ForBasEqu"
target=_blank>this article</a>
in the online Stanford Encyclopedia of Philosophy.

<p><b>About the proofs.</b> Most of the proofs here closely follow
proofs in the book.  I am also experimenting with definitions of
boolean operators more directly related to truth tables, and a number
of proofs use those definitions.  In some cases more than one version
of the same proof is available, one following the book.  The sample
proofs are all created by hand and executed by machine.

<p><b>About the displays.</b> Formulas are presented here in a somewhat
different notation.  Instead of the usual use of lambda,
we have a notation somewhat resembling the Ruby
programming language brace notation for 
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous functions or Smalltalk blocks.
For example in place of <b>&lambda;x.p x</b> you will see <code><b>{x.
p x}</b></code>.  This notation also resembles common notation for sets,
and can be read that way for functions with boolean values &mdash;
"<i>the set of x such that p of x</i>".
The displays also use symbols more like programming
language symbols for "and" and "or", and infix syntax where
applicable.

<p>When the mouse is over a line, that line and lines it uses
are highlighted.  For Rule R and a lambda reductions ("apply"), key
parts of the lines are also highlighted for quicker identification.

<p>Click on the name of the rule of inference or theorem
mentioned on a line and see the proof worked out in detail below
the current proof.

<p><b>About the project.</b> This software is under development
and is currently hosted as
<a href="http://code.google.com/p/jlogic" target=_blank><b>jLogic</b></a>
at Google Code.  Requests and suggestions are welcome.  Please use
<a href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion"
target="_blank">
this template</a> for your input.

<p>Thanks
<br>Cris Perdue

</table>

<script>
// Remove "filter" to load minified JavaScript.
YUI({filter: 'raw', insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  // For convenience.
  var rules = Y.rules;

  // Map from example name to example configuration info, each of
  // which is also a map.  Configuration properties are:
  //
  // ruleName: name of the rule to run, defaults to the example name.
  // args: array of arguments to pass to the rule.  If a function, the
  //   function computes the arguments.
  // level: if 1 then offer this example in the dropdown control.
  var proofs = {

    // PROOFS

    eqSelf: {
      args: [call(p, x)],
      level: 1
    },

    applyBoth: {
      args: [rules.assert(call('=', f, g), x)],
      level: 1
    },

    replaceWhole: {
      args: [rules.assert(call(p, x)),
             rules.assert(call('=', call(p, x), call(q, x)))],
    },

    eqnSwap: {
      args: [rules.assert(call('=', p, q))],
      level: 1
    },

    eqnChain: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', q, r))],
    },

    applyBySides: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', 'a', 'b'))]
    },
    
    applyBoth: {
      args: [rules.assert(call('=', p, q)), r],
      level: 1
    },
    
    applyToBoth: {
      args: [p, rules.assert(call('=', q, r))]
    },

    useDefinition: {
      args: [rules.assert(call('not', equal(p, call('not', p)))), '/fn'],
      level: 1
    },
    
    apply: {
      args: [rules.assert(equal(p, call(lambda(x, T), y))), '/right'],
      level: 1
    },

    changeVar: {
      args: [rules.assert(equal(lambda(z, z), lambda(z, z))), '/right', y],
      level: 1
    },

    bindEqn: {
      args: [rules.assert(call('=', f, g)), x],
    },
    
    instEqn: {
      args: [rules.assert(call('=', call(g, y), z)),
             call(f, x),
             y],
    },
    
    eqT: {
      args: [p]
    },
    
    r5211: {},

    r5211Book: {},
    
    t: {},
    
    r5212: {},
    
    toTIsEquation: {
      args: [rules.assert(call('=', p, q))]
    },
    
    r5213: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', q, r))]
    },
    
    instForall: {
      args: [rules.assert(call('forall', lambda(y, call(p, y)))),
             call(f, y)],
      level: 1
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    equationCases: {
      args: [rules.assert(equal(T, T)),
             rules.assert(equal(F, F)),
             'z'],
      level: 1
    },

    r5218a: {},

    r5218: {
      args: [call(p, y)]
    },
    
    toTIsA: {
      args: [rules.assert(p)],
      level: 1
    },
    
    fromTIsA: {
      args: [rules.assert(call('=', T, p))],
      level: 1
    },
    
    forallT: {
      args: [_var('v')]
    },

    addForall: {
      args: [rules.assert(call(p, y)), y],
      level: 1
    },
    
    instVar: {
      args: [rules.assert(call(p, y)), call(f, x), y],
      level: 1
    },
    
    instMultiVars: {
      args: [rules.assert(implies(p, call('||', T, q))),
             ({p: Y.parse('forall {x. T || b}'),
               q: Y.parse('forall {x. b}')
             })
            ],
      level: 1
    },

    cases: {
      args: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        return [step1, step2, 'x'];
      },
      level: 1
    },
    
    r5223: {},
    
    modusPonens: {
      args: [rules.assert(p), rules.assert(implies(p, q))],
      level: 1
    },
    
    modusPonensHyps: {
      ruleName: 'modusPonens',
      args: function() {
        var step1 = Y.rules.assume('p');
        var step2 = Y.rules.assume('p --> q');
        return [step1, step2];
      },
      level: 1
    },

    r5230TF: {},
    
    r5230FT: {},
    
    r5230FT_alternate: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))],
      level: 1
    },
    
    tautology: {
      /* This tautology is already an equation, let's test one that is not.
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))],
      */
      args: [Y.parse('(p --> q) && (not p --> q) --> q')],
      level: 1
    },
    
    tautInst: {
      args: [Y.parse('p --> T || q'), ({
        p: Y.parse('forall {x. T || p x}'),
        q: Y.parse('forall {x. p x}')
      })],
      level: 1
    },


    r5235: {
      args: [x, p, call(q, x)]
    },

    implyForallThm: {
      args: [x, p, call(q, x)]
    },

    implyForall: {
      args: [x, rules.assert(Y.parse('p --> q x'))],
      level: 1
    },

    implyForallHyps: {
      ruleName: 'implyForall',
      args: function() {
        var step1 = Y.rules.assume('y > 0');
        var step2 = Y.rules.assert('y > 0 --> (p --> q x)');
        var step3 = Y.rules.modusPonens(step1, step2);
	return [x, step3];
      },
      level: 1
    },

    implyForallBookHyps: {
      ruleName: 'implyForallBook',
      args: function() {
	var wff = Y.parse('y > 0 --> (p --> q x)');
        wff.hasHyps = true;
	return [x, wff];
      },
    },

    p: {
      args: [Y.parse('p x && p x --> q x'),
             Y.parse('P && (P --> Q) --> Q')]
    },

    r5238a: {
      args: [y, call(p, y), call(q, y)]
    },

    r5238: {
      args: [['x1', 'x2'], call(p, _var('x1')), call(p, _var('x2'))]
    },

    r5239: {
      args: [equal(p, q), lambda(p, equal(q, p)), '/body/right'],
      level: 1
    },

    replace: {
      args: function() {
        var step1 = Y.rules.assume('x > 0');
        var step2 = Y.rules.assert('x > 0 --> (x = (abs x))');
        var step3 = Y.rules.modusPonens(step1, step2);
        var step4 = Y.rules.assert('x > 0 --> (x + x) > x');
        var step5 = Y.rules.modusPonens(step1, step4);
        return [step3, step5, '/main/right'];
      },
      level: 1
    },

    appendStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      },
      level: 1
    },

    prependStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      },
      level: 1
    },

    bubbleLeft: {
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (((b && a) && d) && a)'), less];
      },
    },

    mergeConj: {
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (a && b) && (c && d)'), less];
      },
      level: 1
    }

  };

  function selectorChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    displayProof(ruleName);
  }

  /**
   * Runs and displays a proof of the named rule (or theorem).
   * If there is no such rule, notifies the user that there is none.
   */
  function displayProof(name) {
    var ruleInfo = proofs[name];
    if (ruleInfo == undefined) {
      alert('No example "' + name + '"');
    } else {
      var startMillis = new Date().getTime();
      var result;
      var ruleName = ruleInfo.ruleName || name;
      var args = ruleInfo.args;
      if (typeof args == 'function') {
	args = args();
      }
      var stepCounter = Y.getStepCounter();
      try {
	result = Y.rules[ruleName].apply(null, args || []);
      } catch(e) {}
      var elapsed = new Date().getTime() - startMillis;
      // This is actually the number of steps needed to execute the
      // rule, not counting steps used in deriving argument steps.
      var nSteps = Y.getStepCounter() - stepCounter;
      // For debugging.
      window.proved = result;
      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      if (result) {
	Y.renderProof(result, proofNode, elapsed, nSteps);
      } else if (Y.errors.length) {
	var last = Y.errors[Y.errors.length - 1];
	proofNode.append('<p><b>Errors: (' + Y.errors.length
			 + ') ' + last.message + '</b></p>');
	if (last.step) {
	  Y.renderProof(last.step, proofNode);
	}
      }
      document.title = 'Proof display -- ' + ruleName;
    }
  }

  // Do we want sample proofs to be editable?
  // Controllable through the query string.
  var editable;

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      // You can control which rule is displayed by including
      // "rule=<ruleName>" in the query string.
      var ruleName = queryData.rule;
      // You can make the displays label steps with their ordinals
      // using ordinals=1 in the query string.
      Y.showOrdinals = queryData.ordinals;
      editable = queryData.edit != undefined;
      if (ruleName == undefined) {
        // Default to displaying instForall.
        ruleName = 'instForall';
      }
      displayProof(ruleName);
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        if (proofs[name].level == 1) {
          if (name == ruleName) {
            selector += '<option selected>' + name + '\n';
          } else {
            selector += '<option>' + name + '\n';
          }
        }
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.addBottomPanel();
      Y.one('#selector').on('change', selectorChanged);

      // Create an interactive proof editor for the user.
      var controller = new Y.ProofControl();
      controller.setEditable(true);
      Y.one('#proofEditor').append(controller.node);
      // For debugging:
      window.proofBuilder = controller;
    });

  // For debugging.
  window.Y = Y;
  window.db = Y.debugString;
});

// Debugging helpers.

/**
 * Returns a string of N spaces.
 */
function spaces(n) {
  var result = '';
  for (var i = 0; i < n; i++) {
    result += ' ';
  }
  return result;
}

</script>
</body>
</html>
