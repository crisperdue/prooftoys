<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">

  <title>ProofToys</title>

   <!-- TODO: deploy with yui-min.js rather than yui.js -->
  <script src="http://yui.yahooapis.com/3.4.0/build/yui/yui.js"></script>
  <!-- For debugging add explicit reference to source file(s) here -->

  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

h1 { color: black }

h2 {
  color: black;
  text-align: left;
}

h2, h3 {
  margin-bottom: .5em;
}

body {
  /* Allow space for the bottom panel. */
  margin-bottom: 4em;
}

a.nav {
  display: block;
  font-style: italic;
  margin: .3em 1.5em .3em 1em;
  text-decoration: none;
  text-indent: -1em;
}

a.nav:before {
  content: "‚ä¶ ";
}

</style>

<script type="text/javascript">
  // Google analytics
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28801147-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>
<body class=yui3-skin-sam
 style="margin: 1em 4em 1em 1em; text-align: left; font-family: sans-serif">

<h1 style="margin-bottom: .2em">Prooftoys</h2>

<div style="margin-bottom: 1em">
<center><i>Interactive tools for mathematical problem-solving.</i></center>
<center><i>Making math quicker, easier, and correct.</i></center>
</div>

<table>
<tr>
<td style="vertical-align: top; padding-top: 7em" width=20%>

<a class=nav href="proofbuilder.html">
 Interactive proof builder</a>
<a class=nav href="http://code.google.com/p/jlogic/wiki/LanguageSummary">
 Summary of the Language</a>
<a class=nav href="http://code.google.com/p/jlogic/wiki/AboutTheLogic">
 About the logic</a>
<a class=nav href="http://code.google.com/p/jlogic">
 Project site</a>
<a class=nav href="http://code.google.com/p/jlogic/source/checkout">
 Source code</a>
<a class=nav
 href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion">
 Comments etc.</a>

<td>
<h2>Introduction</h2>

<h3>The mission</h3>
Prooftoys is an open-source initiative to use the Web to bring
user-friendly full-fledged logical reasoning tools to anyone who works
with math.  The current components are the engine and the user
interface.  They are both under continuing development and important
work remains to be done on both, but are ready for experimental use.

<h3>The engine</h3>
The Prooftoys inference engine uses <i>higher-order logic</i>, which
means it can reason about functions and predicates, which themselves
can have functions and predicates as inputs and outputs.  This gives
it the power to help you develop as much of mathematics as you wish.
The engine runs directly in your web browser for best responsiveness,
interactivity, and convenient access to servers in the Internet cloud.
<p>
The engine implements Peter Andrews' Q<sub>0</sub>, a simple and
elegant version of higher-order logic with a small and understandable
kernel.  On this base it
builds <i href="http://en.wikipedia.org/wiki/Natural_deduction">natural
deduction</i>-style reasoning and a variety high-level inference rules
that make it easy to build high-level proofs.
<p>
The engine is safely programmable, and you can create new high-level
inference rules without compromising correctness.

<h3>The user interface</h3>
<p>
In the web-based Proof Builder user interface you can select steps,
expressions, and locations in steps by pointing and clicking, and
apply any predefined or extended public inference rule.  When reading
an existing proof you can drill down into the details of high-level
inference steps or theorems to see how they are proved in more detail.
<p>
Please do feel free to try out the current version of the
<a href="proofbuilder.html">Proof Builder</a>.

<h2>Sample proofs</h2>
<p>
Examples of many of the currently-implemented rules of inference are
available here.  Selecting a theorem or inference rule below displays
an example of usage of the rule or theorem.  Axioms, theorems, and
rules of inference often have parameters.
<p>
Some often-used practical rules of inference are universal
generalization (addForall), universal instantiation (instForall), and
reasoning by cases (cases).  There is a tautology checker which can
prove arbitrary tautologies, and a version of Professor Andrews' very
own Rule P.
<p>
To see how a rule operates internally, click on its name in the proof
line that uses it.
<p>
<i>Proof displays are supported in recent versions of Firefox and Chrome.</i>

<p id=selectDiv style="margin: 1.5em 1.5em .5em">
<b>Select a rule or theorem to prove:</b>

<div id=proofs style="margin-bottom: 2em"></div>

<p>
<b>About the notation.</b> 
Aside from variables and constants, the language has only function
calls and function expressions, like lambda expressions in the lambda
calculus.  The parser and printer support infix operators, which are
"<a href="http://www.haskell.org/haskellwiki/Currying">curried</a>"
in the internal representation into functions of a single argument.
<p>
Infix operators available in order of increasing precedence are:
<ul>
<li><code>==</code> (equality)
<li><code>--></code> (implication)
<li><code>||</code> (or)
<li><code>&&</code> (and)
<li><code>= != &lt; &lt;= &gt; &gt;=</code> (relational operators
    with equality again)
<li><code>+ -</code>
<li><code>* /</code>
</ul>
Ordinary function calls look like <code><b>(f x)</b></code> or
<code><b>f x</b></code>, and have higher precedence than any infix
operator.
<p>
Anonymous functions have the form <code><b>{x. p x}</b></code>, a
notation somewhat resembling the Ruby programming language notation
for
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous functions or Smalltalk blocks.
This notation also resembles common notation for sets,
and can be read that way for functions with boolean values &mdash;
"<i>the set of x such that p of x</i>".
<p>
For more information see the
<a href="http://code.google.com/p/jlogic/wiki/LanguageSummary">
language summary</a> in the project Wiki.

</table>

<script>
// Remove "filter" to load minified JavaScript.
YUI({filter: 'raw', insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  // For convenience.
  var rules = Y.rules;

  // Map from example name to example configuration info, each of
  // which is also a map.  Configuration properties are:
  //
  // ruleName: name of the rule to run, defaults to the example name.
  // args: array of arguments to pass to the rule.  If a function, the
  //   function computes the arguments.
  // level: if 1 then offer this example in the dropdown control.
  var proofs = {

    // PROOFS

    eqSelf: {
      args: [call(p, x)],
      level: 1
    },

    applyBoth: {
      args: [rules.assert(call('=', f, g), x)],
      level: 1
    },

    replaceWhole: {
      args: [rules.assert(call(p, x)),
             rules.assert(call('=', call(p, x), call(q, x)))],
    },

    eqnSwap: {
      args: [rules.assert(call('=', p, q))],
      level: 1
    },

    eqnChain: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', q, r))],
    },

    applyBySides: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', 'a', 'b'))]
    },
    
    applyBoth: {
      args: [rules.assert(call('=', p, q)), r],
      level: 1
    },
    
    applyToBoth: {
      args: [p, rules.assert(call('=', q, r))]
    },

    useDefinition: {
      args: [rules.assert(call('not', equal(p, call('not', p)))), '/fn'],
      level: 1
    },
    
    apply: {
      args: [rules.assert(equal(p, call(lambda(x, T), y))), '/right'],
      level: 1
    },

    changeVar: {
      args: [rules.assert(equal(lambda(z, z), lambda(z, z))), '/right', y],
      level: 1
    },

    bindEqn: {
      args: [rules.assert(call('=', f, g)), x],
    },
    
    instEqn: {
      args: [rules.assert(call('=', call(g, y), z)),
             call(f, x),
             y],
    },
    
    eqT: {
      args: [p]
    },
    
    r5211: {},

    r5211Book: {},
    
    t: {},
    
    r5212: {},
    
    toTIsEquation: {
      args: [rules.assert(call('=', p, q))]
    },
    
    r5213: {
      args: [rules.assert(call('=', p, q)),
             rules.assert(call('=', q, r))]
    },
    
    instForall: {
      args: [rules.assert(call('forall', lambda(y, call(p, y)))),
             call(f, y)],
      level: 1
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    equationCases: {
      args: [rules.assert(equal(T, T)),
             rules.assert(equal(F, F)),
             'z']
    },

    r5218a: {},

    r5218: {
      args: [call(p, y)]
    },
    
    toTIsA: {
      args: [rules.assert(p)]
    },
    
    fromTIsA: {
      args: [rules.assert(call('=', T, p))]
    },
    
    forallT: {
      args: [_var('v')]
    },

    addForall: {
      args: [rules.assert(call(p, y)), y],
      level: 1
    },
    
    instVar: {
      args: [rules.assert(call(p, y)), call(f, x), y],
      level: 1
    },
    
    instMultiVars: {
      args: [rules.assert(implies(p, call('||', T, q))),
             ({p: Y.parse('forall {x. T || b}'),
               q: Y.parse('forall {x. b}')
             })
            ],
      level: 1
    },

    makeConjunction: {
      args: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        return [step1, step2];
      },
      level: 1
    },

    cases: {
      args: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        return [step1, step2, 'x'];
      },
      level: 1
    },
    
    r5223: {},
    
    simpleModusPonens: {
      ruleName: 'modusPonens',
      args: [rules.assert(p), rules.assert(implies(p, q))],
      level: 1
    },
    
    modusPonens: {
      args: function() {
        var step1 = Y.rules.assume('p');
        var step2 = Y.rules.assume('p --> q');
        return [step1, step2];
      },
      level: 1
    },

    r5230TF: {},
    
    r5230FT: {},
    
    r5230FT_alternate: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))]
    },
    
    tautology: {
      /* This tautology is already an equation, let's test one that is not.
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))],
      */
      args: [Y.parse('(p --> q) && (not p --> q) --> q')],
      level: 1
    },
    
    tautInst: {
      args: [Y.parse('p --> T || q'), ({
        p: Y.parse('forall {x. T || p x}'),
        q: Y.parse('forall {x. p x}')
      })],
      level: 1
    },


    r5235: {
      args: [x, p, call(q, x)]
    },

    implyForallThm: {
      args: [x, p, call(q, x)]
    },

    implyForallNoHyps: {
      ruleName: 'implyForall',
      args: [x, rules.assert(Y.parse('p --> q x'))],
    },

    implyForall: {
      args: function() {
        var step1 = Y.rules.assume('y > 0');
        var step2 = Y.rules.assert('y > 0 --> (p --> q x)');
        var step3 = Y.rules.modusPonens(step1, step2);
	return [x, step3];
      },
      level: 1
    },

    implyForallBookHyps: {
      ruleName: 'implyForallBook',
      args: function() {
	var wff = Y.parse('y > 0 --> (p --> q x)');
        wff.hasHyps = true;
	return [x, wff];
      },
    },

    'Rule P': {
      ruleName: p,
      args: [Y.rules.assume('p x && (p x --> q x)'),
             Y.parse('a && (a --> b) --> b')],
      level: 1
    },

    r5238a: {
      args: [y, call(p, y), call(q, y)]
    },

    r5238: {
      args: [['x1', 'x2'], call(p, _var('x1')), call(p, _var('x2'))]
    },

    r5239: {
      args: [equal(p, q), lambda(p, equal(q, p)), '/body/right']
    },

    replace: {
      args: function() {
        var step1 = Y.rules.assume('x > 0');
        var step2 = Y.rules.assert('x > 0 --> (x = (abs x))');
        var step3 = Y.rules.modusPonens(step1, step2);
        var step4 = Y.rules.assert('x > 0 --> (x + x) > x');
        var step5 = Y.rules.modusPonens(step1, step4);
        return [step3, step5, '/main/right'];
      },
      level: 1
    },

    appendStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      }
    },

    prependStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      }
    },

    bubbleLeft: {
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (((b && a) && d) && a)'), less];
      }
    },

    mergeConjunctions: {
      ruleName: 'mergeConj',
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (a && b) && (c && d)'), less];
      }
    }

  };

  function selectorChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    displayProof(ruleName);
  }

  /**
   * Runs and displays a proof of the named rule (or theorem).
   * If there is no such rule, notifies the user that there is none.
   */
  function displayProof(name) {
    var ruleInfo = proofs[name];
    if (ruleInfo == undefined) {
      alert('No example "' + name + '"');
    } else {
      var startMillis = new Date().getTime();
      var result;
      var ruleName = ruleInfo.ruleName || name;
      var args = ruleInfo.args;
      if (typeof args == 'function') {
	args = args();
      }
      var stepCounter = Y.getStepCounter();
      try {
	result = Y.rules[ruleName].apply(null, args || []);
      } catch(e) {}
      var elapsed = new Date().getTime() - startMillis;
      // This is actually the number of steps needed to execute the
      // rule, not counting steps used in deriving argument steps.
      var nSteps = Y.getStepCounter() - stepCounter;
      // For debugging.
      window.proved = result;
      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      if (result) {
	Y.renderProof(result, proofNode, elapsed, nSteps);
      } else if (Y.errors.length) {
	var last = Y.errors[Y.errors.length - 1];
	proofNode.append('<p><b>Errors: (' + Y.errors.length
			 + ') ' + last.message + '</b></p>');
	if (last.step) {
	  Y.renderProof(last.step, proofNode);
	}
      }
    }
  }

  // Do we want sample proofs to be editable?
  // Controllable through the query string.
  var editable;

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      // You can control which rule is displayed by including
      // "rule=<ruleName>" in the query string.
      var ruleName = queryData.rule;
      // You can make the displays label steps with their ordinals
      // using ordinals=1 in the query string.
      Y.showOrdinals = queryData.ordinals;
      editable = queryData.edit != undefined;
      if (ruleName == undefined) {
        // Default to displaying instForall.
        ruleName = 'instForall';
      }
      displayProof(ruleName);
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        if (proofs[name].level == 1) {
          if (name == ruleName) {
            selector += '<option selected>' + name + '\n';
          } else {
            selector += '<option>' + name + '\n';
          }
        }
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.addBottomPanel();
      Y.one('#selector').on('change', selectorChanged);
    });

  // For debugging.
  window.Y = Y;
  window.db = Y.debugString;
});

// Debugging helpers.

/**
 * Returns a string of N spaces.
 */
function spaces(n) {
  var result = '';
  for (var i = 0; i < n; i++) {
    result += ' ';
  }
  return result;
}

</script>
</body>
</html>
