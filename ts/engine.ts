// Copyright Crispin Perdue.  All rights reserved.
//
// Here be core facilities such as declaring rules, theorems, facts,
// and definitons, matching and fact management that can be separated
// from actual deduction.

'use strict';

// import type { Dexie } from "./dexie.d.ts";

// import type { Dexie } from "dexie";

/** Exported constructor */
// var Dexie;

// Set all of this up immediately upon load, but avoiding changes
// to the global environment (except through the "Toy" namespace).
namespace Toy {

export var _actionInfo;

//// THEOREMS AND RULES

// Predefine some common constants.
var T = constify('T');
var F = constify('F');

// Map from tautology string representation to tautology,
// for proved tautologies.  Private to the tautology rule.
//
// TODO: Part of a proof context.
export var _tautologies = new Map();

//
// Expr methods for inference
//

export interface Expr {
/**
 * Returns a shallow copy of this, annotating the copy with the rule
 * name, rule arguments, and dependencies (ruleName,
 * ruleArgs, ruleDeps).  "This" becomes the "details" property if it
 * already has a justification.  (Axioms, definitions and assertions
 * are not generated by rules, though theorems are.)  The ruleDeps
 * array is optional, empty if not given.
 *
 * If this is identical to one of its ruleDeps, returns this
 * unchanged, making the step a no-op, unless "retain" is true.  (The
 * purpose is to reduce clutter for readers of the proof.)
 *
 * TODO: Make a Step class for proof steps, and have this method
 * return a new one.
 *
 * TODO: Consider always recording the step, but skipping the display
 * in proof.jsc.  Some steps, especially simplifications, do this
 * same thing internally by skipping the call to "justify".
 *
 * TODO: Add a "justify0" method that never modifies assumptions,
 * or alternatively, never "arrange" them here, leaving that task
 * to rules such as "replace".
 */
justify(ruleName, ruleArgs, deps?: Step[], retain?: boolean);
}
Expr.prototype.justify = function(ruleName, ruleArgs, deps, retain) {
  // Note: when splitting Step and Expr, make a version of this just
  // for rules.assert, and use that in any primitive inference rules.
  var ruleDeps = Array.from(deps || []);
  // TODO: Consider removing this special treatment of rule "r" here.
  if (!retain && ruleName !== 'r') {
    for (var i = 0; i < ruleDeps.length; i++) {
      const dep = ruleDeps[i];
      if (dep.sameAs(this)) {
        // If the step returns an input step, return it as-is,
        // obliterating the putative new step.  The resulting proof
        // object may occasionally surprise the author of a proof.
        return dep;
      }
    }
  }
  const step = this;
  // At this spot we could conditionally run arrangeAsms in case the
  // step being justified is conditional.  Omitting that automagic
  // behavior for now.
  //
  // TODO: Consider modifying arrangeAsms to flag its result as
  //   "arrangedAsms", and to check on entry if a step's asms are
  //   flagged.  If so it would immediately return its input
  //   unmodified.  Presumably arrangeAsms is a pure
  //   rewriter/simplifier and thus does not introduce conditional
  //   steps, so calling it here would not result in recursive calls
  //   to it.

  // Allocate a new object to be the new Step.
  const result = (step instanceof Call
                  ? new Call(step.fn, step.arg)
                  : step instanceof Atom
                  ? new Atom(step.pname)
                  // Impossible for a step!
                  : abort('Internal'));
  result._typeFrom(step);

  // The beginnings of a Step class.  Only steps will have the
  // following properties, with .wff accessing the top expression
  // (wff).
  //
  // Note: Likely additional Step methods: freeVars. 
  result.wff = result;
  // TODO: The "rendering" (and also "original") property is quite
  //   sparse.  Consider eliminating "original" for non-rendered steps
  //   and storing "rendering" in a WeakMap.
  result.rendering = null;
  // Record the step as details.
  // Note that above, primitive rules have no deps.
  if (Toy.isProved(step)) {
    // Except for primitive rules listed just below.
    result.details = ruleName === 'r' ? null : step;
  } else {
    switch(ruleName) {
    case 'axiom4':
    case 'assert':
    // TODO: "define" should not have to be a special case here.
    case 'define':
    case 'definition':
    case 'r':
      break;
    default:
      assert(false, 'Input to "justify" should be a step ({1})', step);
    }
  }
  // Give the new step the specified ruleName.
  result.ruleName = ruleName;
  // Make the step be its own original, for uniform access to an original.
  // TODO: Stop doing this, to distinguish StepDisplay objects from Steps.
  result.original = result;
  // Give this step its own new ordinal.
  result.ordinal = stepCounter++;
  // Carry other information forward.
  result.ruleArgs = Array.from(ruleArgs);
  result.ruleDeps = ruleDeps;
  return result;
};

export interface Expr {
  /**
   * Considering a potential rewriting of step2 at the given path, with
   * the given substitution map, and with this as the fact, returns a
   * renaming substitution into this that keeps free variables of this
   * fact distinct from those of step2 as much as is consistent with the
   * rewrite.
   *
   * The map argument must include no-op mappings, as produced by
   * matchSchema, from a name to the same name.
   *
   * TODO: It appears desirable in some cases to rename free variables
   *   of this to be captured by bound variables at the target site.
   *   Consider supporting that option in some way, not necessarily
   *   here.
   */
  distinctifier(step2, path_arg, map);
}
Expr.prototype.distinctifier = function(step2, path_arg, map) {
  const keys = new Set(Object.keys(map));
  // The substitution into this followed by replacement adds only
  // these retained variables as free in the result.  The substitution
  // itself only results in free variables that are already free in
  // step2, and eliminates ones only in the map keys.
  const retained = Toy.setDiff(this.freeVarSet(), keys);
  if (retained.size === 0) {
    // No renaming will be needed.
    return {};
  }
  const free2 = step2.freeVarSet();
  const boundNames =
        new Set(step2.pathBindings(step2.asPath(path_arg)
                                   .uglify(step2.implies()))
                .keys());
  // TODO: XXX This looks broken, names vs Atoms.
  const avoidNames = Toy.union(free2, retained, boundNames);
  const result = {};
  // The result of applying the substitution and then replacing
  // some part of it with the RHS of 
  for (const name of retained) {
    // Remember: retained variables being renamed must stay distinct.
    const v = (free2.has(name) || boundNames.has(name)
               ? Toy.genVar(name, avoidNames)
               : new Atom(name));
    avoidNames.add(v);
    result[name] = v;
  }
  return result;
};

/**
 * Utility that takes arguments as for R2 and returns false
 * if any variable bound at the target site is in both the
 * assumptions and RHS of the equation.
 */
export function boundVarsOK(target, path, equation) {
  if (equation.isCall2('=>')) {
    const hypFreeNames = equation.getLeft().freeVars();
    const eqFreeNames = equation.getRight().freeVars();
    const boundNames = target.boundNames(path);
    for (const name in boundNames) {
      if (name in hypFreeNames && name in eqFreeNames) {
        return false;
      }
    }
  }
  return true;
}

//
// Utility functions
//

/**
 * Processes an object/set or string as a set of labels.  If it is a
 * string, converts it to an object/set by treating it as a
 * space-separated list of words.  If the object/set is empty
 * returns one containing just "none", for convenience.
 */
export function processLabels(labels) {
  switch(typeof labels) {
  case 'string':
    var result = {};
    const array = labels.split(/\s+/);
    if (array.length) {
      array.forEach(function(label) { result[label] = true; });
      return result;
    } else {
      return {none: true};
    }
  case 'object':
    return labels;
  default:
    assert(!labels, 'Bad labels: {1}', labels);
    return {none: true};
  }
}

// Constants related to description.
const descriptors = new Set(['exists1', 'the', 'the1']);

// Computes the fact's set of menu categories based on its metadata
// and goal, and stores them as info.categories.  The categories are
// like menus, but can be more fine-grained, each menu displaying a
// characteristic set of categories.
function computeMenuCategories(info) {
  const stmt = info.goal;
  const categories = new Set;

  for (let label in info.labels) {
    const category = categoryOfLabel[label];
    assert(category, 'No category for label {1}', label);
    if (category !== 'default') {
      categories.add(category);
    }
  }

  if (categories.size === 0) {
    // TODO: Consider moving this computation to fact registration time.
    const introDescrip = () => {
      const factConsts = stmt.constantNames();
      return Toy.intersection(factConsts, descriptors).size > 0;
    };

    // If the labels alone do not determine a category, look for
    // implicit category(s) based on the statement of the rule and
    // metadata other than labels.
    const category =
          (info.desimplifier ? 'desimplifier'
           : info.simplifier ? 'simplifier'
           : introDescrip() ? 'descriptors'
           : stmt.matchPart().isVariable() ? 'varMatch'
           : 'general'
          );
    if (category) {
      categories.add(category);
    }
  }

  info.categories = categories;
}

// Maps fact labels to categories.  Private to computeMenuCategories.
const categoryOfLabel = {
  // The "none" label is assigned automatically when no labels
  // are given.
  none: 'default',
  // The "none" category means "do not offer this fact".
  primitive: 'none',
  ignore: 'none',
  // The remaining labels occur in one or more facts today.
  display: 'edit',
  uncommon: 'other',
  advanced: 'other',
  algebra: 'algebra',
  // The algebra2 name suggests "algebra, but not usually a good idea".
  algebra2: 'other',
  general: 'general',
  basic: 'general',
  higherOrder: 'default',
  // The "backward" label is for facts useful for backward reasoning,
  // though it usually can be inferred from the assumptions of the fact.
  backward: 'backward',
  forward: 'forward',
};

/**
 * Tests whether the given goal (wff) has a type (real number)
 * assumption.
 */
function hasTypeAsm(goal) {
  const asms = goal.getAsms();
  return asms && asms.scanConj(t => !!t.isTypeTest());
}

// Used to order execution of proof steps so they can display
// in order of execution in an automatically-generated proof.
// This increments on every call to "justify".
// Conceptually it could be incremented just by rule R.
var stepCounter = 1;

export function getStepCounter() {
  return stepCounter;
}

/**
 * A simplification function that does nothing, useful as the
 * auto-simplifier for rules that want to suppress simplification.
 */
export function noSimplify(step) {
  return step;
}

export interface Path {
/**
 * Adjusts a path to account for application of a typical rewrite rule
 * that could prefix the path with /right, given a step that is the
 * input to the rewrite and a step that is the result of the rewrite.
 * Apply the adjustment to get the corresponding part of the output
 * given a path into the input step.
 *
 * Caution, currently unused.
 */
adjustForRewrite(input, output);
}
Path.prototype.adjustForRewrite = function(input, output) {
  return (!input.isCall2('=>') && output.isCall2('=>')
          ? Toy.asPath('/right').concat(this)
          : this);
};

export interface Expr {
  andThen(name, ...args);
  swap();
  rewrite(path, fact);
}
/**
 * These become methods on steps, set up by Step.justify.
 */
var ruleMethods = {

  /**
   * Applies the named rule to this Expr and any other given arguments
   * as if by a call to Toy.rules[name](args).
   */
  andThen: function(name, ...args) {
    var rule = rules[name];
    assert(rule, 'No rule with name "{1}"', name);
    var result = rule.apply(rule.info, [this, ...args]);
    return result;
  },
      
  /**
   * Swaps the sides of an equational fact.  Mainly useful when the
   * fact is named.
   */
  swap: function swap_method() {
    return rules.eqnSwap(this);
  },

  /**
   * Applies rules.rewrite to this Expr passing in a path and
   * fact to use.
   */
  rewrite: function rewrite_method(path, fact) {
    return rules.rewrite(this, path, fact);
  }
};
Toy.addMethods(Expr, ruleMethods);


//
// Inference rules, axioms, theorems
//

// Map from rule name to function used in all proofs.
// This is a central global variable.
//
// TODO: Part of a proof context.
export var rules: Record<string, any> = {};

//// RULE PROPERTIES

// The following rule properties are available directly when calling
// addRule.
//
// Properties:
//
// action: function implementing the inference rule.  Calling
//   rules.<ruleName> calls this after calling the precheck if any.
//   If there is a precheck, see information on precheck, below.  If
//   action2 is present, see information on it below.  Each rule must
//   have action or action2, but not both.
//   
//   This property triggers installation of an "attempt" property
//   on the generated rule.  If the rule has a precheck, "attempt"
//   runs that, then the main part of the rule, or just
//   the result of the precheck if that is falsy.  The action2
//   property, next, also generates "attempt".  Either way,
//   "attempt" returns a proof step on success, otherwise some
//   failure indication from the rule.
//
// action2: if present, the action must return a continuation function
//   on success.  The continuation returns a proved step.  This is not
//   for controlling menus or display.  When present, this makes the
//   rule function be a wrapper around the action, calling it,
//   checking the result, then invoking the continuation and
//   automatically justifying the result.  If the return value is not
//   a continuation, the call aborts.  The action, aliased as "prep"
//   in this case, has access to the info as "this".
//
//   Also creates "attempt" and "attempt0" methods that run the
//   continuation if a function is returned from "prep", otherwise
//   returning the non-continuation result of the "prep".  Attempt0
//   is the same except it does not auto-justify the step.
//
// proof: for a theorem (no args), use this instead of "action".  Do
//   not call "justify", that is done automatically and the proof is
//   memoized.  For a theorem, this may be given as an array of steps
//   encoded as text in the usual manner.
//
//   In this case, running "attempt" is the same as the plain rule.
//
// name: name of the rule, axiom or theorem; required if it is a rule
//   of inference with one or more arguments (see below).  Used to
//   look up the rule in "rules".
//
// statement: for a theorem, this wff or string states the theorem
//   proved, with the statement added as the fact.  If a string, it is
//   parsed with mathParse.  If the statement is an equation, with or
//   without assumptions, and its converse is not already added when
//   the theorem is added, its converse will be added as a fact.  Also
//   used by tests.
//
// goal: synonym for statement.
//
// definition: for a definition, this is a statement, often of the
//   form <name> = <term>, that defines the new constant name.  Once
//   the definition is made, this statement is taken as true, as if it
//   were a new axiom, but without danger of creating a contradiction.
//   Other forms can also be used as definitions if justifying facts
//   are proved.  See the function "definition" for more details.
//   
// precheck: if present, a function that must accept the same
//   arguments as the main action.  When the rule action is called, it
//   will call this automatically, followed immediately by the
//   declared action function.  The RuleMenu uses it as well, to rule
//   out inapplicable rules.
//
//   This is expected to return a falsy value if the rule
//   is not applicable to the arguments. (The  plain rule will
//   fail with Toy.abort.)  Otherwise it should return any data useful
//   to the main action function, which will have access to that
//   result through the global temporary Toy._actionInfo.
//
//   To call the precheck directly, refer to rules.<rulename>.precheck.
//   A call to rules.<rulename>.main will automatically receive the
//   result of the most recent precheck.
//
// main: If the rule has a precheck, this will have the main action as
//   its value, and client code may call it after the precheck and
//   before invoking any other rule.
//
// onFail: if a rule's action function is called in the ordinary
//   manner, and it has precheck, and the precheck fails, then its
//   onFail action will run with access to the rule object as "this".
//   If no onFail action is given, a rule with a precheck will
//   return a strict error on failure of the precheck.
//
// inputs: object/map from type to argument number(s), either a single
//   number or an array if more than one such argument.  These
//   currently determine whether a step accepts a selected step or
//   site, also parsing of items in forms.  Most rules accept
//   arguments in string form and convert them as needed internally.
//
//   The supported types are:
//     step: Matches any proof step.
//     equation: Matches a proof step that is an equation.
//     implication: Matches a proof step that is a conditional
//     term: Matches any term.
//     varName: Name suitable for a variable.
//     string: Arbitrary nonempty string.
//     optString: Optionally empty arbitrary string.
//     site: Term in a step; the rule expects the term's step and path
//       to the term as inputs.
//     reducible: Site that matches a call to anonymous function (lambda)
//     bindingSite: Site matching a variable binding (as in "renameBound").
//     ed: for pseudo-rules (editing), the proof editor, filled by
//       argsFromSelection.  
//
// TODO: Consider defining a new form of input descriptor.  Every rule
//   with the new property would be a "fancy" rule whose action
//   function has the appropriate name, that automatically converts
//   its inputs based on its input descriptor.  For each of these
//   define a rule 'fast_' + name to be the simplest form.
//
// data: TODO: obsolete, remove this.
//   If a rule has a "data" property, set rules[ruleName] to a
//   wrapper function that runs the user-written action function with
//   "this" bound to the wrapper and the "data" object as the "data"
//   property of "this".  If the value of the info data property is a
//   function, this.data will the result of applying it to no
//   arguments once during rule setup.
//
// minArgs: Number of required args for the action.  Supply a
//   value here to make trailing arguments optional in the step editor.
//
// maxArgs: Optional maximum number of args to pass to the rule.
//   Unless already present, added automatically by addRule when
//   making a rule, based on the number of declared function
//   arguments for "action".
//
// toOffer: function of displayable step and optional term within the
//   step, or a string containing expression to return from such a
//   function, with arguments "step", and "term".  The step and term
//   in this case belong to the rendering of the step, and have type
//   annotations.  These are assigned the selected step and term, or
//   null if not selected, and if the function returns a falsy value,
//   the step editor will not offer it.
//
// form: HTML template for the rule's input form to be presented by
//   the step editor, as a template allowing {term} for the selected
//   term.  StepEditor will never offer a rule without a form
//   property, at least an empty one.
//   TODO: Separate out this kind of non-offerability.
//
// menu: plain text for the rule's menu item (may become HTML in the
//   future), as a template allowing {term} for the selected term or
//   {right} for a possible term to its right ("group with"); <input
//   class=data-arg=n> for a display of the nth ruleArg that is an
//   Expr.
//
// menuGen: function to return zero or more menu entries for
//   application(s) of the rule.  It will be passed the ruleName,
//   step, selected term or null if none, and the ProofEditor for
//   which it is generating the menu.  A falsy value indicates no menu
//   entries; a non-empty string is for one entry.  An array of one or
//   more plain objects give full menu information, with properties
//   ruleName (string), ruleArgs (Array), optional priority (number
//   where highest will display first), html (string), and optional
//   $node, which overrides the html for controlling the menu item
//   display.  (In this case the html still controls sorting.)  The
//   html property has the effect and format of the plain "menu"
//   property described above.  A returned empty string ruleName
//   indicates a rule menu comment, and never attempts to run a rule.
//
// tooltip: plain text to become the title attribute of mentions of the
//   rule name in proof displays and the description in subproof displays.
//
// result: For theorems with no parameters only; this is the statement
//   of the theorem.  If given as text in ruleInfo, converted into an
//   expression in "rules".
//
// description: HTML word or phrase for use in one-line description,
//   or function to compute it, as in rules.fact.  If beginning with
//   "=", name of a "step formatter" in stepFormatters follows.
//   Either sort of function receives the step as argument.
//
// labels: space-separated list of words to categorize the rule,
//   influencing the rules modes in which it will be offered.  If none
//   are given, effectively a single label "none".  See processLabels
//   for more details.
//
// with: space-separated list of words to provide other properties of
//   the rule or fact, not related to menu offerings.  Accessed in the
//   factInfo like info.with.fubar, as individual properties.
//
// isRewriter: true to highlight on hover like a rewrite rule.
//   TODO: Consider removing this as unnecessary.
//
// inputSide: may be 'right' to indicate that the rule uses
//   the converse equality (rewrites matching the right side of the
//   equation rather than the left side).
//
// noSuggest: pseudo-rules may have side effects and return true on
//   success rather than a new step.  Such should have this property
//   with value true, and the rule itself should return true.  This
//   property prevents the rule from running to produce a suggestion.
//
// internal: write-only property, set to true for rules that have
//   no inputs property given.

// Inference rules (not theorems or facts) can have methods:
//
// precheck: if a precheck is given.
// prep: if there is an action2.
// check: prep or precheck as appropriate.
// attempt: check, and if that succeeds tries the rest of the rule.
//   If check fails, returns its result value.
//
// Toy.ok is a function for testing precheck and prep results.

// Rule definitions that have statements (and are thus theorems)
// support the same properties as facts, specifically: simplifier,
// desimplifier, noSwap, labels, and converse (for properties of facts
// that have a swapped version).  For more information see addFact.

/**
 * Process the given plain object into form for inclusion into
 * Toy.rules and add the resulting rule or rules.  This does not do
 * inference, so it can be called before any theorems are proved.
 */
export function addRule(info) {
  const fmt = Toy.format;

  var name = info.name;
  if (name && rules[name]) {
    console.warn('Inference rule with name', name,
                 'already declared; ignoring.');
    return;
  }

  info.labels = processLabels(info.labels);
  info.with = new Set(info.with ? info.with.split(' ') : []);

  // DEFINITIONS
  if (info.definition) {
    definition(info.definition);
    return;
  }

  var statement = info.statement || info.goal;
  if (info.statement && info.goal) {
    console.warn('Fact has both statement and goal',
                 info.statement.toString(),
                 info.goal.toString());
  }

  // This will become the "rule object", a function:
  var rule;
  // True iff the main function has access to the rule object as "this".
  var mainHasThis = false;
  // If the rule (theorem) has an explicit statement (which should be
  // provably true), coerce the statement to an Expr if given as a
  // string.
  if (typeof statement === 'string') {
    // TODO: Try to avoid using mathParse here.
    statement = info.statement = Toy.mathParse(statement);
  }

  let proof;
  if (info.proof) {
    // There is a proof.
    assert(statement, 'Rule {1} has proof, needs statement.', name);
    assert(!info.action && !info.action2,
           'Both proof and action for {1}', name);
    // Coerce the proof to a proof function.
    proof = check(Toy.asProof(info.proof));
  }

  if (statement) {
    // A statement or goal was given.
    if (!proof) {
      // If there is a statement but no proof, set up a proof that
      // asserts the statement.
      proof = function() {
        return rules.assert(statement);
      }
      if (!info.axiom) {
        console.warn('No proof, asserting', name || statement.toUnicode());
      }
    }

    // Now statement and proof are both initialized.
    // We will now add a fact and potentially a swapped fact.

    // Add it as a fact also, and potentially "swapped".
    // A fact needs a statement, so we rely here on having a statement given.
    //
    // TODO: Use factProperties and remove this.
    var factXferProps = {
      axiom: true,
      description: true,
      simplifier: true,
      desimplifier: true,
      noSwap: true,
      labels: true,
      with: true,
      converse: true
    };
    // Accept selected fact properties in the rule metadata.
    var properties = {goal: statement, proof: proof} as Record<string, any>;
    for (var k in factXferProps) {
      if (k in info) {
        // Uncomment this for detailed tracing.
        // console.warn('Adding', k, 'to', name);
        properties[k] = info[k];
      }
    }
    addFact(properties);
    if (!properties.noSwap) {
      addSwappedFact(properties);
    }
    // There is no name, so we are done.
    if (!name) {
      return;
    }
  }

  let main = proof;

  if (proof) {

    // This rule has a statement, a proof, and a name.  It is a
    // theorem.  Run the proof function at the first request, and
    // thereafter only re-justify the result so there is a new Step
    // object.
    rule = function() {
      if (rule.result) {
        // Re-justify on each request so each request has its
        // own proof line.
        return rule.result.justify(name, []);
      }
      // TODO: Prevent circularity as for facts.
      const result = rule.result = proof();
      if (!result.matches(statement)) {
        console.warn('Caution: proof differs from goal.',
                     '\nProved:', result.toString(),
                     '\nStated:', statement.toString());
      }
      return result.justify(name, []);
    };

    // Make "<rule>.attempt" the same as the rule.
    rule.attempt = rule;
    
    // Describe theorems as "theorem" by default.
    // The theorem name will be added as ruleName into the tooltip.
    if (!('description' in info)) {
      info.description = 'theorem ' + name
    }

  } else {
    //
    // It is a rule of inference, not an axiom, theorem, or fact.
    //
    assert(name, 'Inference rule must have a name', info);
    assert(!(info.action && info.action2), 'Action and action2 are exclusive.');
    // The action property is the user code to run it.
    main = info.action || info.action2;
    assert(typeof main === 'function',
           'Rule action must be a function: {1}', name);
    if (info.maxArgs == null) {
      info.maxArgs = main.length;
    }
    if (info.minArgs == null) {
      info.minArgs = main.length;
    }

    if (info.action2) {
      // If the "prep" phase succeeds, it will return a continuation,
      // and that will return the result of the rule.  If it fails,
      // the basic variant aborts.  This kind of rule includes the
      // "justify" step automatically, but you must be sure not to
      // pass a proved step where a term is needed.
      //
      // TODO: Check "result" more carefully.  The "more" function
      //   should only ever return a proved statement, so presumably
      //   report an error in all other cases.
      rule = function( ...args) {
        const more = main.apply(info, args);
        if (typeof more === 'function') {
          const result = more();
          if (result) {
            return result.justify(name, args, args.filter(x => Toy.isProved(x)));
          } else {
            // TODO: Consider how to better handle a falsy result.
            abort('Falsy result from rule {1}', name);
          }
        } else {
          abort(Toy.errify(more, `Rule ${name} prep failed`));
        }
      };
      // Set rule.prep to the "prep phase".
      rule.prep = main;
      rule.check = main;

      // The "attempt" method tries to run the method and
      // continuation, but if the result from "prep" is not a
      // function, simply returns that value.
      rule.attempt = function( ...args) {
        const more = rule.prep.apply(info, args);
        if (typeof more === 'function') {
          const result = more();
          if (Toy.isProved(result)) {
            return result.justify(name, args, args.filter(x => Toy.isProved(x)));
          } else {
            return result;
          }
        } else {
          return more;
        }
      };

      // The attempt0 method runs the rule inline; like "attempt", but
      // no auto-justification.
      rule.attempt0 = function( ...args) {
        const more = rule.prep.apply(info, args);
        if (typeof more === 'function') {
          return more();
        } else {
          return more;
        }
      };

    } else if (info.precheck) {
      // There is a precheck.
      var checker = function(... args) {
        return Toy._actionInfo = info.precheck.apply(main, args);
      }
      // TODO: Consider communicating through the "this" argument
      //   to the main rule instead of the global variable, e.g.
      //   this.precheck.
      rule = function( ...args) {
        checker.apply(null, args);
        const checked = Toy._actionInfo;
        return (checked && !(checked instanceof Error)
                ? main.apply(info, args)
                : checked instanceof Error
                ? abort(checked)
                // Here checked is falsy.
                : abort('Rule {1} not applicable to {2}', name, args.$$));
      }
      // Set properties on the outer action to give access to the
      // main from the the precheck.
      rule.precheck = checker;
      rule.check = checker;
      rule.main = main;

      rule.attempt = function( ...args) {
        const v = rule.precheck.apply(info, args);
        return ok(v) ? rule.main.apply(info, args) : v;
      };

      // Assert that the main code has access to data and metadata
      // through "this".
      mainHasThis = true;
    } else {
      // There is no checker.  Set up rule.attempt anyway.
      rule = main;
      rule.attempt = main;
    }
  }

  // The following code applies to all rules, axioms, theorems and
  // inference rules.

  assert(rule, 'Oops');
  assert(!info.data, 'Info.data is obsolete');

  // Set up remaining metatadata.

  // Give every info "inputs".
  if (!info.inputs) {
    info.internal = true;
    info.inputs = {};
  }

  // Default the description to the marked up formula or the ruleName.
  if (!('description' in info)) {
    // The name could be undefined.
    info.description = name;
  }
  // Remember the basic tooltip
  info.basicTooltip = info.tooltip;

  // If there is a toOffer property with string value, coerce it
  // to a function of step and path.
  if (typeof info.toOffer === 'string') {
    info.toOffer = new Function('step, term', info.toOffer);
  }
  // Make the action function available here also as "this".
  if (typeof info.toOffer === 'function') {
    info.toOffer = info.toOffer.bind(rule);
  }

  // Add all metadata as the function's "info" property.
  rule.info = info;
  
  if (name) {
    // Include the rule name in the tooltip.
    info.tooltip = Toy.format('{1} ({2})', (info.tooltip || ''), name);

    // Assign a name to the wrapper and main.
    if (rule !== main) {
      Object.defineProperty(rule, 'name',
                            {value: name + '_wrapper'});
      Object.defineProperty(main, 'name', {value: name});
    } else {
      Object.defineProperty(rule, 'name', {value: name});
    }

    // Finally install the rule into the rules.
    rules[name] = rule;
  }
}

/**
 * Takes an arbitrary number of arguments, each in the form
 * accepted by addRule, and performs addRule on each.
 *
 * Prefer this over addRule, addRules, or addFact for adding new
 * facts, rules, and definitions.
 *
 * Extends addRule by allowing "fact:" in place of "statement:"
 * and ignoring arguments that are not plain objects.  Evaluation
 * of any such arguments occurs before calling "declare".
 */
export function declare(...declarations) {
  for (const decl of declarations) {
    if (decl && decl.constructor === Object) {
      if (decl.fact && !decl.statement && !decl.goal) {
        decl.statement = decl.fact;
        delete decl.fact;
      }
      addRule(decl);
    }
  }
}

/**
 * Returns truthy iff the given result (of a rule attempt)
 * is truthy and not an Error.  Useful utility for tactics
 * to test applicability of rules or to test if a rule
 * attempt, i.e. <rule>.attempt(...) is successful.
 *
 * If a "more" continuation is given and the result is a success
 * ("ok"), returns the continuation, else the failure result,
 * for use in action2 rules.
 * 
 * The implementation is rather loose to support prep, precheck,
 * and attempt all in one.
 * 
 * TODO: Rename the one with 2 arguments as ok2 (for action2 rules).
 */
export function ok(status, more?) {
  if (more) {
    return ok(status) ? more : status;
  } else {
    return status && !(status instanceof Error);
  }
}

//// Exercises
  
// This maps from an exercise name to its declarations.
export var exercises = new Map();

/**
 * Declares an exercise with a number of declarations.  This is like
 * the declarations function, but is specific to exercises and requires
 * the name of the exercise as its first argument.
 */
export function exercise(name, ...declarations) {
  const decls = exercises.get(name) || [];
  decls.push(...declarations);
  exercises.set(name, decls);
}


//// Essential uniqueness

// This concept applies to a carrier set and one or more functions of
// one or more arguments from that set, a.k.a. a "structure".
//
// The objects satisfying some property, or wlog some conjunction of
// properties, are essentially unique iff all such structures
// associated with those properties are isomorphic to each other.
//
// A structure is associated with a conjunction of properties iff the
// properties are true of its carrier set, functions, and predicates.


/**
 * Adds the given definition as a new fact provided it meets the
 * requirements for definitions.  It must define a named constant that
 * is neither already defined nor otherwise known as a constant.  The
 * argument is a wff to be asserted as true.  The new constant name
 * must be the one and only free new name.  If the wff is in string
 * form, this parses with termify.
 *
 * If it is of the form:
 *
 * <name> = <term>
 *
 * where <name> is a (new) constant name and <name> does not occur
 * free in <term>, this accepts the equational definition.  It also
 * adds related facts using addDefnFacts if the definition is a
 * function or predicate defined equal to a lambda.
 *
 * If it is of the form:
 *
 * <name> <var> . . . = <term>
 *
 * where the <var>'s are variable names, this converts the equation to
 * the equivalent first form and processes the result accordingly.
 * (This is the idiomatic traditional form of function and predicate
 * definitions.)
 *
 * If the definition has some other form, then there must be a
 * recorded fact of the form: exists {<var>. <condition2>}, where
 * <var> is a variable name that does not occur free in the condition,
 * and condition2 is the result of substituting <var> for <name> in
 * the condition.  Of course the recorded fact could use exists1 in
 * place of exists.
 * 
 * This also registers the type of the new constant, fixing it
 * permanently. Note that the first asserted statement containing
 * the name of a constant also serves to register that constant's type.
 *
 * TODO: If there is an "exists1" fact, this should automatically
 * generate a fact, with proof, that anything having the property is
 * equal to the new constant.
 *
 * TODO: Just existence does not seem to be enough to make such a
 * "constant" worth defining, so scratch that.
 *
 * TODO: Support pseudo-constants based on structures, where a
 * structure is a carrier set and a set of functions from the set to
 * itself, of one or more arguments.  If the structure is "essentially
 * unique", meaning all such structures are isomorphic, define a
 * new constant.
 *
 * TODO: Perhaps appropriate top-level forms might be: "fact", "rule",
 * and "definition".  Each would just add its item to a global list,
 * perhaps even the same global list.  Additionally, the top-level
 * form might do some bookkeeping and report errors, at least for
 * definitions.  These can run at top-level in modules where the logic
 * is available.
 *
 * TODO: Considering allowing a "properties" argument for properties
 * for generated facts, or provide a way to declare fact properties
 * separately from proof of the fact.
 *
 * TODO: Fix the alleged support for benign redefinitions.
 *
 * Returns the newly-defined name.
 */
export function definition(defn_arg) {
  const definitions = Toy.definitions;
  let candidate: EType = justParse(defn_arg);
  // Free occurrences of names of constants that do not have
  // definitions.  We check this before adding any facts that
  // may reference the defined name.
  const news = candidate.newConstants();
  // This has the values in the set, in insertion order.
  const newList = Array.from(news);

  // Check that there is exactly one new constant here, and that it
  // appears only in the LHS of the equality.
  assert(newList.length > 0,
         'Definition {1} needs a fresh constant name.', defn_arg);
  assert(newList.length === 1,
         'Definition {1} has multiple new constants {2}',
         defn_arg, newList.join(', '));
  const name: string = newList[0];
  if (candidate.isCall2('=')) {
    // The name must not appear in the RHS.
    const rhsNames = candidate.getRight().newConstants();
    assert(!rhsNames.has(name),
           'Definition of {1} refers to {1}', name);
  }

  // This checks for a definition in "infix form", with the new constant
  // function or predicate in the middle of three Atoms on the left.  If
  // so, register it as infix, and rearrange the LHS so it is prefix.
  function handleInfix() {
    let left = candidate.getLeft();
    const parts = left.asArray();
    // If the lhs side has the form v1 C v2, treat C as the constant
    // being defined, and declare it with a default precedence.
    if (parts.length == 3) {
      const mid = parts[1];
      if (mid.isNamedConst()) {
        left = call(mid, parts[0], parts[2]);
        addConstants([mid]);
        const name = mid.name;
        // Give it a default infix binding power.
        precedence[name] = infixPower;
        candidate = infixCall(left, '=', candidate.getRight());
      }
    }
  }
  handleInfix();
  // Now it is safe to calculate type information.
  candidate = candidate.typedCopy();
  // Register the single new name as a constant.
  Toy.addConstants(newList);
  // Register the type of the new constant.
  candidate.registerConstants();
  // Notice that all of this constant registration is done before the
  // definition is potentially asserted as true in normalizeDefn.

  // Normalizing does some deduction, so ensure it is done only after
  // logic is loaded.
  const addFacts = () => {
    const defined = new Atom(name);
    // The defn is the definition in standard form: <constant> = <term>.
    const defn = normalizeDefn(candidate);
    // TODO: Is the best place to assert it?
    const assertion: EType = rules.assert(defn);
    if (defn.isCall2('=') && defn.getLeft().isNamedConst()) {
      // Allow benign redefinition same as an existing one.
      const name: string = defn.getLeft().name;
      const prev = definitions[name];
      if (prev instanceof Expr && prev.matches(defn)) {
        // If it does not match, later checks will flunk it.
        console.log('Benign redefinition of', name);
        return name;
      }
    }
    if (defn.isCall2('=') &&
        defn.getLeft().matches(defined) &&
        Toy.isEmpty(defn.getRight().newConstants())) {
      // It is a classic equational definition.
      // Add it to the facts andthe definitions database.
      addFact({goal: assertion, definition: true,
               desimplifier: !(assertion.getRight() instanceof Atom)});
      definitions[name] = assertion;
      addDefnFacts(assertion);
    } else {
      // It is not a classic equational definition.
      var x = Toy.genVar('x', defn.allNames());
      // Substitute the fresh variable for the constant name.
      var body = defn.subFree1(x, name);
      var exists1 = Toy.call('exists1', Toy.lambda(x, body));
      if (isRecordedFact(exists1)) {
        // TODO: Add the fact that only one value has the property.
        console.warn('Not using exists1 fact for {1}.', defn);
      } else {
        var exists = Toy.call('exists', Toy.lambda(x, body));
        assert(isRecordedFact(exists),
               'Definition {1} needs an existence fact.', defn);
      }
      // Assert that the definition is true, and add to the definitions.
      addFact({goal: defn, definition: true});
      definitions[name] = defn;
    }
  };
  if (deferringDefnFacts) {
    deferredDefnFacts.push(addFacts);
  } else {
    addFacts();
  }
  return name;
}

/**
 * Converts an equational wff in the traditional idiomatic form for
 * function and predicate definitions into the basic form accepted
 * above.  Private to "definition" above.
 *
 * If the input is an equation, asserts it and (attempts to) return a
 * proved statement based on that assertion.  If not in that form,
 * just returns its argument.
 *
 * Happily this makes good use of equations with "==", as for "in" /
 * "element of", defining a boolean-valued function (predicate).
 */
function normalizeDefn(defn_arg: EType) {
  if (!defn_arg.isCall2('=')) {
    return defn_arg;
  }
  let left = defn_arg.getLeft();
  let right = defn_arg.getRight();
  while (left instanceof Call) {
    assert(left.arg.isVariable(), 'Not a variable: {1}', left.arg);
    right = Toy.lambda(left.arg, right);
    left = left.fn;
  }
  const result = Toy.infixCall(left, '=', right);
  return result;
}

// Set to false when defn facts can be proved immediately.
//
// TODO: Part of a proof context.
let deferringDefnFacts = true;

// Functions to compute defnFacts when the needed support is ready.
export const deferredDefnFacts = [];

/**
 * Call this to prove deferred facts and cease deferrals.
 */
export function enableDefnFacts() {
  deferringDefnFacts = false;
  deferredDefnFacts.forEach(function(f) { f(); });
  deferredDefnFacts.length = 0;
}

/**
 * This function only has effect for equational definitions
 * of the form <atom> = <term>, in Expr form.
 *
 * If it is a function definition (the term is a lambda), it generates
 * a basic equational fact for application of the function or
 * predicate to arguments.  In other words if f = {x. <term>},
 * generates the fact f x = <term>, and similarly if there are
 * multiple arguments.
 *
 * This is intended mainly for use from Toy.definition.
 */
export function addDefnFacts(definition) {
  if (definition.isCall2('=') && definition.getLeft().isNamedConst()) {
    // Add the converse as a simplifier.
    const eqn0 = rules.fact(definition);
    let eqn = eqn0;
    let lambda = eqn.getRight();
    addSwappedFact({goal: definition,
                    desimplifier: !(lambda instanceof Atom),
                    definitional: true});
    while (lambda instanceof Lambda) {
      eqn = (rules.applyBoth(eqn, lambda.bound)
             .andThen('reduce', '/right'));
      lambda = eqn.getRight();
    }
    // TODO: Consider adding a fact unconditionally, and treating
    //   it automatically as a desimplifier.
    if (eqn != eqn0) {
      // Flag the fact as being essentially the same as the definition
      // of the function or predicate.
      addFact({goal: eqn, definitional: true, desimplifier: true});
      addSwappedFact({goal: eqn, definitional: true, simplifier: true});
    }
  }
}


//// FACTS

//// About factInfo objects.  These are plain objects with properties:
//
// axiom: boolean, true iff recorded as an axiom  
// categories: computed from the labels, these determine the menu(s)
//   on which the fact may be offered.  Each menu offers facts from a
//   configured set of categories.
// goal: Expr statement of the fact, with all assumptions.  All
//   variables are exactly as declared, though functions such as
//   mathParse may add assumptions before returning the Expr.
// description: string with brief documentation
// labels: object / set of labels like the ones for rules
// simplifier: true if this is an equation that simplifies
// desimplifier: true if this is an equation that "desimplifies"
// noSwap: if true, inhibits automatic generation of a fact
//   with equation LHS and RHS swapped
// prover: function intended to prove the fact
// proved: proved statement or falsy if not yet proved
// proof: user-defined proof function
// inProgress: truthy iff a proof of this fact is in progress.

//// About standard forms of statements, including fact declarations
//
// 

// Every fact declared by addFact or addRule is recorded under a
// string key that represents the consequent of the fact if it is
// conditional, and otherwise the full fact.  In either case the
// fact's (unique) fact properties object is the stored value.  This
// maps from fact key to an array of fact property objects as
// described above.  Private to factInfoMatching, setFactInfo, and
// eachFact (but see also factSquish).
//
// TODO: Consider eliminating this structure, using _resolutionsByKey
//   in its place.
//
// TODO: Part of a proof context.
export var _factsByKey = new Map();

// Fact declarations and fact references:

// A fact declaration, as in addFact, is an unabbreviated statement of
// the fact.  (If the statement is to be parsed, the parsing code
// may fill in parts, such as type assumptions, that are implicit
// in the string form.)

// Fact references appear where a fact is used, as in rules.fact or in
// rules.rewrite and its variants.  A fact reference is a wff, in the
// form of an Expr or string, and resolves to a recorded fact by the
// following matching process:
// 
// If a fact reference is not conditional, treat it as a conditional
// with an empty set of assumptions.
//
// A reference resolves to a recorded fact if and only if there is
// exactly one fact for which: 1) the consequent of the reference
// exactly matches the consequent of the fact after standardizing
// names of the free variables of each, and 2) the assumptions of the
// reference, taken as a set, are a subset or equal to the set of
// assumptions of the fact that is referred to.  This matching allows
// for changes of variable names between the recorded fact and the
// reference, provided that all free variables in the assumptions are
// also free in the consequent.

/**
 * Map from string identifying the main part of a statement to an
 * array of records of all recorded facts having that string as their
 * key.  The key is insensitive to alphabetic changes of variable
 * names.  Each record is an Object with properties "resInfo" and
 * "factInfo", where "resInfo" is a "statement resolution information"
 * object and "factInfo" is the object with all the properties of the
 * fact.  See getResInfo for details on resInfo objects.
 *
 * This could also be used to look up factInfo from a fact goal or
 * equivalent that may have different variable names or order of
 * assumptions, but that is more directly supported through
 * _factsByKey.
 * 
 * This supports fairly efficient resolution of actual or proposed
 * fact references to facts, and is used by the process that ensures
 * that no fact reference ever becomes ambiguous.
 *
 * TODO: With _factsByKey giving access to factInfo and
 * _resolutionsByKey giving access to resInfo, possibly this could
 * store just pairs of statement and fact goal.
 */
// TODO: Part of a proof context.
export const _resolutionsByKey = new Map();

/**
 * This finds and returns the factInfo object of a recorded fact that
 * "matches" the given resInfo, or null if there is none.  It does
 * this by comparing the resInfo's of fact goals with the given
 * resInfo.  (We will call the fact resInfo just "the fact" and the
 * given resInfo just "the statement", and in both cases the
 * assumptions are compared as sets.)  The main parts of the statement
 * and fact must be the same, and if the assumptions of the fact are
 * the same as the assumptions of the statement, its factInfo is the
 * result.  If the fact assumptions are a strict superset, and it is
 * the only such fact, that factInfo is the result, otherwise null.
 *
 * This is a helper for resolveFactRef.
 *
 * TODO: See TODO for resolveFactRef.
 */
export function factInfoMatching(resInfo) {
  let extender = null;
  const factPropsList = _factsByKey.get(resInfo.key);
  for (const factProps of factPropsList || []) {
    const stmtInfo = getResInfo(factProps.goal);
    if (stmtInfo.key == resInfo.key &&
        stmtInfo.asmSet.superset(resInfo.asmSet)) {
      if (resInfo.asmSet.superset(stmtInfo.asmSet)) {
        return factProps;
      } else if (extender) {
        // Multiple extenders were found, so fail.
        return null;
      } else {
        // This one is an extender, so the tentative resolution.
        extender = factProps;
      }
    }
  }
  return extender;
}

/**
 * Returns the "expansion" of a statement into a recorded fact.  The
 * given statement, preferably given as a wff, must be the same as as
 * the recorded fact, modulo alphabetic change of variables, except
 * that it may omit assumptions that are "type declarations" or "zero
 * tests" for free variables.  The result is a version of the full
 * declared fact (goal) wff of the statement, with free variable names
 * as in the given statement rather than the declaration.  Returns
 * null if there is no such declared fact.
 *
 * The rationale is that it can be convenient for the user to enter
 * the fact with fewer assumptions, and the omitted assumptions are
 * guaranteed to appear elsewhere in the fact.  (If they did not, they
 * could be dropped from the fact without effecting its truth.)
 *
 * This is the principal API entry point for resolving fact references.
 * See also resolveFactRef.
 */
export function factExpansion(stmt) {
  const resInfo = getResInfo(stmt);
  const expanded = resInfo._expansion;
  if (expanded) {
    return expanded;
  }
  const factInfo = resolveFactRef(stmt);
  if (factInfo) {
    // TODO: Catch renamings needed in the assumptions!
    const asStated = factInfo.goal.stripSomeDecls();
    const asRequested = resInfo.stmt.stripSomeDecls();
    // This check is OK as it is just a renaming.
    let map = asRequested.matchSchema(asStated);
    if (map) {
      const expansion = factInfo.goal.subFree(map);
      resInfo._expansion = expansion;
      return expansion;
    }
  }
  return null;
}

/**
 * This returns a factInfo object with information about the unique
 * recorded fact that the given statement can expand into, or
 * null if there is none.  The expansion will use free variables
 * from the given statement in place of ones from the declaration
 * of the fact.
 *
 * The statement can use different variable names than the fact,
 * and it may omit some kinds of assumptions if they are not required
 * to uniquely identify a recorded fact.  Currenetly the given statement
 * may be able to omit type declarations on variables, such as (R x),
 * or nonzero checks on variables, and any of these that are included
 * can appear in any order.  Other assumptions, if included, may have
 * to appear in the same order as stated in the actual fact.
 */
export function resolveFactRef(stmt) {
  // The resInfo is "fact resolution information" for the statemement.
  const resInfo = getResInfo(stmt);
  const resolutions = _resolutionsByKey.get(resInfo.key) || [];
  // This gets a non-null value iff stmt has already been resolved.
  const resolvent = resolutions.find(function(rec) {
      //  Use of object identity here is OK because _statementResInfos
      //  ensures that repeated lookups of the same statement object
      //  result in the same resInfo object.  Also, factExpansion
      //  currently expects distinct statement objects to have
      //  distinct resInfo objects, and sharing of resInfos among
      //  different statements would be incompatible with that.
      return rec.resInfo == resInfo;
    });
  if (resolvent) {
    return resolvent.factInfo;
  }
  // No resolution is already in _resolutionsByKey, so do the
  // hard work of actually matching.
  const info = factInfoMatching(resInfo);
  if (info) {
    resolutions.length === 0 && _resolutionsByKey.set(resInfo.key, resolutions);
    resolutions.push({resInfo: resInfo, factInfo: info});
    return info;
  }
  return null;
}

/**
 * Resolves the given statement wff to a full fact statement if
 * possible, otherwise returns null.  Like resolveFactRef, but
 * returns just the goal, as stated in the fact declaration.
 */
export function resolveToFact(stmt) {
  const info = resolveFactRef(stmt);
  return info ? info.goal : null;
}

/**
 * Returns true iff the given wff refers to a specific recorded fact
 * and has the same set of assumptions as in that fact, allowing
 * for differences in variable names.
 */
export function isRecordedFact(stmt) {
  // First check that the statement resolves to a specific fact.
  const factInfo = resolveFactRef(stmt);
  if (factInfo) {
    // Then verify that the statement and the fact are indeed
    // equivalent.
    const asms = getResInfo(stmt).asmSet;
    const factAsms = getResInfo(factInfo.goal).asmSet;
    return asms.equals(factAsms);
  }
  return false;
}


/**
 * Like getResult, below, but always proves the statement if it has
 * an associate prover function.
 */
export function proveResult(stmt) {
  return getResult(stmt, true);
}

/**
 * Accepts an already-proved step or the full statement of some
 * recorded fact.  Returns a proof of the step, or one like it except
 * for changes of names of variables including free variables.  Aborts
 * if the result of the proof does not match the stated goal or the
 * given statement does not resolve to a recorded fact.  Does not
 * catch exceptions.
 *
 * Note that the facts database currently looks up facts by their
 * "main" part, ignoring any assumptions.
 *
 * The optional second argument, for internal use only, if true,
 * overrides any setting of Toy.assertFacts and assures that a proved
 * result will be returned (if there is a prover function).
 *
 * TODO: Consider renaming to something like "stepify" and using as
 *   a conversion for inputs to steps in the vein of "termify".
 */
export function getResult(statement, mustProve?) {
  if (Toy.isProved(statement)) {
    return statement;
  }
  var info = resolveFactRef(statement);
  assert(info, 'Not a recorded fact: {1}', statement);
  return getResult0(info, mustProve);
}

/**
 * Same as getResult, but the argument is a factInfo.
 */
export function getResult0(info, mustProve?) {
  // TODO: Consider more precise checking of the result of the lookup.
  if (info.proved) {
    return info.proved;
  }
  const goal = info.goal;
  var prover = info.prover;
  if (Toy.assertFacts && !mustProve) {
    var result = rules.assert(goal);
    return result;
  }
  assert(!info.inProgress, 'Circularity proving {1}', info.goal);
  try {
    info.inProgress = true;
    // Get the proved result of the fact.
    info.proved = prover();
    assert(info.proved.isProved(),
           'Proof of {1} failed;\n  got {2}', goal, info.proved);
    info.inProgress = false;
  } finally {
    if (info.inProgress) {
      info.inProgress = false;
    }
  }
  return info.proved;
}

/**
 * Returns true iff a proof of the referenced (recorded) fact is
 * underway but not completed.  Can be used to prevent infinite
 * regress, as in the case of simplifiers that might be skipped during
 * their own proof.
 */
function isInProgress(stmt) {
  const info = resolveFactRef(stmt);
  return info && info.inProgress;
}

/**
 * JS Map from statement in wff (or currently string) form to
 * information about the statement.  The information is a resInfo
 * object computed by getResInfo.  This serves as a cache to
 * accelerate these calculations, especially given that the same
 * statements tend to be used over and over.  Private to getResInfo.
 *
 * This can support string keys, but mathParse already accelerates
 * conversion of strings to wffs.
 */
// TODO: Part of a proof context.
export const _statementResInfos = new Map();

const noTerms = new Toy.TermSet();

/**
 * Given a wff (or currently a string to parse), returns a "resInfo"
 * or "fact resolution information" object, which has information
 * useful for resolving exactly which fact the statement is intended
 * to refer to.  If given a string, this ignores a leading "@".
 *
 * The resInfo is a plain object with properties "key", "asmSet",
 * "standardVars", all related to the given fact statement, also
 * "stmt" with the exact given statement, and one more property
 * internal to factExpansion.
 *
 * The standardVars property is the stmt wff with standardized
 * variables, but with the main part first if the input is a
 * conditional.  (Precise form is (main & asms)).  The asmSet is a
 * TermSet of the standardized wff's assumptions, the key is a
 * stringification of its main part, and the stmt is the wff of the
 * stmt argument.
 *
 * A fact key is a string that represents the main body of the wff,
 * with all variables of that part replaced with standard variables so
 * the key does not depend on the names of variables supplied as the
 * statement.  The asmSet is a TermSet of the assumptions, also using
 * standard variable names.
 *
 * This remembers the association between the given statement object
 * and the resInfo to speed repeated lookups, which is the usual case
 * for fact references in rewriting rules or fact lists.
 *
 * TODO: Do the parsing in client code so different type assumptions
 *  and such can be inserted there.
 */
export function getResInfo(stmt) {
  // Computes the resolution info for the statement and caches the
  // association in _statementResInfos.
  function computeStatementInfo(stmt) {
    if (typeof stmt == 'string') {
      // Uncomment this line to get the warnings back.
      // console.warn('Deprecated: resInfo of string:', stmt);
    }
    const term = x => termify(typeof x === 'string' && x[0] === '@'
                              ? x.slice(1) : x);
    const wff = term(stmt);
    const main = wff.getMain();
    const hasAsms = wff.isCall2('=>');
    // This makes a wff with main first, and also has
    // any assumptions, ordered after the main part.  We
    // do not expect this to be a theorem.
    //
    // TODO: Avoid the potential ambiguity in case of a similar
    //   statement that is a conjunction with no assumptions.
    const wff2 = (hasAsms
                  ? Toy.infixCall(main, '&', wff.getLeft())
                  : wff);
    const standard = Toy.standardVars(wff2);
    const asmSet = (hasAsms
                    ? Toy.makeConjunctionSet(standard.getRight())
                    : noTerms);
    const key = (hasAsms ? standard.getLeft() : standard).toKey();
    const info = {key: key, asmSet: asmSet,
                  // TODO: Consider flipping this back to a conditional
                  //   if it was so originally.
                  standardVars: standard,
                  // _expansion will be initialized later.
                  stmt: wff, _expansion: null};
    _statementResInfos.set(stmt, info);
    return info;
  }
  return (_statementResInfos.get(stmt) ||
          computeStatementInfo(stmt));
}


//// Finding matching facts

/**
 * Finds a single LHS match within the given term with one of the
 * given facts.  Returns the value of the successful call to
 * findMatchingFact, with a "path" property added indicating the path
 * from the term argument to the matched term, or a falsy value if no
 * call succeeded.
 *
 * All arguments other than the term are passed via "info".  If it is
 * a plain object, it interprets the following properties:
 *
 * facts: List of facts in the format accepted by findMatchingFact.
 * context: Context information for "where" clauses as
 *   accepted by findMatchingFact.
 *   TODO: (BUG!) Accept an "isQuantified" property here, or more 
 *      detailed information, to indicate enclosing bound variables.
 * searchMethod: Name of method to apply to the term to control
 *   which subexpressions of the term to apply findMatchingFact to;
 *   defaults to 'searchMost', which searches through calls.
 *
 * If the info is an array, it must be the list of facts.
 *
 * TODO: Consider changing this to something like applyMatchingFactIn,
 *   doing essentially the same search, but attempting to apply the
 *   first fact that seems to match, and continuing the search if
 *   application fails.
 */
export function searchForMatchingFact(term, info, cxt={}) {
  var allFacts, searchMethod;
  if (info.constructor === Object) {
    allFacts = info.facts;
    info.context && Object.assign(cxt, info.context);
    searchMethod = info.searchMethod;
  } else {
    allFacts = info;
  }
  // If set to non-null, just unconditional facts.  At present only
  // includes facts that are just a statement in string form.
  // Computed here for efficiency.
  //
  // TODO: Handle more complicated facts (as needed).
  var pureFacts = null;
  searchMethod = searchMethod || 'searchMost';
  function factFinder(term, revPath, isQuantified) {
    if (isQuantified) {
      pureFacts = pureFacts || allFacts.filter(isPureFact);
    }
    // If some free variables of a conditional fact do not appear in
    // the assumptions, this may exclude it unnecessarily.
    //
    // TODO: Consider a more precise check here.
    var facts = isQuantified ? pureFacts : allFacts;
    var result = findMatchingFact(facts, cxt, term, isQuantified);
    if (result) {
      result.path = revPath.reverse().concat(result.path);
    }
    return result;
  }
  // TODO: Accurately determine quantification of the term,
  //   and use the proper information rather than a boolean
  //   to control "purity" of facts in each context.
  return term[searchMethod](factFinder, Toy.Path.empty, false);
}

/**
 * Returns truthy if the given recorded fact or fact info or tautology
 * is unconditional and so applicable in all contexts, even within
 * variable bindings.
 */
export function isPureFact(fact) {
  if (typeof fact === 'string' || fact instanceof Expr) {
    // This next line supports ordinary facts and also tautologies.
    // It relies on resolveToFact to return a conditional whenever
    // it is given a statement that has implicit assumptions.
    var fullFact = resolveToFact(fact) || termify(fact);
    return fullFact && fullFact.isCall2('=');
  } else if (fact.constructor === Object && fact.pure) {
    return true;
  }
}

// This finds the fact part to match.  If the fact is not an equation,
// uses the main part instead of the LHS.
export function schemaPart(fact) {
  var main = fact.getMain();
  return (main.isCall2('=')
          ? main.getLeft()
          : main);
}

export interface Expr {
  /** Converts a main part of the form a == T back to just A, useful for
   * presentation of a rewrite rule.  Currently unused.
   */
  withoutEqT();
}
Expr.prototype.withoutEqT = function() {
  const infix = Toy.infixCall;
  const main = this.getMain();
  const map = main.matchSchema('a == T');
  if (map) {
    return (this.implies()
            ? infix(this.getLeft(), '=>', map.a)
            : map.a);
  } else {
    return this;
  }
};

/**
 * Searches the given pattern list for one whose "schema part" matches
 * the given term.  If it finds one, returns info about it in a plain
 * object in the format described below.  The schema part of a
 * (possibly conditional) equational fact is the LHS of the equation.
 * Otherwise it is the main part: the consequent if conditional,
 * otherwise the entire fact.
 *
 * TODO: This and its users can now produce a substitution that fails
 * on account of unification.  Implement an approach to deal with
 * this issue.
 *
 * The context argument is available to "where" arguments as "cxt",
 * and any "factLists" property of the context defines lists of named
 * patterns accessible by using the name in place of an explicit list.
 * The value of the factLists property is a plain object mapping from
 * list name to a list (array) value.  In this way lists can be
 * reused, and also enables them to be effectively recursive.
 *
 * Each pattern argument can be an argument acceptable to
 * resolveToFact, or:
 *
 * A plain object with properties as follows:
 *
 * stmt: value acceptable to resolveFactRef, or a statement
 *   of a tautology.
 * where: optional string to evaluate, with "subst" 
 *   argument to findMatchingFact available as "$" and cxt and term
 *   available as free variables for use in the string.
 *   OR if it is a function, call it with the substition, cxt, and
 *   term as arguments.  The statement will only be considered
 *   to match if the result is truthy.
 *
 * For fact statements passed as list elements or the "stmt" property
 * of a list element, if proof of the fact is in progress at the time,
 * the fact is ignored in the search.  This provides a crude mechanism
 * for avoiding infinite regress, for example when simplifying steps
 * of the proof of a simplifier fact.
 *   
 * Or it can be a plain object with a single property, either:
 *
 * descend: a plain object with properties "schema", a schema
 *   (possibly in string form) to match against the term, and "parts",
 *   a plain object mapping from variable names in this schema each to
 *   a pattern list as described above. If the search reaches this
 *   "descend" item and the schema matches the term, the search
 *   descends into the parts of the term, applying each schema
 *   variable's list of facts to the part of the term matching that
 *   schema variable.
 *
 * TODO: Consider replacing "schema" and "parts" with "match"
 *   and additional properties named after some of the variables
 *   in the schema, as in walkPatterns.
 *
 * apply: a function to apply to the input term and context, which
 *   must return an equation whose LHS is the same as the term except
 *   for possible changes of bound variables, or a falsy value if it
 *   fails to produce such an equation.  The call is done by
 *   Toy.normalReturn, and this uses the value returned from that.
 *
 * The value returned is falsy if no match is found, else a plain
 * object with properties:
 * 
 * stmt: Statement of the found fact, tautology, arithmetic fact, or
 *   the equation returned by an "apply" pattern, always coerced to a
 *   wff with asWff.
 * term: the term argument to findMatchingFact.
 * subst: substitution that makes the given term match the fact (empty for
 *   "apply" patterns).
 * path: path to the portion of the given term that matched some pattern.
 *
 * If pureOnly is true, this only accepts a fact that is a pure
 * equation, with no conditions on it.
 */
export function findMatchingFact(facts_arg, cxt, term, pureOnly?) {
  // This function interprets a fact statement as a wff.
  // Currently it uses mathParse.
  // TODO: Use the context (cxt) and perhaps other information to determine
  //   this aspect of the interpretation of a fact statement, enabling
  //   fact statements here that are not interpreted as relating to real
  //   numbers.
  function interpret(stmt) {
    if (typeof stmt === 'string' && Toy.isIdentifier(stmt)) {
      return Toy.getTheoremStatement(stmt);
    } else {
      return mathParse(stmt);
    }
  }
  function apply$(expr, $) {
    if (typeof expr === 'function') {
      return expr($, cxt, term);
    } else {
      // Suppress acccess to the enclosing "facts" variable.
      // OK for str to refer to "cxt" or "term".
      var facts;
      return eval(expr);
    }
  }
  var facts = facts_arg;
  if (typeof facts_arg == 'string' && Toy.isIdentifier(facts_arg)) {
    facts = cxt.factLists && cxt.factLists[facts_arg];
  }
  for (const factMatcher of facts) {
    if (factMatcher.constructor !== Object) {
      // The factMatcher is a string or wff.
      // The stmt is a wff, so there will be no need for lower-level code
      // to decide how to "interpret" / parse it.
      var stmt = interpret(factMatcher);
      if (!isInProgress(stmt)) {
        // TODO: Change this to match before checking for inProgress,
        //   and warn when a match is rejected due to fact proof in
        //   progress.
        var fullFact = (factExpansion(stmt) ||
                        rules.arithFact && rules.arithFact(stmt) ||
                        rules.tautology(stmt));
        if (Toy.isError(fullFact)) {
          continue;
        }
        if (!(pureOnly && fullFact.isCall2('=>'))) {
          var schema = schemaPart(fullFact);
          // This substitution might not work.
          // TODO: Consider how to handle its potential failure.
          var subst = term.matchSchema(schema);
          if (subst) {
            var result = {stmt: fullFact.asWff(),
                          term: term,
                          path: Toy.asPath(''),
                          subst: subst};
            return result;
          }
        }
      }
    } else if (factMatcher.apply) {
      // "apply"
      var eqn = Toy.normalReturn(factMatcher.apply, term);
      if (eqn && !(pureOnly && eqn.isCall2('=>'))) {
        const value = {
          stmt: eqn.asWff(),
          term: term,
          path: Toy.asPath(''),
          subst: {}
        };
        return value;
      }
    } else if (factMatcher.descend) {
      // "descend"
      var partInfo = factMatcher.descend;
      // TODO: Handle pureOnly here.
      let result = _locateMatchingFact(term,
                                       partInfo.schema,
                                       partInfo.parts,
                                       cxt);
      if (result) {
        return result;
      }
    } else {
      const stmt = interpret(factMatcher.stmt);
      if (!stmt) {
        console.warn('Nothing to do in fact matcher:',
                     factMatcher);
        return null;
      }
      const factInfo = resolveFactRef(stmt);
      let goal = null;
      if (factInfo) {
        if (factInfo.inProgress) {
          return null;
        }
        goal = factExpansion(stmt);
      } else {
        goal = rules.tautology(stmt);
      }
      // TODO: Consider supporting arithmetic facts as well as
      //   recorded facts and tautologies, as for rewriting.
      if (!goal) {
        console.error('No such fact:', '' + stmt);
        return null;
      }
      // This restriction applies to tautologies also.
      if (pureOnly && goal.isCall2('=>')) {
        return null;
      }
      const schema = schemaPart(goal);
      // This substitution might fail.
      // TODO: consider how to handle its potential failure.
      const subst = term.matchSchema(schema);
      const where = factMatcher.where;
      if (subst && (!where || apply$(where, subst))) {
        var result = {stmt: goal.asWff(),
                      term: term,
                      path: Toy.asPath(''),
                      subst: subst};
        return result;
      }
    }
  }
  // If no match found the value will be falsy.
};

/**
 * This handles "descend" patterns in findMatchingFact, and is private
 * to it.
 *
 * Arguments are the term argument to findMatchingFact, the schema
 * property of the "descend" pattern, the "parts" property of the
 * "descend" pattern, and the context argument to findMatchingFact.
 */
export function _locateMatchingFact(expr, schema_arg, varsMap, context) {
  var schema = termify(schema_arg);
  var factLists = context.factLists;
  var subst;
  // This substitution might fail.
  // TODO: Consider how to handle its potential failure.
  if ((subst = expr.matchSchema(schema))) {
    return Toy.withExit(exit => {
        // Checks if the given term of the schema matches some fact in
        // the appropriate factsList.  Only schema variables are
        // eligible to match.
        function checkTerm(schemaTerm, revPath) {
          if (schemaTerm.isVariable()) {
            var list = varsMap[schemaTerm.name];
            if (typeof list == 'string' && Toy.isIdentifier(list)) {
              list = factLists[list];
            }
            if (list) {
              var result =
                findMatchingFact(list, context, expr.get(revPath.reverse()));
              if (result) {
                result.path = revPath.reverse().concat(result.path);
                exit(result);
              }
            }
          }
        }
        // TODO: Consider replacing this use of Expr.traverse with
        //   Expr.searchMost.
        schema.traverse(checkTerm);
      });
  }
}

/**
 * Beta-reduces the given term if it is a call to a lambda,
 * otherwise returns a falsy value.
 */
export function tryReduce(term) {
  return term.isLambdaCall() && rules.axiom4(term);
}

/**
 * Find and apply one of the facts to the part of the step at the
 * given path, returning the result, or null if none of the
 * facts apply.  Note: uses rules.rewrite by default; supply
 * a ruleName (fourth arg) if desired.
 *
 * TODO: Support a rule function rather than a rule name.
 */
export function applyMatchingFact(step, path, facts, ruleName='rewrite') {
  const info = findMatchingFact(facts, null, step.get(path));
  return info && rules[ruleName](step, path, info.stmt);
}

/**
 * Apply the list of fact rewrites to the "focal" part of the step
 * until none of them any longer is applicable, returning the result.
 */
export function applyToFocalPart(step, facts) {
  return applyFactsWithinSite(step, step.pathToFocalPart(), facts);
}

/**
 * Apply the list of facts as rewrites to the given part of the step
 * until none of them any longer is applicable, returning the result,
 * with asms deduped but not simplified. (?)  Returns its input step
 * if no matches are found.
 */
export function applyFactsWithinSite(step, path_arg, facts) {
  var path = Toy.asPath(path_arg);
  var eqn1 = rules.considerPart(step, path);
  var eqn2 = applyFactsWithinRhs(eqn1, facts);
  return (eqn2 == eqn1 ? step : rules.replace(step, path, eqn2));
}

/**
 * Apply the list of facts as rewrites to the RHS of the given step,
 * which must be an equation.  Repeats until none of them is
 * applicable, returning the result.  Returns its input step if no
 * matches are found.  Uses rules.rewrite, not rewriteOnly.
 */
export function applyFactsWithinRhs(step, facts) {
  var rhs;
  var info;
  var eqn = step;
  while (rhs = eqn.asPath('/main/right'),
         info = searchForMatchingFact(eqn.get(rhs), facts)) {
    var fullPath = rhs.concat(info.path);
    eqn = rules.rewrite(eqn, fullPath, info.stmt);
  }
  return eqn;
}

/**
 * Apply the function to the subexpression of step at path.  The
 * function should return a possibly conditional equation whose LHS is
 * the same as the target subexpression.  This replaces the
 * subexpression using the returned equation.
 *
 * If the function returns a falsy value, this returns that.
 */ 
export function convert(step, path, fn) {
  var expr = step.get(path);
  assert(expr, 'Bad path {1}', path, step);
  var eqn = fn(expr);
  return eqn && rules.replace(step, path, eqn);
}

/**
 * Proves that the given term is equal to something by taking it as
 * equal to itself, applying the given equation throughout its RHS,
 * rewriting the result with the given fact, then applying the reverse
 * of the equation throughout the resulting RHS.  The term can be
 * a string, while the equation can be proved steps or statements
 * of any recorded equational fact.
 *
 * Intended to capture a design pattern for proving facts about
 * "inverse" functions such as division and subtraction.
 */
export function transformApplyInvert(term_arg, eqn_arg, fact) {
  var term = termify(term_arg);
  var eqn = getResult(eqn_arg);
  var revEqn = rules.eqnSwap(eqn);
  var step1 = rules.consider(term);
  var step2 = applyFactsWithinRhs(step1, [eqn]);
  var step3 = rules.rewrite(step2, '/main/right', fact);
  var step4 = applyFactsWithinRhs(step3, [revEqn]);
  return step4;
}

/**
 * Apply the given function to the step repeatedly until the result of
 * the call is falsy or identical to its input.  Return the result of
 * the last call that was not falsy or same.
 */
export function repeatedly(step, fn) {
  var simpler = step;
  var next;
  while (true) {
    next = fn(simpler);
    if (!next || next.matches(simpler)) {
      return simpler;
    }
    simpler = next;
  }
}

/**
 * Applies the given facts repeatedly to the RHS of the given equation
 * until none matches, each time replacing the RHS with the result of
 * applying the matching fact.  Returns the last version created.
 */ 
export function arrangeRhs(eqn_arg, context, facts) {
  var rhsPath;
  var info;
  var eqn = eqn_arg;
  while (rhsPath = eqn.asPath('/main/right'),
         info = findMatchingFact(facts, context, eqn.get(rhsPath))) {
    var fullPath = rhsPath.concat(info.path);
    const next = rules.rewrite(eqn, fullPath, info.stmt);
    eqn = next;
  }
  return eqn; 
}

/**
 * Arranges the given part of the given step by repeatedly applying
 * the given facts until none matches, returning a step with the part
 * replaced by the result of the rearrangement.
 *
 * As a good practice, this considers the part in isolation, only
 * replacing it in the step when done applying facts.
 *
 * TODO: Consider eliminating the use of "consider" here when exactly
 *   one fact application can be done.
 */
export function arrange(step, path, context, facts) {
  var eqn = rules.consider(step.get(path));
  var arranged = arrangeRhs(eqn, context, facts);
  return rules.replace(step, path, arranged);
}

/**
 * Call the given function for each recorded fact, passing
 * it the info object stored for the fact.
 */
export function eachFact(fn) {
  _factsByKey.forEach(function(list) {
      list.forEach(function(info) {
          fn(info);
        });
    });
}

/**
 * Checks that the named rule is a theorem (i.e. takes no arguments),
 * and gets its result by running its action.  Returns null if there
 * is not a theorem of that name.  If the theorem's proof has already
 * run, its action will not rerun it, but only re-justify so there
 * will be a new step.
 */
export function getTheorem(name) {
  var action = rules[name];
  if (!action || action.length !== 0) {
    return null;
  }
  return action();
}

/**
 * Returns the statement of a named theorem.
 */
export function getTheoremStatement(name) {
  const fn = rules[name];
  // If the rule takes arguments it will have no statement.
  return fn && fn.info.statement;
}    


//// UTILITY FUNCTIONS

/**
 * Searches the given list of equational facts in order seeking one
 * that matches the LHS of the given equational step.  In particular,
 * the part of the step at path must match with the variable in the
 * LHS of the fact having the given name, which should occur exactly
 * once in the fact's LHS.
 *
 * If this finds such a fact it returns a function of no arguments
 * that applies the fact to the step using rules.rewrite and returns
 * the result of the rewrite.
 *
 * TODO: Consider how to make sure the facts in factList are
 *   interpreted appropriately.
 *
 * TODO: If useful, extend to facts that are not equations.  Probably
 *   rethink and rewrite along with all or most uses of
 *   matchSchemaPart.
 */
export function matchFactPart(step, path, factList, name) {
  return Toy.each(factList, function(fact_arg) {
      const stmt = mathParse(fact_arg);
      const expn = (factExpansion(stmt) ||
                    rules.tautology(stmt));
      if (expn && !(expn instanceof Error)) {
      var schema = expn.getMain().getLeft();
      var info = step.matchSchemaPart(path, schema, name);
      if (info) {
        return function() {
          return rules.rewrite(step, info.path, stmt);
        };
      }
    }
  });
}

/**
 * Build a schema for a conjunction of assumptions, ensuring all are
 * in the TermMap, with optional exclusions, a TermSet.  The schema is
 * of the form a1 & ... & an, where the "a"s are variables for the
 * terms for each of the assumptions.
 */
export function buildHypSchema(hyps, map, exclusions?) {
  var schema = null;
  hyps.scanConj(function(hyp) {
      var v = map.addTerm(hyp);
      if (!exclusions || !exclusions.has(hyp)) {
        schema = schema ? Toy.infixCall(schema, '&', v) : v;
      }
    });
  return schema;
}

/**
 * Returns the given conjunction of assumptions except any appearing in
 * the exclusions TermSet.  If there are no such assumptions, returns
 * T.
 */
function hypsExcept(hyps, exclusions) {
  var result = null;
  hyps.scanConj(function(hyp) {
      if (!exclusions.has(hyp)) {
        result = result ? Toy.infixCall(result, '&', hyp) : hyp;
      }
    });
  return result;
}

/**
 * Makes a facts map into a list of the fact keys.
 */
export function listFacts(map) {
  var list = [];
  for (var key in map) {
    list.push(key);
  }
  return list;
}

/**
 * Developer utility function that modifies the named rule to emit
 * information about calls to it.
 */
export function traceRule(name) {
  var rule = rules[name];
  function timed() {
    console.log('Enter', name);
    for (var i = 0; i < arguments.length; i++) {
      console.log(i, arguments[i] + '');
    }
    var t = new Toy.NestedTimer(name);
    t.start();
    var result = rule.apply(rule.info, arguments);
    var elapsed = t.end();
    console.log('=', result + '');
    console.log('Exit', name, elapsed, 'ms');
    return result;
  }
  timed.info = rule.info;
  rules[name] = timed;
}

/**
 * Returns the plain object with various information about the rule
 * applied to create the given step.
 */
export function getRuleInfo(step) {
  return rules[step.ruleName].info;
}

/**
 * If the given step has a "site" input, this returns the path
 * of the site argument, a string or Path object.  This uses the
 * "inputs" information of the rule that generated the step to
 * determine which argument to access.
 */
export function getStepSite(step) {
  var inputs = getRuleInfo(step).inputs;
  for (var type in inputs) {
    if (type in Toy.siteTypes) {
      var args = step.ruleArgs;
      // Assumes there can be only one "site" argument.
      var index = inputs[type];
      return args[index];
    }
  }
}

/**
 * Returns an array of the (regular) steps leading up to and including
 * the given plain / unrendered step, sorted by ordinal.
 */
export function proofOf(step) {
  // See also the similar Toy.unrenderedDeps.
  const visited = new Set();
  var result = [];
  // Traverses the dependencies graph, recording each step found
  // and building an array of them.
  function visitWithDeps(step) {
    if (!visited.has(step)) {
      result.push(step);
      visited.add(step);
      step.ruleDeps.forEach(function(dep) { visitWithDeps(dep); });
    }
  }
  visitWithDeps(step);
  result.sort(function(s1, s2) {
      return s1.ordinal - s2.ordinal;
    });
  return result;
}

/**
 * Returns an array of "assume" steps in the proof of the given step
 * (see Toy.proofOf) that create an assumption of the step.  Assumes
 * that the assumptions are a chain of conjuncts, which is true of
 * normalized assumptions.  Used in rendering to highlight the sources
 * of assumptions.
 */
export function assumptionsUsed(step) {
  var asms = step.asmPart();
  if (!asms) {
    return [];
  }
  var asmList = [];
  asms.scanConj(function (expr) { asmList.push(expr); });

  var steps = proofOf(step);
  var result = [];
  for (var i = 0; i < steps.length; i++) {
    var step = steps[i];
    if (step.ruleName === 'assume') {
      for (var j = 0; j < asmList.length; j++) {
        var asm = asmList[j];
        // Note that every "assume" step is a conditional.
        if (step.getRight().sameAs(asm)) {
          result.push(steps[i]);
        }
      }
    }
  }
  return result;
}

/**
 * The given Expr is treated as the root of a tree of conjuncts.
 * This searches for a direct or indirect conjunct of it that
 * passes the test.  Returns a (pretty) path to the node found,
 * or null if none is found.
 */
export function pathToConjunct(root, test) {
  var Path = Toy.Path;
  function pathFrom(node) {
    if (test(node)) {
      return Path.empty;
    }
    if (node.isCall2('&')) {
      var rpath = pathFrom(node.getRight());
      if (rpath) {
        return new Path('right', rpath);
      }
      var lpath = pathFrom(node.getLeft());
      if (lpath) {
        return new Path('left', lpath);
      }
    }
    return null;
  }
  return pathFrom(root);
}

/**
 * Builds and returns a propositional schema from the given term,
 * with the structure of the tree of conjunctions rooted at the term.
 * Matching parts get the same variable letter.
 */
export function conjunctionSchema(term) {
  var map = new Toy.TermMap();
  var infixCall = Toy.infixCall;
  function makeSchema(term) {
    if (term.isCall2('&')) {
      return infixCall(makeSchema(term.getLeft()), '&',
                       makeSchema(term.getRight()));
    } else {
      map.addTerm(term);
      return map.get(term);
    }
  }
  return makeSchema(term);
}

export interface Expr {
/**
 * Returns a Map with information about the bindings of variables that
 * are bound in the scope of the given path.  Keys of the map are
 * variable names, and each value is a path to the site where the
 * variable of that name is bound.
 *
 * The path must only have segments fn, arg, and/or body.
 *
 * TODO: Define a similar method that reports _all_ bindings.  If a
 *   name is bound in multiple parents of the target term, this
 *   only reports the innermost binding of that name.
 */
pathBindings(path_arg);
}
Expr.prototype.pathBindings = function(path_arg) {
  const Path = Toy.Path;
  const bindings = new Map();
  let path = Toy.asPath(path_arg);
  let revPath = Path.empty;
  let term = this;
  while (!path.isEnd()) {
    const segment = path.segment;
    path = path.rest;
    switch(segment) {
    case 'fn':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('fn', revPath);
      term = term.fn;
      break;
    case 'arg':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('arg', revPath);
      term = term.arg;
      break;
    case 'body':
      assert(term instanceof Lambda, 'Not a Lambda: {1}', term);
      bindings.set(term.bound.name, revPath.reverse());
      revPath = new Path('body', revPath);
      term = term.body;
      break;
    default:
      assert(false, 'Bad segment {1} in path {2}', segment, path_arg);
    }
  }
  return bindings;
}


//// Simplification facts

/**
 * Simplification facts for algebra, used in _simplifyOnce
 * simplifier: true are added to this list.
 *
 * TODO: Consider whether x - 7 is simpler than x + -7.
 * TODO: Declare number facts as simplifiers rather than adding here.
 */
// TODO: Part of a proof context.
export var basicSimpFacts: (string | Object)[] = [
                      'T & a == a',
                      'a & T == a',
                      'F & a == F',
                      'a & F == F',
                      'T | a == T',
                      'a | T == T',
                      'F | a == a',
                      'a | F == a',
                      'a & a == a',
                      'a | a == a',
                      'a | not a == T',
                      'a => T == T',
                      'F => a == T',
                      'not T == F',
                      'not F == T',
                      '(a == T) == a',
                      'not (not a) == a',
                      'x = x == T',
                      'T => a == a',
                      'if T x y = x',
                      'if F x y = y',
                      ];

//// Support for adding facts

// Object / set of property names supported in fact info data, used
// for validation of fact properties.  See addFact.
var factProperties = {
  goal: true,
  proved: true,
  axiom: true,
  statement: true,
  proof: true,
  definition: true,
  simplifier: true,
  desimplifier: true,
  noSwap: true,
  labels: true,
  with: true,
  props: true,
  description: true,
  definitional: true,
  // autoSimplify: true,
  // afterMatch: true,
  converse: true
};

/**
 * Adds an entry to the facts database given information in the format
 * of fact entries in facts maps, assuming here that the synopsis is
 * already added to the info as a synopsis property.  Can use the
 * synopsis property to generate a goal and the proof property as the
 * prover.  Top-level code, as in files of theorems, definitions, and
 * inference rules, should use addRule as it supports rules of
 * inference,and do additional useful work such as automatically
 * adding appropriate swapped facts.  The goal as stored in the
 * database has type information.
 *
 * Returns the fully-processed "info".
 *
 * This does no inference, so it can be called before proving any
 * theorems.
 *
 * Currently recognizes input properties as follows:
 *
 * goal: if present, can generate the synopsis; if proved, becomes
 *   the proved result, and any proof function will be ignored,
 *   otherwise a WFF.
 * axiom: true if this is an axiom.
 * asserted: true iff this fact is asserted without proof, but not 
 *   an axiom.
 * statement:  string for input to mathParse.  Must parse to a
 *   complete statement of the fact, to be used as the goal.
 * proof: function to return the proved fact, matching the goal.
 *   If not present, one will be generated to assert the goal.
 * description: string or function as for a rule description.
 * simplifier: true iff this fact is a simplifier.
 * desimplifier: true iff this fact is the "converse" of a simplifier.
 * definition: true if this fact is introduced as a definition.
 *   Currently just affects the message.
 * definitional: the fact is "basically" a definition of a
 *   function or predicate.  Used for presentation of the fact
 *   in a menu.
 * autoSimplify: if given, a simplifier function that takes the
 *   result of a rewrite with this fact as its input and applies it
 *   as the interactive auto-simplifier.
 * labels: Optional object/set of label names.  If given as a string,
 *   parses space-separated parts into a set.  The result constains just
 *   "none" if none are given.
 * converse.labels: Like labels, but applies to a "swapped" version
 *   of the fact, if any.
 */
export function addFact(info) {
  // This function adds to the info and supplies it to setFactInfo.

  // This will be the same as the goal if the goal is proved.
  info.proved = info.goal && info.goal.isProved() && info.goal;

  // Ensure that the goal has types.
  info.goal = (info.proved ||
               // TODO: Consider how to possibly better ensure that
               // types in the goal are identical with types in the
               // proved fact.  (Always prove on first use?)
               info.goal.typedCopy() ||
               mathParse(info.statement));
  const goal = info.goal;
  if (goal.isCall2('=>')) {
    const asmFrees = goal.getLeft().freeVarSet();
    const mainFrees = goal.getMain().freeVarSet();
    const asmExtras = Toy.setDiff(asmFrees, mainFrees);
    if (asmExtras.size) {
      console.log('Goal asms have extra free vars in', goal.$$);
    }
  }

  for (var key in info) {
    if (!(key in factProperties)) {
      var id = info.goal ? info.goal.$$ : 'goal?';
      console.warn('In fact', id, 'extra info key:', key);
    }
  }

  if (info.proof) {
    // Give the proof function a useful and pretty name for stack
    // traces.
    const stmt = info.statement || info.goal.toUnicode();
    Object.defineProperty(info.proof, 'name', {value: 'proof of ' + stmt});
  }

  // Adding new constants.  Doing it here adds them before asserting
  // the fact.  Also rules.assert can add constants in case it is used
  // without registering a fact. (And Toy.define also adds the defined
  // constant as it bypasses this code.)
  // TODO: If there is no proof, assert the fact immediately and skip
  //   this code.
  info.goal.registerConstants();
  const names = info.goal.newConstants();
  if (names.size > 0) {
    if (info.definition) {
      console.log('Defining',
                  Array.from(names).join(', '));
    } else {
      console.log('In fact', info.goal.toString(), 'introducing constants:',
                  Array.from(names).join(', '));
    }
    Toy.addConstants(names);
  }
  if (!info.proved) {
    if (!info.axiom && !info.definition && !info.proof) {
      console.warn('No proof for', info.goal.toUnicode());
    }
    info.prover = asFactProver(info.proof, info.goal);
  }
  // This will be set to true when starting to attempt a proof and
  // reset to false when the proof succeeds.  In findMatchingFact
  // facts with proof currently in progress are not considered, e.g.
  // affecting simplification.
  info.inProgress = false;

  info.labels = processLabels(info.labels);
  computeMenuCategories(info);

  if (isRecordedFact(info.goal)) {
    console.warn('Fact', info.goal.$$, 'already recorded, skipping.');
  } else {
    if (info.simplifier) {
      // This puts a string onto basicSimpFacts for fast cached
      // lookups, but watch out for cases where toString and parse are
      // not inverses.
      basicSimpFacts.push('@' + info.goal.toString());
    }
    setFactInfo(info);
  }
  return info;
}

/**
 * Records the (new) given fact information; private to addFact.  See
 * comments on _factsByKey and fact management functions for the
 * expectations on the argument.
 */
function setFactInfo(info) {
  assert(!isRecordedFact(info.goal),
         'Already recorded fact: {1}', info.goal);
  const key = getResInfo(info.goal).key;
  const facts = _factsByKey.get(key) || [];
  // Ensure that the key has an array of facts.
  facts.length > 0 || _factsByKey.set(key, facts);
  // Tentatively add the fact to the list.
  facts.push(info);
  return true;
}

/**
 * Add the "converse" of an equational fact if it is not already
 * recorded.  Determines the statement from the info's goal.  If it is
 * an equation, adds a fact with its LHS and RHS swapped, otherwise
 * does nothing.
 *
 * If the fact to be swapped is a simplifier or desimplifier, the
 * newly-created fact will be appropriately labeled as the opposite,
 * and converses of primitive facts are also labeled as primitive.
 */  
function addSwappedFact(info) {
  var stmt = info.goal;
  if (stmt.isEquation()) {
    var swapped = Toy.commuteEqn(stmt);
    if (!isRecordedFact(swapped)) {
      function proveSwapped() {
        return rules.fact(stmt).andThen('eqnSwap');
      }
      var labels2 = processLabels(info.converse && info.converse.labels);
      if (info.labels && info.labels.primitive) {
        labels2.primitive = true;
      }
      computeMenuCategories(info);
      var info2 = {proof: proveSwapped,
                   goal: swapped,
                   simplifier: !!info.desimplifier,
                   desimplifier: !!info.simplifier,
                   description: info.description,
                   labels: labels2
      };
      addFact(info2);
    }
  }
}

/**
 * Accepts a "prover" function of no arguments and a goal statement
 * (Expr).  The prover may be null, in which case this generates
 * a trivial prover that asserts the goal.
 *
 * Returns a function to construct and return a proved statement from
 * the arguments.  The returned function runs the prover to prove the
 * goal.  When running the prover, the returned function also attempts
 * to use exactly the free variables in the goal, and arranges the
 * assumptions accordingly.  It warns if assumptions do not match up
 * with the goal, and raises an error if it cannot make the main part
 * match exactly.
 *
 * This supports rules.fact and rules like rewrite that accept a fact
 * statement.  Internal to addFact.
 */
function asFactProver(prover, goal) {
  assert(!prover || typeof prover === 'function',
         'Not a function: {1}', prover);
  // This function wraps around the user-supplied fact prover
  // to do the generic parts of the work.
  function factProverWrapper() {
    var result;
    if (goal.isProved()) {
      result = goal;
    } else if (!prover) {
      // The proof is just a stub not yet filled in.
      return rules.assert(goal);
    }
    var result = prover();
    if (result instanceof Error) {
      if (Toy.assertOnFailure) {
        return rules.assert(goal);
      } else {
        abort('Failed to prove {1}.\nGot: {2}', goal, result);
      }
    }
    // Seek a substitution into the result that yields the goal.
    var subst = result.alphaMatch(goal);
    // TODO: Check that substitutions exist, but don't actually do
    //   substitutions here.  Now rules.fact substitutes as needed to
    //   use the variables desired at each use.
    if (subst) {
      return rules.instMultiVars(result, subst);
    } else {
      // Try matching the main parts of the result and goal.
      // Reorder any assumptions as needed.
      //
      // TODO: Review this bit of code!!  There are some fine points
      //   of design not fully resolved, e.g. "arrangeAsms".
      var subst2 = result.getMain().alphaMatch(goal.getMain());
      if (subst2) {
        // The main parts match up to change of variables.
        // Conceivably the assumptions could have other free variables
        // that could still be reconciled, but we are not that
        // ambitious at present.
        var proved = (rules.instMultiVars(result, subst2)
                       .andThen('arrangeAsms'));
        if (proved.matches(goal)) {
          return proved;
        }
        let okAsms = true;
        // Check if the proved can match the goal by rearranging
        // assumptions.
        const goalAsms = goal.asmSet();
        const factAsms = proved.asmSet();
        if (!goalAsms.superset(factAsms)) {
          console.error('Fact requires unstated assumptions.',
                        '\nProved:', proved.toString(),
                        '\nStated:', goal.toString());
          okAsms = false;
        }
        if (!factAsms.superset(goalAsms)) {
          console.error(
            'Ignoring unneeded assumptions in the fact statement.',
            '\nProved:', proved.toString(),
            '\nStated:', goal.toString()
          );
          // This is a pretty innocuous issue so we let it pass.
          // okAsms = false;
        }
        if (okAsms) {
          // The assumptions can match if rearranged.
          return proved;
        }
      }
    }
    console.error(Toy.format('Instead of {1}\n proved {2}', goal, result));
    if (Toy.assertOnMismatch) {
      return rules.assert(goal);
    } else {
      abort('Proof mismatch');
    }
  }
  return factProverWrapper;
}

// This gets called at load time to generate the statement and
// proof of the stated tautology.
export function defTautology(statement) {
  return ({statement: statement, proof: () => rules.tautology(statement)});
}


//// SOME DEFINITIONS

/**
 * Dumps out fact resolutions as a debugging aid.
 */
export function dumpFactResolutions() {
  const map = _resolutionsByKey;
  map.forEach(function(list, k) {
      console.log('Key', k);
      let goal = null;
      list.forEach(function(resItem) {
          if (!goal) {
            goal = resItem.factInfo.goal;
            console.log('  fact ' + resItem.factInfo.goal);
          }
          const resInfo = resItem.resInfo;
          console.log('  from ' + resInfo.stmt);
          if (resInfo._expansion) {
            console.log('  as ' + resInfo._expansion);
          }
        });
    });
}

// Settable variables, export right here:

// If true, facts are only proved when explicitly requested,
// as when displaying the proof, but not when used in another
// proof.  Matching never causes a fact to be proved.
export var assertFacts = false;

// Assert requested facts that don't match the result of the proof.  
// This can be temporarily set to true to work around failures
// of proofs that might obscure other bugs that need to be fixed.
export var assertOnMismatch = false;

// Set to true to assert facts whose proofs fail with an error.
// The purpose is somewhat like assertOnMismatch.
export var assertOnFailure = false;

}  // namespace;
