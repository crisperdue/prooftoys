<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!--
  Uses "almost standards mode" -- standard except for
  some table cell sizing.
  -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Prooftoys Tests</title>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="boilerplate.js"></script>

<style type="text/css">

  body { xbackground-color: #EEF }

  .yui3-skin-sam .yui3-console-entry-pass .yui3-console-entry-cat {
    background-color: #0C0;
    color: black;
  }

  .yui3-skin-sam .yui3-console-entry-fail .yui3-console-entry-src {
    background-color: red;
    color: white;
  }

</style>
  
</head>
<body class=yui3-skin-sam
  style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Test Results</h1>

<div id=log class="yui3-skin-sam">
</div>


<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'querystring', 'overlay',
   function(Y) {

  // Initialize the console
  var yconsole = new Y.Console({
      style: 'block',
      height: '600px',
      width: '700px',
      newestOnTop: false                   
    });
  yconsole.render('#log');

  // Make "Y" available globally.
  window.Y = Y;

  // Make rules available throughout.
  var rules = Y.rules;

  // Assertion utilities:

  function assertEqual(a, b) {
    Y.Assert.areEqual(a, b);
  }

  var assert = Y.assert;

  // For testing convenience automatically assert steps from wffs.
  // TODO: Remove the need for this.
  Y.autoAssert = true;

  /**
   * Check effect of a rewriter.  Null expected value means expected
   * null result.  Empty expected string means just log the result for
   * debugging.
   */
  function checkRewriter(expected, input, rule) {
    var input = typeof input == 'string' ? Y.parse(input) : input;
    var equation = rule(input);
    if (expected == null) {
      assertEqual(null, equation);
    } else {
      assert(equation);
      var actual = equation.getRight();
      if (expected) {
        assertEqual(expected, actual);
      } else {
        Y.log(actual);
      }
    }
  }

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Do not display source step info in toString.
  Y.trackSourceSteps = false;

  // Example equation: x + x = 2 * x
  var times2 = call('=', call('+', x, x), call('*', '2', x));

  // Example WFF: x > 0 ==> x + x > x
  var bigger = call('==>', call('>', x, '0'),
                    call('>', call('+', x, x), x));

  var testCase = new Y.Test.Case({

      name: "Proof Tests",

      _should: {
        ignore: {
          testTautologyAndProfile: true  // More time-consuming.
        }
      },

      setUp: function() {
        tracing = false;
      },

      // Warmups, to confirm what some assertions do.

      testTrue: function() {
        Y.Assert.areEqual(true, true);
      },
      test11: function() {
        Y.Assert.areEqual(1, 1);
      },
      testTrue1: function() {
        Y.Assert.areEqual(true, 1);
      },

      // configure

      testConfigure: function() {
        var o = Y.configure({}, {
            add: function(x) { this[x] = true; },
            list: [1, 2, 3],
            zero: 0,
            count: {value: 1, writable: true}
          });
        assert(typeof o.add === 'function');
        assert(o.list.constructor === Array);
        assert(typeof o.zero === 'number');
        assert(typeof o.count === 'number');
        try {
          o.add = 3;
          Y.assert.fail('Should fail');
        } catch(e){}
        try {
          o.zero = 3;
          Y.assert.fail('Should fail');
        } catch(e){}
        o.count = 3;
        assert(o.count === 3);
      },

      // Sets, TermSets

      testSet: function() {
        var set = new Y.Set();
        // isEmpty
        assert(set.isEmpty());
        // size
        assertEqual(0, set.size());
        // add and has
        set.add('one');
        set.add(2);
        set.add('three');
        assert(set.has('one'));
        assert(set.has('2'));
        assert(set.has(2));
        assert(set.has('three'));
        // size
        assertEqual(3, set.size());
        // choose
        assert(set.has(set.choose()));
        // remove
        set.remove('three');
        assert(!set.has('three'));
        // each
        var items = [];
        var found = set.each(function(value) {
            items.push(value);
            if (value == 2) {
              return value;
            }
          });
        assertEqual(2, found);
        assert(items.indexOf(2) >= 0);
      },

      TestTermSet: function() {
        var set = new TermSet();
        var term = call(f, x);
        set.add(term);
        assert(set.has(term));
        assert(!set.has(call(f, y)));
        var items = [];
        set.each(function(value) { items.push(value); });
        assertEqual(1, items.length);
        assertEqual(term, items[0]);
        set.remove(term);
        assertEqual(0, set.size());
        assert(!set.has(term));
        assert(set.isEmpty());

        // Constructor with a term argument:
        term = Y.parse('p x');
        set = new TermSet(term);
        assert(set.has(term));
      },

      // Maps, TermMaps

      testMap: function() {
        var map = new Y.Map();
        var term = call(f, x);
        assert(map.isEmpty());
        assertEqual(0, map.size());
        assert(!map.has('toString'));
        map.set('foo', term);
        assert(map.has('foo'));
        assertEqual(term, map.get('foo'));
        assertEqual(1, map.size());
        var o = {a: 1};
        map.set('bar', o);
        assertEqual(o, map.get('bar'));
        assertEqual(2, map.size());
        map.remove('foo');
        assertEqual(1, map.size());
        map.remove('asdf');
        assertEqual(1, map.size());
        map.each(function(value, key) {
            assertEqual(o, value);
            assertEqual('bar', key);
          });
      },

      testMap0: function() {
        var map = new Y.Map(String, 0);
        assert(map.isEmpty());
        assert(!map.has('foo'));
        assertEqual(0, map.get('foo'));
      },

      testTermMap: function() {
        var map = new Y.TermMap();
        var term = Y.infixCall(x, '=', x);
        var t2 = call(f, y);
        // has
        map._set(term, t2);
        assert(map.has(term));
        // get
        assertEqual(t2, map.get(term));
        // each
        var result = map.each(function(value, key) {
            assertEqual(t2, value);
            assertEqual(term.dump(), key);
            assert(term.toString() != key);
            return true;
          });
        assertEqual(true, result);
        // remove
        map.remove(term);
        assertEqual(0, map.size());
        assert(map.isEmpty());
      },

      testAddTerm: function() {
        var map = new Y.TermMap();
        var term = Y.infixCall(x, '=', x);
        var v = map.addTerm(term);
        assertEqual('a1', v);
        assertEqual('a1', map.addTerm(Y.infixCall(x, '=', x)));
        assertEqual('a2', map.addTerm(call(p, x)));
        assert(map.has(call(p, x)));
        assertEqual('a2', map.get(call(p, x)));
      },

      // Tests for subtypes of Expr

      testVar: function() {
        assertEqual('x', x.toString());
      },

      testApp: function() {
        var app = call(f, x);
        assertEqual(f, app.fn);
        assertEqual(x, app.arg);
        assertEqual('(f x)', app.toString());
      },

      testLambda: function() {
        var abs = lambda(x, f);
        assertEqual(x, abs.bound);
        assertEqual(f, abs.body);
        assertEqual('{x. f}', abs.toString());

        assertEqual('{x. (f x)}', lambda(x, call(f, x)));
      },

      testDump: function() {
        assertEqual('T', T.dump());
        assertEqual('x', x.dump());
        assertEqual('(f x)', call(f, x).dump());
        assertEqual('{x. (f x)}', lambda(x, call(f, x)).dump());
        assertEqual('((= x) y)', call('=', x, y).dump());
      },

      // PARSER

      testTokenize: function() {
        var result = Y.tokenize('a');
        assertEqual('a,(end)', result);
        result = Y.tokenize('(a > b)');
        assertEqual('(,a,>,b,),(end)', result);
        result = Y.tokenize('{x. x}');
        assertEqual('{,x,.,x,},(end)', result);
        result = Y.tokenize('(=>x*)');
        assertEqual('(,=>,x,*,),(end)', result);
        result = Y.tokenize('f "as\\"df" 2');
        assertEqual('f,"as\\"df",2,(end)', result);
        assertEqual('as"df', result[1].value);
      },

      testParse: function() {
        var result = Y.parse('a');
        assertEqual('a', result.dump());
        result = Y.parse('(xx)');
        assertEqual('xx', result.dump());
        result = Y.parse('f x');
        assertEqual('(f x)', result.dump());
        result = Y.parse('not = (F =)');
        assertEqual('((= not) (= F))', result.dump());
        result = Y.parse('{x. x} T');
        assertEqual('({x. x} T)', result);
        result = Y.parse('a + b * c');
        assertEqual('(a + (b * c))', result);
        result = Y.parse('a ==> a & c');
        assertEqual('(a ==> (a & c))', result);
        // Numbers
        assertEqual(42, Y.parse('42').value);
        var expr = Y.parse('x + 103');
        assertEqual(103, expr.getRight().value);
        assertEqual(undefined, expr.getLeft().value);
        // Strings
        var expr = Y.parse('f "asdf"')
        assertEqual('"asdf"', expr.getRight().name);
        var expr = Y.parse('f "as\\"df"');
        assertEqual('"as\\"df"', expr.getRight().name);
        assertEqual(8, expr.getRight().name.length);
      },


      // Operations on Exprs.

      testNth: function() {
        var term = Y.parse('(f x (p y))');
        assertEqual('f', term.nth(0));
        assertEqual('x', term.nth(1));
        assertEqual('(p y)', term.nth(2));
        assertEqual('x', x.nth(0));
      },

      testAsArray: function() {
        var term = Y.parse('(f x (p y))');
        var array = term.asArray();
        assertEqual(3, array.length);
        assertEqual('f', array[0]);
        assertEqual('x', array[1]);
        assertEqual('(p y)', array[2]);
      },

      testIsNumeral: function() {
        var v = new Y.Var('-3');
        assert(v.isNumeral());
        v = new Y.Var('a1');
        assert(!v.isNumeral());
      },

      testIsString: function() {
        var v = new Y.Var('"asdf"');
        assert(v.isString());
        v = new Y.Var('a');
        assert(!v.isString());
        v = new Y.Var('-3');
        assert(!v.isString());
      },

      testUnparseString: function() {
        var ups = Y.unparseString;
        assertEqual('"asdf"', ups('asdf'));
        assertEqual('"\\\\asdf"', ups('\\asdf'));
        assertEqual('"asdf\\""', ups('asdf"'));
        assertEqual('"asdf\\n"', ups('asdf\n'));
      },

      testEncodeSteps: function() {
        var step1 = rules.assume('x = y + 3');
        var step2 = rules.assume('x + y = 5');
        var step3 = rules.replace(step1, step2, Y.path('/main/left/left'));
        var step4 = rules.instVar(step3, 'y', new Y.Var('5'));
        var saved = Y.encodeSteps([step1, step2, step3, step4]);
        var parsed = Y.parse(saved);
        var a = parsed.asArray();
        assertEqual(5, a.length);
        assertEqual('steps', a[0]);
        // Note that testDecodeSteps effectively tests more of this.
      },

      testDecodeArg: function() {
        var steps = [Y.rules.assert('x = y + 1')];
        function check(expected, input) {
          input = typeof input == 'string' ? Y.parse(input) : input;
          var actual = Y._decodeArg(input, steps);
          assertEqual(expected, actual);
        }
        check('foo', '"foo"');
        check('/arg', '(path "/right")');
        check('(x = (y + 1))', '(s 1)');
        check('(p (f x))', '(t (p (f x)))');
      },

      testDecodeSteps: function() {
        var step1 = rules.assume('x = y + 3');
        var step2 = rules.assume('x + y = 5');
        var step3 = rules.replace(step1, step2, Y.path('/main/left/left'));
        var step4 = rules.instVar(step3, 'y', new Y.Var('5'));
        var saved = Y.encodeSteps([step1, step2, step3, step4]);
        var steps = Y.decodeSteps(saved);
        Y.log(steps);
        assertEqual(4, steps.length);
        assertEqual('(((y + 3) + y) = y)', steps[3].getRight());
      },

      testFreeNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.freeNames();
        assertEqual(true, map['f']);
        assertEqual(undefined, map['x']);
      },

      testBoundNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.boundNames('');
        assertEqual('{}', Y.debugString(map));
        var map = wff.boundNames('/body/arg');
        assertEqual('{x: true}', Y.debugString(map));
      },

      testSubst: function() {
        var target = Y.parse('x = ({x. x} x)');
        assertEqual('(y = ({x. x} y))', target.subst(y, x));
        // Result is exactly the input where there are no occurrences.
        Y.assert(target === target.subst(z, y));
        Y.assert(target.locate('/right/fn')
                 === target.subst(y, x).locate('/right/fn'));
      },

      testCopy: function() {
        var source = '(x = x)';
        var target = Y.parse(source);
        // Copy is equal to original
        assertEqual(source, target.copy());
        Y.assert(target.matches(target.copy()));
        // But not identical.
        Y.assert(target !== target.copy());
      },

      testDecapture: function() {
        var target = call(lambda(x, x), y);
        var result = Y.decapture(target, x);
        assertEqual('({x_1. x_1} y)', result.toString());
        var target = Y.parse('({x. f x} y)');
        // Result is exactly the input when no decapturing is needed.
        Y.assert(target === Y.decapture(target, z));
      },

      testSubFree: function() {
        var v = _var('v');
        var target = call(lambda(v, v), x);
        // Now substitute in 'a different v':
        var result = Y.subFree(_var('v'), x, target);
        // We see that it replaces just the free occurrence.
        assertEqual('({v. v} v)', result.toString());
        // A case where decapturing is needed.
        result = Y.subFree(y, x, Y.parse('{y. x} x'));
        assertEqual('({x_1. y} y)', result);
        // A very similar case where it is not needed.
        result = Y.subFree(y, x, Y.parse('{y. T} x'));
        assertEqual('({y. T} y)', result);
      },

      testMathVars: function() {
        function check(expected, input) {
          input = typeof input == 'string' ? Y.parse(input) : input;
          var actual = input.mathVars();
          assertEqual(expected, Y.debugString(actual));
        }
        check('{}', 'x');
        check('{x: true}', 'x + 1');
        check('{x: true}', 'neg x + 1');
        check('{z: true}', '1 + (recip z)');
        check('{}', 'x = y');
        check('{x: true, y: true}', 'x = y + 1');
        check('{x: true, y: true}', 'x + ({z. z + y} 1)');
        // A more thorough implementation might include y also.
        check('{x: true}', 'x + ({z. z = y} 1)');
      },

      testMathVarConditions: function() {
        function check(expected, input) {
          input = typeof input == 'string' ? Y.parse(input) : input;
          var actual = input.mathVarConditions();
          assertEqual(expected, actual + '');
        }
        check('undefined', 'x');
        check('(R x)', 'x + x');
        check('((R x) & (R y))', 'y + x * y');
        check('(((R x) & (R y)) & (R z))', 'z * y * x');
      },

      testNormalized: function() {
        var e1 = call(lambda(x, call(f, x)), _var('y'));
        var result = Y.normalized(e1);
        assertEqual('({$1. (f $1)} y)', result.toString());
      },

      testIsCall1: function() {
        assertEqual(false, times2.isCall1('='));
        assertEqual(true, Y.parse('f x').isCall1());
        assertEqual(true, Y.parse('f x').isCall1('f'));
      },

      testIsCall2: function() {
        Y.Assert.isTrue(times2.isCall2('='), 'Times2 not an equation?');
      },

      testExprReplace: function() {
        var y = _var('y');
        var e1 = call(lambda(x, call(f, x)), y);
        var path = Y.path('/fn/body/arg');
        var result = e1.replace(path, function(expr) { return call(f, x); });
        assertEqual('({x. (f (f x))} y)', result.toString());
        var target = Y.parse('f x = y');
        result = target.replace(Y.path('/right'), function(expr) { return z; });
        Y.assert(target.getLeft() === result.getLeft());
      },

      testPath: function() {
        var p = '/a/b';
        var path = Y.path(p);
        assertEqual(p, path.toString());
        assertEqual('a', path.segment);
        assertEqual('b', path.rest('a').segment);
        Y.assert(path.rest('a').rest('b').isMatch());
        assertEqual('(none)', path.rest('b').toString());
        Y.assert(Y.path('/').isMatch());
        assertEqual('f', Y.path('fn').next(call(f, x)).toString());
        assertEqual('x', Y.path('arg').next(call(f, x)).toString());
        var p2 = '/left/binop';
        assertEqual('/fn/arg/fn/fn', Y.path(p2).toString());
        var p3 = '/arg/fn';
        assertEqual(p3 + p3, Y.path(p3).concat(p3));
      },

      testSearch: function() {
        xPlusX = call('+', x, x)
        var found =
          times2.search(function(expr) { return xPlusX.matches(expr); });
        assertEqual('(x + x)', found.toString());
      },

      testLocate: function() {
        var expr = call('forall', lambda(x, call(p, x)));
        var body = expr.locate(Y.path('/arg/body'));
        assertEqual('(p x)', body.toString());
      },

      testPathTo: function() {
        function findX(expr) {
          return expr == x;
        }
        assertEqual('', '' + x.pathTo(findX));
        assertEqual('/fn', '' + call(x, y).pathTo(findX));
        assertEqual('/arg', '' + call(y, x).pathTo(findX));
        assertEqual('/body', '' + lambda(x, x).pathTo(findX));
        assertEqual('/arg/arg/arg',
                    '' + call(f, call(f, call(g, x))).pathTo(findX));
      },

      testPathToBinding: function() {
        function isX(expr) {
          return expr == x;
        }
        assertEqual(null, x.pathToBinding(isX));
        assertEqual(null, call(x, y).pathToBinding(isX));
        assertEqual('', '' + lambda(x, x).pathToBinding(isX));
        assertEqual('/fn',
                    '' + call(lambda(x, x), z).pathToBinding(isX));
      },

      testMatchAsSchema: function() {
        function check(expected, schema, term) {
          term = typeof term == 'string' ? Y.parse(term) : term;
          schema = typeof schema == 'string' ? Y.parse(schema) : schema;
          var subst = Y.matchAsSchema(schema, term);
          if (expected) {
            assertEqual(expected, Y.debugString(subst));
          } else {
            Y.log(Y.debugString(subst));
          }
        }
        check('{p: (x = x)}', p, equal(x, x));
        check('{p: (x < 1), q: (x = 0)}',
              implies(p, q), Y.parse('x < 1 ==> (x = 0)'));
        check('{a: 3, b: 2}', 'a + b', '3 + 2');
      },

      testGeneralizeTF: function() {
        var gen = Y.parse('p T = T').generalizeTF(Y.parse('p F = F'), x);
        assertEqual('((p x) = x)', gen + '');
        try {
          Y.parse('p T = x').generalizeTF(Y.parse('p F = F'), x);
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
        try {
          Y.parse('p T').generalizeTF(Y.parse('p T F'), x);
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
      },

      testHasArgs: function() {
        Y.assert(Y.parse('f x').hasArgs(1));
        Y.assert(!Y.parse('f x').hasArgs(2));
        Y.assert(Y.parse('x + 1').hasArgs(1));
        Y.assert(Y.parse('x + 1').hasArgs(2));
        Y.assert(!Y.parse('x + 1').hasArgs(3));
      },

      testHypLocater: function() {
        var rules = Y.rules;
        function check(expected, step, hyp) {
          hyp = typeof hyp === 'string' ? Y.parse(hyp) : hyp;
          var actual = step.getLeft().hypLocater(hyp);
          assertEqual(expected, actual);
        }
        var step1 = rules.axiomCommutativePlus();
        check('(h & h1)', step1, 'R x');
        check('(h2 & h)', step1, 'R y');
        var h3 = rules.assume('p');
        var step2 = rules.prependStepHyps(step1, h3);
        check('((h & h2) & h1)', step2, 'p');
        check('((h3 & h) & h1)', step2, 'R x');
      },

      testHypMover: function() {
        var rules = Y.rules;
        function check(expected, step, hyp) {
          hyp = typeof hyp === 'string' ? Y.parse(hyp) : hyp;
          var actual = step.getLeft().hypMover(hyp);
          assertEqual(expected, actual);
        }
        var step1 = rules.axiomAssociativePlus();
        check('(((h & h2) & h3) = ((h2 & h3) & h))',
              step1, 'R x');
        check('(((h1 & h) & h3) = ((h1 & h3) & h))',
              step1, 'R y');
        var h3 = rules.assume('p');
        var step2 = rules.prependStepHyps(step1, h3);
        check('((((h & h2) & h3) & h4) = (((h2 & h3) & h4) & h))',
              step2, 'p');
        check('((((h1 & h) & h3) & h4) = (((h1 & h3) & h4) & h))',
              step2, 'R x');
      },

      testMergedHypotheses: function() {
        function check(expected, input) {
          input = typeof input == 'string' ? Y.parse(input) : input;
          var eqn = input.mergedHypotheses();
          var taut = Y.rules.tautology(eqn);
          var result = Y.rules.rewrite(input, '/', taut);
          assertEqual(expected, result);
        }
        check('(a & b)', 'a & b');
        check('a', 'a & a');
        check('(a & b)', 'a & (a & b)');
        check('((a & b) & c)', 'a & (b & c)');
        check('(a & b)', '(a & b) & (a & b)');
        check('(a & b)', '(a & b) & (b & a)');
        check('((a & b) & c)', '(a & b) & (c & b & a)');
        check('((a & b) & c)', '(b & a) & (b & c & a)');
      },

      testIsHypotheses: function() {
        var step1 = Y.rules.assume(Y.parse('p x'));
        Y.assert(step1.getLeft().isHypotheses());
        Y.assert(step1.getRight().isHypotheses());
        var conj = Y.infixCall(step1.getLeft(), '&', step1.getRight());
        Y.assert(conj.isHypotheses());
        var conj2 = Y.infixCall(conj, '&', conj);
        Y.assert(conj2.isHypotheses());
      },

      testSourceStepLess: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        // Which step came earlier?
        Y.assert(Y.sourceStepLess(step1.getLeft(), step2.getLeft()));
        Y.assert(!Y.sourceStepLess(step2.getLeft(), step1.getLeft()));
      },

      testSourceStepComparator: function() {
        var compare = Y.sourceStepComparator;
        var step1 = Y.rules.assume('p T');
        var l1 = step1.getLeft();
        var step2 = Y.rules.assume('p F');
        var l2 = step2.getLeft();
        // Which step came earlier?
        assert(compare(l1, l2) < 0);
        assertEqual(0, compare(l1, l1));
        assert(compare(l2, l1) > 0);
        assert(compare(x, l2) > 0);
        assert(compare(l2, x) < 0);
      },

      testMergeConjunctions: function() {
        var rules = Y.rules;
        function check(expected, input) {
          var expr = typeof input == 'string' ? Y.parse(input) : input;
          var actual = rules.mergeConjunctions(expr).getRight();
          assertEqual(expected, actual);
        }
        check('(x & y)', 'y & x');
        check('(y & z)', 'z & y & z');
        check('((x & y) & z)', 'x & (y & z)');
        check('((p x) & (p y))', 'p x & p y');

        // With sourceSteps:
        var h1 = rules.assert('p x');
        h1.sourceStep = h1;
        var h2 = rules.assert('p y');
        h2.sourceStep = h2;
        var conj = rules.makeConjunction(h1, h2);
        var h3 = rules.assert('p z');
        h3.sourceStep = h3;
        var conj2 = rules.makeConjunction(h2, h3);
        check('((p x) & (p y))', Y.infixCall(conj, '&', conj));
        check('(((p x) & (p y)) & (p z))', Y.infixCall(conj, '&', conj2));
        check('(((p x) & (p y)) & (p z))', Y.infixCall(conj2, '&', conj));
      },

      testRepeatedCall: function() {
        try {
          Y.repeatedCall('&', []);
          Y.Assert.fail('repeatedCall should throw here');
        } catch(e) {}
        assertEqual('x1', Y.repeatedCall('&', [1]));
        assertEqual('(x3 & x5)', Y.repeatedCall('&', [3, 5]));
        assertEqual('((x3 & x5) & x19)',
                    Y.repeatedCall('&', [3, 5, 19]));
      },


      // ALIASES

      testAliases: function() {
        var parse = Y.parse;
        // Printing and parsing should be inverses.
        assertEqual('(a == b)', parse('a == b'));
        // Aliases should not affect meanings of expressions.
        Y.assert(parse('a == b').matches(parse('a = b')));
      },


      // UTILITIES

      testCheckNumber: function() {
        assertEqual(42, Y.checkNumber(42));
        try {
          Y.checkNumber('42');
          Y.Assert.fail('Should throw');
        } catch(e) {}
      },

      testCheckRange: function() {
        assertEqual(42, Y.checkRange(42));
        try {
          Y.checkRange(-Math.pow(2, 53));
          Y.Assert.Fail('Should throw');
        } catch(e) {}
      },


      // CONSTANTS AND DEFINITIONS

      // Actually "proof support" function:
      testIsConstant: function() {
        Y.assert(Y.isConstant('T'));
        Y.assert(T.isConst());
        Y.assert(Y.isConstant('==>'));
        Y.assert(Y.isConstant('neg'));
        Y.assert(!equal(x, x).isConst());
      },

      testIsDefined: function() {
        Y.assert(!Y.isDefined('T'));
        Y.assert(!Y.isDefined(T));
        Y.assert(!Y.isDefined('==>'));
	Y.assert(Y.isDefined('forall'));
	Y.assert(Y.isDefined(_var('forall')));
        try {
          Y.isDefined(equal(x, x));
          Y.Assert.fail('Name not a variable or string');
        } catch(e) {}
      },


      // TYPES

      testParseType: function() {
        function check(expected, input) {
          assertEqual(expected, Y.parseType(input));
        }
        check('i', 'i');
        check('o', 'o');
        check('R', 'R');
        check('t12', 't12');
        check('(o i)', 'o i');
        check('i', '(i)');
        check('((o R) R)', 'o R R');
        check('((o i) i)', '(o i i)');
        check('(o (o i))', 'o (o i)');
      },

      // TYPE INFERENCE

      testFindType: function() {
        var rules = Y.rules;
        assertEqual('o', Y.findType(T));
        assertEqual('o', Y.findType(Y.parse('x = x')));
        try {
          Y.findType(Y.parse('f f'));
          Y.Assert.fail('Should not unify');
        } catch(e) {}
        // The identity function, problematic for some algorithms.
        var type = Y.findType(Y.parse('{x. x}'));
        Y.assert(type instanceof Y.FunctionType, 'Not a FunctionType');
        Y.assert(type.types[0] instanceof Y.TypeVariable, 'Not a TypeVariable');
        assertEqual(type.types[0], type.types[1]);
        assertEqual('o', Y.findType(rules.axiom1()));
        assertEqual('o', Y.findType(rules.axiom2()));
        assertEqual('o', Y.findType(rules.axiom3()));
        assertEqual('o', Y.findType(rules.axiom4(Y.parse('({x. x} y)'))));
        assertEqual('o', Y.findType(rules.axiom5()));
        function check(expected, expr) {
          expr = (typeof expr == 'string') ? Y.parse(expr) : expr;
          var type = Y.findType(expr);
          // for debugging:
          // Y.log(expected + '/' + type);
          assertEqual(expected, type);
        }
        // Note that all the "> 0" conditions below force variables to
        // be individual variables.
        //
        // From two reals to boolean:
        check('((o i) i)', '{x. {y. x > y & y > 0}}');
        // From set to boolean:
        check('(o (o i))', '{x. x = {y. y > 0}}');
        // From set to individual:
        check('(i (o i))',
              // Max of a set having at least one positive number.
              '{p. the {x. p x & x > 0 & forall {y. p y ==> x >= y}}}');
        // From set and individual to boolean, note how the
        // first argument type appears last when written out.
        //         y  x
        check('((o i) (o i))', '{x. {y. (x = (= y)) & (y > 0)}}');
        check('((o i) (o i))', '{x. {y. (x = (> y)) & (y > 0)}}');
        // Successful typing of the identity function
        check('o', '({x. x} p) = p');
        // An example where the type check in Rule R catches improper
        // use of types.
        var step1 = Y.parse('p (f g) ==> p g').assert();
        // This is pathological in that p and f each appear on just
        // one side of the equation, which means the value of the
        // expressions containing them are not affected by their
        // values.
        var step2 = Y.parse('p g = g f').assert();
        try {
          Y.rules.r(step2, step1, '/right');
          Y.Assert.fail('Rule R should prohibit this step');
        } catch(e) {}
      },


      // RULE DESCRIPTIONS

      testEachArgType: function() {
        var each = Y.eachArgType;
        info = [];
        each('implyForallThm', function(index, type) {
            info[index] = type;
          });
        assertEqual(info[0], 'varName');
        assertEqual(info[1], 'term');
        assertEqual(info[2], 'term');
      },


      // PROOFS

      testRuleR: function() {
        var path = Y.path('/right/left');
        var result = Y.rules.r(times2, bigger, path);
        assertEqual('((x > 0) ==> ((2 * x) > x))', result);
      },

      testAxiom4: function() {
        var app = call(lambda(x, call(f, x)), y);
        var result = Y.rules.axiom4(app);
        Y.Assert.isInstanceOf(Y.Call, result);
        assertEqual('=', result.fn.fn.name);
        assertEqual('(({x. (f x)} y) = (f y))', result);
      },

      testAxioms: function() {
        assertEqual('(((g T) & (g F)) == (forall {x. (g x)}))',
                    Y.rules.axiom1());
        assertEqual('((x = y) ==> ((h x) = (h y)))',
                    Y.rules.axiom2());
        assertEqual('((f = g) = (forall {x. ((f x) = (g x))}))',
                    Y.rules.axiom3());
        assertEqual('((the (y =)) = y)',
                    Y.rules.axiom5());
        // Real numbers.  Make sure parsing works.
        Y.rules.axiomCommutativePlus();
        Y.rules.axiomCommutativeTimes();
        Y.rules.axiomAssociativePlus();
        Y.rules.axiomAssociativeTimes();
        Y.rules.axiomDistributivity();
        Y.rules.axiomPlusZero();
        Y.rules.axiomTimesOne();
        Y.rules.axiomTimesZero();
        Y.rules.axiomNeg();
        Y.rules.axiomReciprocal();
        Y.rules.axiomPlusType();
        Y.rules.axiomTimesType();
        Y.rules.axiomNegType();
        Y.rules.axiomReciprocalType();
      },

      testAxiomArithmetic: function() {
        function check(expected, expr) {
          if (typeof expr == 'string') {
            expr = Y.parse(expr);
          }
          var result = Y.rules.axiomArithmetic(expr);
          // Y.log(result);
          assertEqual(expected, result);
        }
        var neg5 = Y.rules.axiomArithmetic(Y.parse('neg 5')).getRight();
        check('((2 + 2) = 4)', '2 + 2');
        check('((5 * 4) = 20)', '5 * 4');
        check('((5 - 4) = 1)', '5 - 4');
        check('((neg 5) = -5)', 'neg 5');
        check('((5 > 4) = T)', '5 > 4');
        check('((5 >= 4) = T)', '5 >= 4');
        check('((5 < 4) = F)', '5 < 4');
        check('((5 <= 4) = F)', '5 <= 4');
      },

      testAsHypotheses: function() {
        var step1 = Y.rules.assert('p = p');
        try {
          Y.rules.asHypotheses(step1);
          Y.Assert.fail('Should throw');
        } catch(e) {}
        var step2 = Y.rules.assert('p ==> p');
        var step3 = Y.rules.assume('p');
        var step4 = Y.rules.assert('p ==> q');
        var step5 = Y.rules.modusPonens(step3, step4);
        var step6 = Y.rules.asImplication(step5);
        var result = Y.rules.asHypotheses(step6);
        assertEqual('(p ==> q)', result);
        Y.assert(result.hasHyps);
      },

      testApplyBoth: function() {
        assertEqual('((f x) = (g x))', Y.rules.applyBoth(call('=', f, g), x));
      },

      testApplyToBoth: function() {
        var inf = Y.rules.applyToBoth(p, call('=', q, r));
        assertEqual('((p q) = (p r))', inf);
        var step = Y.rules.assume('x = y + 1');
        var result = Y.rules.applyToBoth(Y.parse('{x. x - 1}'), step);
        assertEqual('((x - 1) = ((y + 1) - 1))', result.getRight());
      },

      testEqSelf: function() {
        var result = Y.rules.eqSelf(call(f, y));
        assertEqual('((f y) = (f y))', result);
        assertEqual('(x = x)', Y.rules.eqSelf(x));
      },

      testR5201a: function() {
        var result = Y.rules.replaceWhole(call(p, x),
                                          call('=', call(p, x), call(q, x)));
        assertEqual('(q x)', result);
      },

      testR5201b: function() {
        var inf = Y.rules.eqnSwap(call('=', p, q));
        assertEqual('(q = p)', inf);
      },

      testR5201c: function() {
        var inf = Y.rules.eqnChain(call('=', p, q), call('=', q, r));
        assertEqual('(p = r)', inf);
      },

      testR5201d: function() {
        var inf = Y.rules.applyBySides(call('=', p, q), call('=', 'a', 'b'));
        assertEqual('((p a) = (q b))', inf);
      },

      testR5201e: function() {
        var inf = Y.rules.applyBoth(call('=', p, q), r);
        assertEqual('((p r) = (q r))', inf);
      },

      testApplier: function() {
        var rule = rules.applier;
        checkRewriter('3', '{x. x} 3', rule);
        checkRewriter(null, '(f 3)', rule);
        checkRewriter('(x + (neg y))', 'x - y', rule);
        checkRewriter('(F = a)', 'not a', rule);
      },

      testApply: function() {
        var rules = Y.rules;
        // Apply a call to a lambda.
        var step1 = rules.axiom4('{x. x} 2');
        var result = rules.apply(step1, '/left');
        assertEqual('(2 = 2)', result);
        // Apply a call to 1-arg function:
        var step1 = rules.tautology('(p ==> not p) ==> not p');
        var result = rules.apply(step1, '/right');
        assertEqual('((p ==> (not p)) ==> (F = p))', result);
        // Apply a call to a 2-arg function:
        var step1 = rules.assume('x != y');
        var result = rules.apply(step1, '/right');
        assertEqual('((x != y) ==> (not (x = y)))', result);
      },

      testUseDefinition: function() {
        var inf =
          Y.rules.useDefinition(call('not', equal(p, equal(F, p))), '/fn');
        assertEqual('(F = (p = (F = p)))', inf);
      },

      testInstEqn: function() {
        var c = new Y.Var('c');
        var inf = Y.rules.instEqn(Y.parse('g y = c'),
                                  Y.parse('f x'),
                                  'y');
        assertEqual('((g (f x)) = c)', inf);
      },

      testEqT: function() {
        assertEqual('(T = (b = b))', Y.rules.eqT('b'));
	var step = Y.rules.eqT(call(f, x));
        assertEqual('(T = ((f x) = (f x)))', step);
	var controller =
          Y.renderInference(step, Y.one(document.body)).getData('proofControl');
        var step2 = Y.rules.instVar(step.details, y, x);
        // Add a step and immediately remove it.  See that at least
        // there are no exceptions.
        controller.addStep(step2);
        controller.removeStepAndFollowing(step2.rendering);
      },

      testR5211: function() {
        assertEqual('((T & T) = T)', Y.rules.r5211());
      },

      testRuleT: function() {
        assertEqual('T', Y.rules.t());
      },

      testR5212: function() {
        assertEqual('(T & T)', Y.rules.r5212());
      },

      testEqnIsTrue: function() {
        var inf = Y.rules.toTIsEquation(call('=', p, q));
        assertEqual('(T = (p = q))', inf);
      },

      testR5213: function() {
        var inf = Y.rules.r5213(call('=', p, q),
                                call('=', q, r));
        assertEqual('((p = q) & (q = r))', inf);
      },

      testChangeVar: function() {
        var expr = equal(lambda(z, z), lambda(y, y));
        var result = Y.rules.changeVar(expr, '/left', x);
        assertEqual('({x. x} = {y. y})', result);
      },

      testBindEqn: function() {
        var inf = Y.rules.bindEqn(call('=', f, g), x);
        assertEqual('({x. f} = {x. g})', inf);
      },

      testInstForall: function() {
        var result = Y.rules.instForall(call('forall', lambda(y, call(p, y))),
                                        call(f, y))
        assertEqual('(p (f y))', result);

        // Hypotheses
        var hyps = Y.rules.assume('p y');
        var step1 = Y.rules.assert('forall {y. p y}');
        var step2 = Y.rules.appendStepHyps(step1, hyps);
        var result = Y.rules.instForall(step2, call(f, y));
        assertEqual('((p y) ==> (p (f y)))', result)
        Y.assert(result.hasHyps);
      },

      testR5214: function() {
        var inf = Y.rules.r5214();
        assertEqual('((T & F) = F)', inf);
      },

      testAndTBook: function() {
        var inf = Y.rules.andTBook(p);
        assertEqual('((T & p) = p)', inf);
      },

      testAndT: function() {
        var inf = Y.rules.andT(p);
        assertEqual('((T & p) = p)', inf);
      },

      testR5217Book: function() {
        assertEqual('((T = F) = F)', Y.rules.r5217Book());
      },

      testEquationCases: function() {
        var inf = Y.rules.equationCases(equal(T, T), equal(F, F), 'z');
        assertEqual('(z = z)', inf);
      },

      testR5218: function() {
        var inf = Y.rules.r5218(p);
        assertEqual('((T = p) = p)', inf);
      },

      testToTIsA: function() {
        var inf = Y.rules.toTIsA(p);
        assertEqual('(T = p)', inf);
        // Hyps
        var step1 = Y.rules.assume(p);
        var result = Y.rules.toTIsA(step1);
        assertEqual('(p ==> (T = p))', result);
      },

      testFromTIsA: function() {
        var inf = Y.rules.fromTIsA(call('=', T, p));
        assertEqual('p', inf);
        // Hyps
        var step1 = Y.rules.assume(p);
        var step2 = Y.rules.toTIsA(step1);
        var result = Y.rules.fromTIsA(step2);
        assertEqual('(p ==> p)', result);
      },

      testAddForall: function() {
        var inf = Y.rules.addForall(call(p, y), y);
        assertEqual('(forall {y. (p y)})', inf);

        // Hypotheses
        var step1 = Y.rules.assume(Y.parse('x = 0'));
        var wff = Y.parse('x = 0 ==> y > x');
        wff.hasHyps = true;
        wff.getLeft().sourceStep = step1;
        assertEqual('((x = 0) ==> (forall {y. (y > x)}))',
                    Y.rules.addForall(wff, 'y'));
      },

      testInstVar: function() {
        var result = Y.rules.instVar(call(p, y), call(f, x), y);
        assertEqual('(p (f x))', result);

        // Hypotheses
        // TODO: Make this really test with hypotheses.
        var step1 = Y.rules.axiom('axiom2');
        result = Y.rules.instVar(step1, call(p, x), x);
      },

      testInstiateVar: function() {
        var result =
          Y.rules.instantiateVar(call(p, y), '/right', call(f, x));
        assertEqual('(p (f x))', result);

        // Hypotheses
        // TODO: Make this really test with hypotheses.
        var step1 = Y.rules.axiom('axiom2');
        result = Y.rules.instVar(step1, call(p, x), x);
      },

      testInstMultiVars: function() {
        var map = {p: Y.parse('forall {x. T | b}'),
                   q: Y.parse('forall {x. b}')
        };
        var result = Y.rules.instMultiVars(implies(p, call('|', T, q)), map);
        assertEqual('((forall {x. (T | b)}) ==> (T | (forall {x. b})))',
                    result);

        // Hypotheses
        // TODO: Make this really test with hypotheses.
        var step = Y.rules.axiom('axiom2');
        var map2 = {x: call(p, x),
                    y: call(p, y)};
        var result = Y.rules.instMultiVars(step, map2);
        assertEqual('(((p x) = (p y)) ==> ((h (p x)) = (h (p y))))', result);
      },

      testCases: function() {
        var result = Y.rules.cases(equal(call(p, T), T),
                                   equal(call(p, F), F),
                                   x);
        assertEqual('((p x) = x)', result);

        // Hypotheses
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F')
        result = Y.rules.cases(step1, step2, 'x');
        // TODO: In tests with hypotheses, allow order of hypotheses
        //   to vary.
        assertEqual('(((p T) & (p F)) ==> (p x))', result);
        Y.assert(result.hasHyps);
      },

      testModusPonens: function() {
        var result = Y.rules.modusPonens(p, implies(p, q));
        assertEqual('q', result);

        // Hypotheses
        var step1 = Y.rules.assume('p ==> not p');
        // A tautology, but don't rely on the tautology rule here.
        var step2 = Y.rules.assert('(p ==> not p) ==> not p');
        result = Y.rules.modusPonens(step1, step2);
        assertEqual('((p ==> (not p)) ==> (not p))', result);
        Y.assert(result.hasHyps);
      },

      testTIsXIsX: function() {
        assertEqual('((T = x) = x)', rules.tIsXIsX());
      },

      testR5230TF: function() {
        assertEqual('((T = F) = F)', Y.rules.r5230TF());
      },

      testR5230FT_alternate: function() {
        assertEqual('((F = T) = F)', Y.rules.r5230FT_alternate());
      },

      testR5231T: function() {
        assertEqual('((not T) = F)', Y.rules.r5231T());
      },

      testR5231F: function() {
        assertEqual('((not F) = T)', Y.rules.r5231F());
      },

      testFalseEquals: function() {
        assertEqual('((F =) = not)', Y.rules.falseEquals());
      },

      testTrueEquals: function() {
        assertEqual('((T =) = {x. x})', Y.rules.trueEquals());
      },

      testEvalBool: function() {
        var inf = Y.rules.evalBool(call('not', T));
        assertEqual('((not T) = F)', inf);
        inf = Y.rules.evalBool(call('&', F, T));
        assertEqual('((F & T) = F)', inf);
        inf = Y.rules.evalBool(Y.parse('(p (F | T))'));
        assertEqual('((p (F | T)) = (p T))', inf);
        taut = Y.parse('(p ==> not p) ==> not p');
        inf = Y.rules.evalBool(taut.subst(T, p, {}));
        assertEqual('T', inf.getRight());
        inf = Y.rules.evalBool(taut.subst(F, p, {}));
        assertEqual('T', inf.getRight());
      },

      testTautology: function() {
        var wff = T;
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);

        var wff = equal(x, x);
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);

        var wff = Y.parse('(p ==> not p) ==> not p');
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);

        var wff = Y.parse('(p & q ==> r) = (p ==> (q ==> r))');
        var proved = Y.rules.tautology(wff);
        assertEqual(wff.toString(), proved);
        var proved = Y.rules.tautology(wff);
      },

      testTautologyAndProfile: function() {
        var wff = Y.parse('a1 & a2 & a3 & a4 & a5 & a6 == ' +
                          'a1 & a2 & a4 & a5 & a6 & a3');
        console.profile('Tautology');
        var inf = Y.rules.tautology(wff);
        console.profileEnd();
        assertEqual(wff.toString(), inf);
      },

      testMakeConjunction: function() {
        var result = Y.rules.makeConjunction(p, q);
        assertEqual('(p & q)', result);

        // With hypotheses:
        var step1 = Y.rules.assume(p);
        var step2 = Y.rules.assume(q);
        result = Y.rules.makeConjunction(step1, step2);
        assertEqual('((p & q) ==> (p & q))', result);
      },

      testTautInst: function() {
        var b = call(p, x);
        var map1 = {
          p: Y.parse('forall {x. T | p x}'),
          q: Y.parse('forall {x. p x}')
        };
        var result = Y.rules.tautInst(Y.parse('p ==> T | q'), map1);
        var expected =
          '((forall {x. (T | (p x))}) ==> (T | (forall {x. (p x)})))';
        assertEqual(expected, result);

        // With hypotheses:
        var h_taut = Y.parse('x > 0 ==> (p ==> p)');
        h_taut.hasHyps = true;
        var result = Y.rules.tautInst(h_taut, {p: q});
        assertEqual('((x > 0) ==> (q ==> q))', result);
        Y.assert(result.hasHyps);
      },

      testAnyImpliesTheorem: function() {
        var thm = Y.rules.theorem('t');
        var result = Y.rules.anyImpliesTheorem(Y.parse('x > 0'), thm);
        assertEqual('((x > 0) ==> T)', result);
      },

      testR5235: function() {
        var inf = Y.rules.r5235(x, p, call(q, x));
        var wff =
          '((forall {x. (p | (q x))}) ==> (p | (forall {x. (q x)})))';
        assertEqual(wff, inf);
      },

      testImplyForallThm: function() {
        var result = Y.rules.implyForallThm(x, p, call(q, x));
        var wff =
          '((forall {x. (p ==> (q x))}) ==> (p ==> (forall {x. (q x)})))';
        assertEqual(wff, result);
      },

      testImplyForall: function() {
        var result = Y.rules.implyForall(x, Y.parse('p ==> q x'));
        assertEqual('(p ==> (forall {x. (q x)}))', result);

        // With hypotheses:
        var step1 = Y.rules.assert('R y ==> (p ==> q x)');
	var step2 = Y.rules.assume('R y');
	var step3 = Y.rules.modusPonens(step2, step1);
        result = Y.rules.implyForall(x, step3);
        assertEqual('((R y) ==> (p ==> (forall {x. (q x)})))', result);
      },

      testForwardChain: function() {
        var step1 = Y.rules.assume('p x & (p x ==> q x)');
        var inf = Y.rules.forwardChain(step1, 'a & (a ==> b) ==> b');
        assertEqual('(q x)', inf.unHyp());

        var step1 = Y.rules.assert('h x ==> (p x & (p x ==> q x))');
	var step2 = Y.rules.assume('h x');
	var step3 = Y.rules.modusPonens(step2, step1);
        var result = Y.rules.forwardChain(step3,
                                          'a & (a ==> b) ==> b');
        assertEqual('((h x) ==> (q x))', result);
        Y.assert(result.hasHyps);
      },

      testBackwardChain: function() {
        // TODO: Implement me.
      },

      testSubgoal: function() {
        var input = Y.parse('R (x + (y + 2))');
        var theorem = rules.axiomTimesType();
        Y.log(rules.subgoal(input, theorem));
      },

      testR5238a: function() {
        var inf = Y.rules.r5238a(y, call(p, y), call(q, y));
        var wff =
          '(({y. (p y)} = {y. (q y)}) = (forall {y. ((p y) = (q y))}))';
        assertEqual(wff, inf);
      },

      testR5238: function() {
        var result = Y.rules.r5238(['x1', 'x2'],
                                   call(p, _var('x1')),
                                   call(p, _var('x2')));
        var wff =
          ('(({x1. {x2. (p x1)}} = {x1. {x2. (p x2)}}) = '
           + '(forall {x1. (forall {x2. ((p x1) = (p x2))})}))');
        assertEqual(wff, result);
      },

      testR5239: function() {
        var inf = Y.rules.r5239(equal(p, q),
                                lambda(p, equal(q, p)),
                                '/body/right');
        var expected =
          '((forall {p. (p = q)}) ==> ({p. (q = p)} = {p. (q = q)}))';
        assertEqual(expected, inf);

        inf = Y.rules.r5239(equal(p, q), equal(r, p), '/right');
        assertEqual('((p = q) ==> ((r = p) = (r = q)))', inf);

        // Here 'y' is bound in C and free in A = B.
        inf = Y.rules.r5239(Y.parse('(T = (y > x))'),
                            Y.parse('{y. T}'),
                            '/body');
        var expected =
          '((forall {y. (T = (y > x))}) ==> ({y. T} = {y. (y > x)}))';
        assertEqual(expected, inf);
      },

      testReplace: function() {
        var result = Y.rules.replace(Y.parse('x > 0 ==> (x = (abs x))'),
                                     Y.parse('x > 0 ==> ((x + x) > x)'),
                                     '/right/right');
        assertEqual('((x > 0) ==> ((x + x) > (abs x)))', result);
      },

      testBubbleLeft: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        function bubble(string) {
          return Y.rules.bubbleLeft(Y.parse(string), less);
        }
        var result = bubble('a & b');
        assertEqual('(a & b)', result.getRight());
        var result = bubble('b & a');
        assertEqual('((b & a) = (a & b))', result);

        result = bubble('a & b & c');
        assertEqual('((a & b) & c)', result.getRight());
        result = bubble('a & c & b');
        assertEqual('((a & b) & c)', result.getRight());
        result = bubble('b & c & a');
        assertEqual('((a & b) & c)', result.getRight());

        result = bubble('b & c & d & a');
        assertEqual('(((a & b) & c) & d)', result.getRight());
        result = bubble('a & c & d & b');
        assertEqual('(((a & b) & c) & d)', result.getRight());

        // With simplification.
        var result = bubble('a & a');
        assertEqual('a', result.getRight());
        var result = bubble('a & b & b');
        assertEqual('(a & b)', result.getRight());
        result = bubble('a & c & d & a');
        assertEqual('((a & c) & d)', result.getRight());
        result = bubble('b & a & d & a');
        assertEqual('((a & b) & d)', result.getRight());
      },

      testMergeRight: function() {
        var result = Y.rules.mergeRight(Y.parse('l == (a & b) & (c & d)'));
        assertEqual('(l == (a & ((c & d) & b)))', result);
        var result = Y.rules.mergeRight(Y.parse('l == a & (b & c & d)'));
        assertEqual('(l == (((b & c) & d) & a))', result);
      },

      testMergeConj: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        function merge(string) {
          return Y.rules.mergeConj(Y.rules.assert(string), less).getRight();
        }
        var result = merge('(a & b) & (c & d)');
        assertEqual('(((a & b) & c) & d)', result);
        var result = merge('a & (c & d)');
        assertEqual('((a & c) & d)', result);
        var result = merge('(a & b & c) & (a & b & c)');
        assertEqual('((a & b) & c)', result);
        var result = merge('(b & b & a) & (a & b & c)');
        assertEqual('((a & b) & c)', result);
      },

      testExtractHypothesis: function() {
        var rules = Y.rules;
        var step = rules.axiomCommutativePlus();
        var expected =
          '(((R x) & (R y)) ==> ((R x) ==> ((x + y) = (y + x))))';
        var result = rules.extractHypothesis(step, Y.parse('R x'));
        assertEqual(expected, result);
        expected =
          '(((R x) & (R y)) ==> ((R y) ==> ((x + y) = (y + x))))';
        result = rules.extractHypothesis(step, Y.parse('R y'));
        assertEqual(expected, result);
      },

      testIsolateCondition: function() {
        // TODO: implement me.
      },

      testConjunctionDeduper: function() {
        var rule = rules.conjunctionDeduper;
        checkRewriter(null, '(R x) & (R y)', rule);
        checkRewriter('(R x)', '(R x) & (R x)', rule);
        checkRewriter('(R x)', 'R x & T', rule);
        checkRewriter('((R x) & (R y))', 'R x & R y & R x', rule);
        checkRewriter('((R x) & (R y))',
                      '(R x) & (R y) & T & R y & R x', rule);
      },

      testConjunctsImplyConjunct: function() {
        var rule = rules.conjunctsImplyConjunct;
        function check(conjuncts, conjunct) {
          conjuncts =
            typeof conjuncts == 'string' ? Y.parse(conjuncts) : conjuncts;
          conjunct =
            typeof conjunct == 'string' ? Y.parse(conjunct) : conjunct;
          // Y.log(rule(conjuncts, conjunct));
          var result = rule(conjuncts, conjunct);
          assertEqual(Y.infixCall(conjuncts, '==>', conjunct) + '',
                      result);
        }
        check('a', 'a');
        check('a & b', 'b');
        check('a & b', 'a');
        check('a & b & c', 'b');
        check('(R x) & (R y)', '(R x)');
      },

      testDedupeHyps: function() {
        // TODO: Implement.
      },

      testEqualConjunctions: function() {
        var input = Y.parse('R x & T == T & R x');
        var proved = rules.equalConjunctions(input);
        assert(proved.matches(input));
        input = Y.parse('R x == R x & R x');
        proved = rules.equalConjunctions(input);
        assert(proved.matches(input));
        input = Y.parse('R x & R x & R (x + y) == R (x + y) & R x');
        proved = rules.equalConjunctions(input);
        assert(proved.matches(input));
      },

      testRepeatedlyRewrite: function() {
        var input = rules.assume('R (neg (neg (x + y)))');
        var result = rules.repeatedlyRewrite(input, '/right',
                                             rules.findTypeRewriter);
        assertEqual('(R (x + y))', result.getRight());
      },

      testArithmetic: function() {
        var input = rules.assume('x = 2 + 2');
        var result = rules.arithmetic(input, '/right/right');
        assertEqual('(x = 4)', result.getRight());
        input = rules.axiomReciprocal();
        var step1 = rules.instVar(input, '2', x);
        // Apply arithmetic to the "2 != 0" part of the instantiated axiom.
        var result = rules.arithmetic(step1, '/left/right');
        assertEqual('T', result.locate('/left/right'));
      },

      testSubtractionType: function() {
        assertEqual('(((R x) & (R y)) ==> (R (x - y)))',
                    rules.subtractionType());
      },

      testDivisionType: function() {
        assertEqual('(((R x) & ((R y) & (y != 0))) ==> (R (x / y)))',
                    rules.divisionType());
      },

      testNumericTypesSimplifier: function() {
        function check(expected, input) {
          checkRewriter(expected, input, rules.numericTypesSimplifier);
        }
        check('(p x)', 'p x');
        check('(p x)', 'p x & p x');
        check('((R x) & (R y))', 'R x & R y');
        check('(R x)', 'R x & R 2');
        check('(R x)', 'R x & R (neg x)');
        check('((R x) & (x != 0))', 'R x & x != 0 & R (recip x)');
        check('((R x) & (R y))', 'R x & R y & R (x + y)');
        check('((R x) & (R y))', 'R x & R y & R (neg (neg x + neg y))');
        check('(R x)', 'R x & (2 != 0)');
      },

      testSimplifyNumericTypes: function() {
        var profile;
        function checkRule(expected, step, rule, path) {
          if (profile) {
            console.profile(profile);
            profile = null;
          }
          var result = rule(step);
          console.profileEnd();
          if (expected == null) {
            assertEqual(null, result);
          } else {
            assert(result);
            var actual = path ? result.locate(path) : result;
            if (expected) {
              assertEqual(expected, actual);
            } else {
              Y.log('In: ' + step.getLeft());
              Y.log('Act: ' + actual);
            }
          }
        }
        function check(expected, step) {
          checkRule(expected, step, rules.simplifyNumericTypes, '/left');
        }
        var neg = rules.commutePlus(rules.axiomNeg(), '/right/left');
        check('(R x)', neg);

        var step1 = rules.assume('x + y + z + 3 = 3');
        var axiom = rules.axiomCommutativePlus();
        var step2 = rules.rewrite(step1, '/main/left', axiom);
        // To profile:
        // profile = 'Simplify Numerics';
        check('(((((((x + y) + z) + 3) = 3) & (R x)) & (R y)) & (R z))',
              step2);
      },

      testJustifyNumericType: function() {
        Y.autoAssert = false;
        var input = Y.parse('R x & R y ==> R (x + y)');
        assert(rules.justifyNumericType(input).matches(input));
        input = Y.parse('R x & R y & R z ==> R (x + y)');
        assert(rules.justifyNumericType(input).matches(input));
        input = Y.parse('R x ==> R (neg x)');
        assert(rules.justifyNumericType(input).matches(input));
        input = Y.parse('R x & x != 0 ==> R (recip x)');
        assert(rules.justifyNumericType(input).matches(input));
        input = Y.parse('x = 5 ==> R x');
        assertEqual('(((x = 5) & (R x)) ==> (R x))',
                    rules.justifyNumericType(input));
      },

      testOperateOnBoth: function() {
        var eqn = rules.eqSelf(x);
        var five = Y.parse('5');
        assertEqual('((x + 5) = (x + 5))',
                    rules.addToBoth(eqn, five));
        assertEqual('((x - 5) = (x - 5))',
                    rules.subtractFromBoth(eqn, five));
        assertEqual('((x * 5) = (x * 5))',
                    rules.multiplyBoth(eqn, five));
        assertEqual('((x / 5) = (x / 5))',
                    rules.divideBoth(eqn, five));
      },

      testConsider: function() {
        function check(expected, input) {
          input = typeof input == 'string' ? Y.parse(input) : input;
          var actual = rules.consider(input);
          assertEqual(expected, actual + '');
        }
        check('(x = x)', 'x');
        check('(((R x) & (R y)) ==> ((x + y) = (x + y)))', 'x + y');
      },

      // Utility functions for proofs.

      testBuildHypSchema: function() {
        var rules = Y.rules;
        var bs = Y._buildHypSchema;
        var map = new Y.TermMap();
        var schema = bs(rules.axiomAssociativePlus().getLeft(), map);
        assertEqual('((a1 & a2) & a3)', schema);
        assertEqual('a3', map.get(Y.parse('R z')));
      },

      // END OF RULES AND THEOREMS

      // Looking at what can be done with Andrews' definition of "and".
      // From here you can get counterexamples to the possibilities
      // that ordered pairs other than TT satisfy the definition.
      testFunWithAnd: function() {
        var result = Y.rules.funWithAnd();
      }
    });

  Y.Test.Runner.add(testCase);
  Y.Test.Runner.run();
  Y.Test.Runner.subscribe(Y.Test.Runner.COMPLETE_EVENT, function(event) {
      // Y.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      console.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      var passed = event.results.failed == 0 && event.results.passed > 0;
      document.body.style.backgroundColor = passed ? '#0C0' : '#F00';
      document.title += passed ? ' Passed' : ' Failed';
    });
});

</script>
</body>
</html>
