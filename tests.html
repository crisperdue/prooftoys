<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Builder Tests</title>

  <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui-min.js"></script>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="proofdisplay.js"></script>
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

  h1 { color: black }
  body { xbackground-color: #EEF }
  .yui3-skin-sam .yui3-console-entry-pass .yui3-console-entry-cat {
    background-color: #0C0;
    color: black;
  }
  .yui3-skin-sam .yui3-console-entry-fail .yui3-console-entry-src {
    background-color: red;
    color: white;
  }

</style>
  
</head>
<body class=yui3-skin-sam
  style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Test Results</h1>

<div id=log class="yui3-skin-sam">
</div>


<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
   'proof', 'querystring',
   function(Y) {

  // Initialize the console
  var yconsole = new Y.Console({
      style: 'block',
      height: '600px',
      width: '700px',
      newestOnTop: false                   
    });
  yconsole.render('#log');

  // Make "Y" available globally.
  window.Y = Y;

  function assertEqual(a, b) {
    Y.Assert.areEqual(a, b);
  }

  // Logs the result of each top-level step of an ifnerence.
  function logDetails(inference) {
    var details = inference.proof.steps;
    for (var i = 0; i < details.length; i++) {
      var step = details[i];
      Y.log(step.result + ' ' + step.name);
    }
  }

  // Logs the assumptions of an inference.
  function logAssumptions(inference) {
    var assumptions = inference.assumptions();
    for (var a in assumptions) {
      Y.log('Assuming ' + a);
    }
  }

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Example equation: x + x = 2 * x
  var times2 = call('=', call('+', x, x), call('*', '2', x));

  // Example WFF: x > 0 --> x + x > x
  var bigger = call('-->', call('>', x, '0'),
                    call('>', call('+', x, x), x));

  var testCase = new Y.Test.Case({

      name: "Proof Tests",

      _should: {
        ignore: {
          // testTautology: true  // More time-consuming.
        }
      },

      setUp: function() {
        tracing = false;
      },

      // Warmups, to confirm what some assertions do.

      testTrue: function() {
        Y.Assert.areEqual(true, true);
      },
      test11: function() {
        Y.Assert.areEqual(1, 1);
      },
      testTrue1: function() {
        Y.Assert.areEqual(true, 1);
      },

      // Tests for expr.js.

      testVar: function() {
        assertEqual('x', x.toString());
      },

      testApp: function() {
        var app = call(f, x);
        assertEqual(f, app.fn);
        assertEqual(x, app.arg);
        assertEqual('(f x)', app.toString());
      },

      testLambda: function() {
        var abs = lambda(x, f);
        assertEqual(x, abs.bound);
        assertEqual(f, abs.body);
        assertEqual('{x : f}', abs.toString());

        assertEqual('{x : (f x)}', lambda(x, call(f, x)));
      },

      testFreeNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.freeNames();
        assertEqual(true, map['f']);
        assertEqual(undefined, map['x']);
      },

      testBoundNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.boundNames('');
        assertEqual('{}', Y.debugString(map));
        var map = wff.boundNames('/body/arg');
        assertEqual('{x: true}', Y.debugString(map));
      },

      testDecapture: function() {
        var target = call(lambda(x, x), y);
        var result = Y.decapture(target, x);
        assertEqual('({x_1 : x_1} y)', result.toString());
      },

      testSubFree: function() {
        var v = _var('v');
        var target = call(lambda(v, v), x);
        // Now substitute in 'a different v':
        var result = Y.subFree(_var('v'), x, target);
        // We see that it replaces just the free occurrence, and renames
        // the bound occurrence.
        assertEqual('({v_1 : v_1} v)', result.toString());
      },

      testNormalize: function() {
        var e1 = call(lambda(x, call(f, x)), _var('y'));
        var result = Y.normalized(e1);
        assertEqual('({$1 : (f $1)} y)', result.toString());
      },

      testIsCall2: function() {
        Y.Assert.isTrue(times2.isCall2('='), 'Times2 not an equation?');
      },

      testReplace: function() {
        var y = _var('y');
        var e1 = call(lambda(x, call(f, x)), y);
        var path = Y.path('/fn/body/arg');
        var result = e1.replace(path, function(expr) { return call(f, x); });
        assertEqual('({x : (f (f x))} y)', result.toString());
      },

      testPath: function() {
        var p = '/a/b';
        var path = Y.path(p);
        assertEqual(p, path.toString());
        assertEqual('a', path.segment);
        assertEqual('b', path.rest('a').segment);
        Y.assert(path.rest('a').rest('b').isMatch());
        assertEqual('(none)', path.rest('b').toString());
        Y.assert(Y.path('/').isMatch());
        assertEqual('f', Y.path('fn').next(call(f, x)).toString());
        assertEqual('x', Y.path('arg').next(call(f, x)).toString());
        var p2 = '/left/binop';
        assertEqual('/fn/arg/fn/fn', Y.path(p2).toString());
      },

      testSearch: function() {
        xPlusX = call('+', x, x)
        var found =
          times2.search(function(expr) { return xPlusX.matches(expr); });
        assertEqual('(x + x)', found.toString());
      },

      testLocate: function() {
        var expr = call('forall', lambda(x, call(p, x)));
        var body = expr.locate(Y.path('/arg/body'));
        assertEqual('(p x)', body.toString());
      },

      testPathTo: function() {
        function findX(expr) {
          return expr == x;
        }
        assertEqual('', '' + x.pathTo(findX));
        assertEqual('/fn', '' + call(x, y).pathTo(findX));
        assertEqual('/arg', '' + call(y, x).pathTo(findX));
        assertEqual('/body', '' + lambda(x, x).pathTo(findX));
        assertEqual('/arg/arg/arg',
                    '' + call(f, call(f, call(g, x))).pathTo(findX));
      },

      testMatchAsSchema: function() {
        var bindings = Y.matchAsSchema(p, equal(x, x));
        assertEqual('{p: (x = x)}',
                    Y.debugString(bindings));
        bindings = Y.matchAsSchema(implies(p, q),
                                   Y.parse('x < 1 --> (x = 0)'));
        assertEqual('{p: (x < 1), q: (x = 0)}',
                    Y.debugString(bindings));
      },

      testGeneralizeTF: function() {
        var gen = Y.parse('p T = T').generalizeTF(Y.parse('p F = F'));
        assertEqual('((p v) = v)', gen + '');
        try {
          Y.parse('p T = x').generalizeTF(Y.parse('p F = F'));
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
        try {
          Y.parse('p T').generalizeTF(Y.parse('p T F'));
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
      },

      // PARSER

      testTokenize: function() {
        var result = Y.tokenize('a');
        assertEqual('a,(end)', result);
        result = Y.tokenize('(a > b)');
        assertEqual('(,a,>,b,),(end)', result);
        result = Y.tokenize('{x|x}');
        assertEqual('{,x,|,x,},(end)', result);
        result = Y.tokenize('(=>x*)');
        assertEqual('(,=>,x,*,),(end)', result);
      },

      testParse: function() {
        var result = Y.parse('a');
        assertEqual('a', result.dump());
        result = Y.parse('(xx)');
        assertEqual('xx', result.dump());
        result = Y.parse('f x');
        assertEqual('(f x)', result.dump());
        result = Y.parse('not = (F =)');
        assertEqual('((not =) (F =))', result.dump());
        result = Y.parse('{x|x} T');
        assertEqual('({x : x} T)', result);
        result = Y.parse('a + b * c');
        assertEqual('(a + (b * c))', result);
        result = Y.parse('a --> a && c');
        assertEqual('(a --> (a && c))', result);
      },


      // PROOFS

      // Actually "proof support" function:
      testIsConstant: function() {
        Y.assert(Y.isConstant('T'));
        Y.assert(Y.isConstant(T));
        Y.assert(Y.isConstant('-->'));
        Y.assert(!Y.isConstant(equal(x, x)));
      },

      testRuleR: function() {
        var path = Y.path('/right/left');
        var inf = Y.makeInference('r', [times2, bigger, path]);
        assertEqual('((x > 0) --> ((2 * x) > x))', inf.result);
        var assumptions = inf.assumptions();
      },

      testAxiom4: function() {
        var app = call(lambda(x, call(f, x)), y);
        var result = Y.makeInference('axiom4', [app]).result;
        Y.Assert.isInstanceOf(Y.Call, result);
        assertEqual('=', result.fn.fn.name);
        assertEqual('(({x : (f x)} y) = (f y))', result);
      },

      testAxioms: function() {
        assertEqual('(((g T) && (g F)) = (forall {x : (g x)}))',
                    Y.makeInference('axiom1').result);
        assertEqual('((x = y) --> ((h x) = (h y)))',
                    Y.makeInference('axiom2').result);
        assertEqual('((f = g) = (forall {x : ((f x) = (g x))}))',
                    Y.makeInference('axiom3').result);
        assertEqual('((the (y =)) = y)',
                    Y.makeInference('axiom5').result);
      },

      testApplyBoth: function() {
        var inf = Y.makeInference('applyBoth',
                                  [call('=', f, g),
                                   x]);
        logDetails(inf);
      },

      testEqSelf: function() {
        var result = Y.makeInference('eqSelf', [call(f, y)]).result;
        assertEqual('((f y) = (f y))', result);
        assertEqual('(x = x)', Y.makeInference('eqSelf', [x]).result);
      },

      testR5201a: function() {
        var inf = Y.makeInference('replaceWhole',
                                  [call(p, x),
                                   call('=', call(p, x), call(q, x))]);
        assertEqual('(q x)', inf.result);
      },

      testR5201b: function() {
        var inf = Y.makeInference('eqnSwap', [call('=', p, q)]);
        assertEqual('(q = p)', inf.result);
      },

      testR5201c: function() {
        var inf = Y.makeInference('eqnChain',
                                  [call('=', p, q), call('=', q, r)]);
        assertEqual('(p = r)', inf.result);
      },

      testR5201d: function() {
        var inf =
          Y.makeInference('applyBySides',
                          [call('=', p, q), call('=', 'a', 'b')]);
        assertEqual('((p a) = (q b))', inf.result);
      },

      testR5201e: function() {
        var inf = Y.makeInference('applyBoth', [call('=', p, q), r]);
        assertEqual('((p r) = (q r))', inf.result);
      },

      testR5201f: function() {
        var inf = Y.makeInference('applyToBoth', [p, call('=', q, r)]);
        assertEqual('((p q) = (p r))', inf.result);
      },

      testUseDefinition: function() {
        var inf =
          Y.makeInference('useDefinition',
                          ['not', call('not', equal(p, equal(F, p))), '/fn']);
        assertEqual('(F = (p = (F = p)))', inf.result);
      },

      testInstEqn: function() {
        var c = new Y.Var('c');
        var inf =
          Y.makeInference('instEqn', [call('=', call(g, y), c), call(f, x), y]);
        assertEqual('((g (f x)) = c)', inf.result);
      },

      testEqT: function() {
        assertEqual('(T = (b = b))', Y.makeInference('eqT', ['b']).result);
	var inf = Y.makeInference('eqT', [call(f, x)]);
        assertEqual('(T = ((f x) = (f x)))', inf.result);
	var node = Y.renderInference(inf);
        var proof = inf.proof;
        var step = proof.steps[2];
        var expr = step.result.locate('/left');
        assertEqual('({y : y} = g)', expr);
        Y.log('expr found');
        assertEqual(step, Y.getProofStep(expr.node));
        Y.log('getProofStep OK');
        assertEqual(proof, Y.getProof(expr.node));
        Y.log('getProof OK')
        assertEqual(expr, Y.getExpr(expr.node));
        Y.log('getExpr OK');
      },

      testR5211: function() {
        var inf = Y.makeInference('r5211', []);
        assertEqual('((T && T) = T)', inf.result);
      },

      testRuleT: function() {
        assertEqual('T', Y.makeInference('t').result);
      },

      testR5212: function() {
        var inf = Y.makeInference('r5212', []);
        assertEqual('(T && T)', inf.result);
      },

      testEqnIsTrue: function() {
        var inf = Y.makeInference('toTIsEquation', [call('=', p, q)]);
        assertEqual('(T = (p = q))', inf.result);
      },

      testR5213: function() {
        var inf = Y.makeInference('r5213',
                                  [call('=', p, q),
                                   call('=', q, r)]);
        assertEqual('((p = q) && (q = r))', inf.result);
      },

      testChangeVar: function() {
        var expr = equal(lambda(z, z), lambda(y, y));
        var inf = Y.makeInference('changeVar', [expr, '/left', y]);
        logDetails(inf);
      },

      testBindEqn: function() {
        var inf = Y.makeInference('bindEqn', [call('=', f, g), x]);
        assertEqual('({x : f} = {x : g})', inf.result);
      },

      testForallInst: function() {
        var inf = Y.makeInference('forallInst',
                                  [call('forall', lambda(y, call(p, y))),
                                   call(f, y)])
        assertEqual('(p (f y))', inf.result);
        logAssumptions(inf);
      },

      testAndTBook: function() {
        var inf = Y.makeInference('andTBook', [p]);
        assertEqual('((T && p) = p)', inf.result);
      },

      testAndT: function() {
        var inf = Y.makeInference('andT', [p]);
        assertEqual('((T && p) = p)', inf.result);
      },

      testR5217Book: function() {
        var inf = Y.makeInference('r5217Book', []);
        assertEqual('((T = F) = F)', inf.result);
      },

      testEquationCases: function() {
        var inf = Y.makeInference('equationCases',
                                  [lambda(z, equal(z, z))]);
        assertEqual('(z = z)', inf.result);
      },

      testR5218: function() {
        var inf = Y.makeInference('r5218', [p]);
        assertEqual('((T = p) = p)', inf.result);
      },

      testToTIsA: function() {
        var inf = Y.makeInference('toTIsA', [p]);
        assertEqual('(T = p)', inf.result);
        logAssumptions(inf);
      },

      testFromTIsA: function() {
        var inf = Y.makeInference('fromTIsA', [call('=', T, p)]);
        assertEqual('p', inf.result);
        logAssumptions(inf);
      },

      testUGen: function() {
        var inf = Y.makeInference('uGen', [call(p, y), y]);
        assertEqual('(forall {y : (p y)})', inf.result);
        logAssumptions(inf);
      },

      testSub: function() {
        var inf = Y.makeInference('sub', [call(p, y), call(f, x), y]);
        assertEqual('(p (f x))', inf.result);
        logAssumptions(inf);
      },

      testSubAll: function() {
        var map = {p: Y.parse('forall {x | T || b}'),
                   q: Y.parse('forall {x | b}')
        };
        var inf = Y.makeInference('subAll',
                                  [implies(p, call('||', T, q)), map]);
        assertEqual('((forall {x : (T || b)}) --> (T || (forall {x : b})))',
                    inf.result);
        logAssumptions(inf);
      },

      testCases: function() {
        var inf = Y.makeInference('cases', [z, call('=', call(p, z), z)]);
        assertEqual('((p z) = z)', inf.result);
        logAssumptions(inf);
      },

      testModusPonens: function() {
        var inf = Y.makeInference('modusPonens', [p, implies(p, q)]);
        assertEqual('q', inf.result);
        logAssumptions(inf);
      },

      testR5230TF: function() {
        var inf = Y.makeInference('r5230TF');
        assertEqual('((T = F) = F)', inf.result);
      },

      testR5230FT_alternate: function() {
        var inf = Y.makeInference('r5230FT_alternate');
        assertEqual('((F = T) = F)', inf.result);
      },

      testR5231T: function() {
        var inf = Y.makeInference('r5231T');
        assertEqual('((not T) = F)', inf.result);
      },

      testR5231F: function() {
        var inf = Y.makeInference('r5231F');
        assertEqual('((not F) = T)', inf.result);
      },

      testFalseEquals: function() {
        var inf = Y.makeInference('falseEquals');
        assertEqual('((F =) = not)', inf.result);
      },

      testTrueEquals: function() {
        var inf = Y.makeInference('trueEquals');
        assertEqual('((T =) = {x : x})', inf.result);
      },

      testEvalBool: function() {
        var inf = Y.makeInference('evalBool', [call('not', T)]);
        assertEqual('((not T) = F)', inf.result);
        inf = Y.makeInference('evalBool', [call('&&', F, T)]);
        assertEqual('((F && T) = F)', inf.result);
        inf = Y.makeInference('evalBool', [Y.parse('(p (F || T))')]);
        assertEqual('((p (F || T)) = (p T))', inf.result);
        taut = Y.parse('(p --> not p) --> not p');
        inf = Y.makeInference('evalBool', [taut.subst(T, p, {})]);
        assertEqual('T', inf.result.getRight());
        inf = Y.makeInference('evalBool', [taut.subst(F, p, {})]);
        assertEqual('T', inf.result.getRight());
      },

      testTautology: function() {
        var wff = T;
        var inf = Y.makeInference('tautology', [wff]);
        assertEqual(wff.toString(), inf.result);
        var wff = equal(x, x);
        var inf = Y.makeInference('tautology', [wff]);
        assertEqual(wff.toString(), inf.result);
        var wff = Y.parse('(p --> not p) --> not p');
        Y.log('Tautology: ' + wff);
        var inf = Y.makeInference('tautology', [wff]);
        assertEqual(wff.toString(), inf.result);
        var wff = Y.parse('(p && q --> r) = (p --> (q --> r))');
        Y.log('Tautology: ' + wff);
        var inf = Y.makeInference('tautology', [wff]);
        assertEqual(wff.toString(), inf.result);
      },

      testMakeConjunction: function() {
        var inf = Y.makeInference('makeConjunction', [p, q]);
        assertEqual('(p && q)', inf.result);
      },

      testTautInst: function() {
        var b = call(p, x);
        var map1 = {
          p: call('forall', lambda(x, call('||', T, b))),
          q: call('forall', lambda(x, b))
        };
        var inf = Y.makeInference('tautInst',
                                  [implies(p, call('||', T, q)), map1]);
        logDetails(inf);
      },

      testR5235: function() {
        var inf = Y.makeInference('r5235', [x, p, call(q, x)]);
        var wff =
          '((forall {x : (p || (q x))}) --> (p || (forall {x : (q x)})))';
        assertEqual(wff, inf.result);
      },

      testImplyForall: function() {
        var inf = Y.makeInference('implyForall', [x, p, call(q, x)]);
        var wff =
          '((forall {x : (p --> (q x))}) --> (p --> (forall {x : (q x)})))';
        assertEqual(wff, inf.result);
      },

      testP: function() {
        var inf = Y.makeInference('p', [Y.parse('p x'),
                                         Y.parse('p x --> q x'),
                                         Y.parse('q x'),
                                         Y.parse('P && (P --> Q) --> Q')]);
        assertEqual('(q x)', inf.result);
      },

      testR5238a: function() {
        var inf = Y.makeInference('r5238a',
                                  [y, call(p, y), call(q, y)]);
        var wff =
          '(({y : (p y)} = {y : (q y)}) = (forall {y : ((p y) = (q y))}))';
        assertEqual(wff, inf.result);
      },

      testR5238: function() {
        var inf = Y.makeInference('r5238',
                                  [['x1', 'x2'],
                                   call(p, _var('x1')),
                                   call(p, _var('x2'))]);
        var wff =
          ('(({x1 : {x2 : (p x1)}} = {x1 : {x2 : (p x2)}}) = '
           + '(forall {x1 : (forall {x2 : ((p x1) = (p x2))})}))');
        assertEqual(wff, inf.result);
      },

      testR5239: function() {
        var inf = Y.makeInference('r5239',
                                  [equal(p, q),
                                   lambda(p, equal(q, p)),
                                   '/body/right']);
        var wff =
          '((forall {p : (p = q)}) --> ({p : (q = p)} = {p : (q = q)}))';
        assertEqual(wff, inf.result);
        inf = Y.makeInference('r5239',
                              [equal(p, q), equal(r, p), '/right']);
        assertEqual('((p = q) --> ((r = p) = (r = q)))', inf.result);
      },

      testReplace: function() {
        var args = [Y.parse('x > 0 --> (x = (abs x))'),
             Y.parse('x > 0 --> ((x + x) > x)'), '/right'
             ]
        var inf = Y.makeInference('replace', args);
        assertEqual('((x > 0) --> ((x + x) > (abs x)))', inf.result);
      },


      // END OF RULES AND THEOREMS

      // Looking at what can be done with Andrews' definition of "and".
      // From here you can get counterexamples to the possibilities
      // that ordered pairs other than TT satisfy the definition.
      testFunWithAnd: function() {
        var inf = Y.makeInference('funWithAnd', []);
        // logDetails(inf);
      },

      testMakeInference: function() {
        var inf = Y.makeInference('eqT', [x]);
        Y.log(inf.toString());
        assertEqual('eqT', inf.name);
        assertEqual(1, inf.arguments.length);
        assertEqual('x', inf.arguments[0].name);
      }
  });

  Y.Test.Runner.add(testCase);
  Y.Test.Runner.run();
  Y.Test.Runner.subscribe(Y.Test.Runner.COMPLETE_EVENT, function(event) {
      // Y.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      console.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      document.body.style.backgroundColor = 
        (event.results.failed == 0 && event.results.passed > 0)
        ? '#0C0'
        : '#F00';
    });
});

</script>
</body>
</html>
