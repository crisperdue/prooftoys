<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Builder Tests</title>

  <script src="http://yui.yahooapis.com/3.4.0/build/yui/yui-min.js"></script>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

  h1 { color: black }
  body { xbackground-color: #EEF }
  .yui3-skin-sam .yui3-console-entry-pass .yui3-console-entry-cat {
    background-color: #0C0;
    color: black;
  }
  .yui3-skin-sam .yui3-console-entry-fail .yui3-console-entry-src {
    background-color: red;
    color: white;
  }

</style>
  
</head>
<body class=yui3-skin-sam
  style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Test Results</h1>

<div id=log class="yui3-skin-sam">
</div>


<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
   'proof', 'querystring',
   function(Y) {

  // Initialize the console
  var yconsole = new Y.Console({
      style: 'block',
      height: '600px',
      width: '700px',
      newestOnTop: false                   
    });
  yconsole.render('#log');

  // Make "Y" available globally.
  window.Y = Y;

  function assertEqual(a, b) {
    Y.Assert.areEqual(a, b);
  }

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Do not display source step info in toString.
  Y.trackSourceSteps = false;

  // Example equation: x + x = 2 * x
  var times2 = call('=', call('+', x, x), call('*', '2', x));

  // Example WFF: x > 0 --> x + x > x
  var bigger = call('-->', call('>', x, '0'),
                    call('>', call('+', x, x), x));

  var testCase = new Y.Test.Case({

      name: "Proof Tests",

      _should: {
        ignore: {
          // testTautology: true  // More time-consuming.
        }
      },

      setUp: function() {
        tracing = false;
      },

      // Warmups, to confirm what some assertions do.

      testTrue: function() {
        Y.Assert.areEqual(true, true);
      },
      test11: function() {
        Y.Assert.areEqual(1, 1);
      },
      testTrue1: function() {
        Y.Assert.areEqual(true, 1);
      },

      // Tests for expr.js.

      testVar: function() {
        assertEqual('x', x.toString());
      },

      testApp: function() {
        var app = call(f, x);
        assertEqual(f, app.fn);
        assertEqual(x, app.arg);
        assertEqual('(f x)', app.toString());
      },

      testLambda: function() {
        var abs = lambda(x, f);
        assertEqual(x, abs.bound);
        assertEqual(f, abs.body);
        assertEqual('{x. f}', abs.toString());

        assertEqual('{x. (f x)}', lambda(x, call(f, x)));
      },

      testFreeNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.freeNames();
        assertEqual(true, map['f']);
        assertEqual(undefined, map['x']);
      },

      testBoundNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.boundNames('');
        assertEqual('{}', Y.debugString(map));
        var map = wff.boundNames('/body/arg');
        assertEqual('{x: true}', Y.debugString(map));
      },

      testSubst: function() {
        var target = Y.parse('x = ({x. x} x)');
        assertEqual('(y = ({x. x} y))', target.subst(y, x));
        // Result is exactly the input where there are no occurrences.
        Y.assert(target === target.subst(z, y));
        Y.assert(target.locate('/right/fn')
                 === target.subst(y, x).locate('/right/fn'));
      },

      testCopy: function() {
        var source = '(x = x)';
        var target = Y.parse(source);
        // Copy is equal to original
        assertEqual(source, target.copy());
        Y.assert(target.matches(target.copy()));
        // But not identical.
        Y.assert(target !== target.copy());
      },

      testDecapture: function() {
        var target = call(lambda(x, x), y);
        var result = Y.decapture(target, x);
        assertEqual('({x_1. x_1} y)', result.toString());
        var target = Y.parse('({x. f x} y)');
        // Result is exactly the input when no decapturing is needed.
        Y.assert(target === Y.decapture(target, z));
      },

      testSubFree: function() {
        var v = _var('v');
        var target = call(lambda(v, v), x);
        // Now substitute in 'a different v':
        var result = Y.subFree(_var('v'), x, target);
        // We see that it replaces just the free occurrence.
        assertEqual('({v. v} v)', result.toString());
        // A case where decapturing is needed.
        result = Y.subFree(y, x, Y.parse('{y. x} x'));
        assertEqual('({x_1. y} y)', result);
        // A very similar case where it is not needed.
        result = Y.subFree(y, x, Y.parse('{y. T} x'));
        assertEqual('({y. T} y)', result);
      },

      testNormalize: function() {
        var e1 = call(lambda(x, call(f, x)), _var('y'));
        var result = Y.normalized(e1);
        assertEqual('({$1. (f $1)} y)', result.toString());
      },

      testIsCall2: function() {
        Y.Assert.isTrue(times2.isCall2('='), 'Times2 not an equation?');
      },

      testExprReplace: function() {
        var y = _var('y');
        var e1 = call(lambda(x, call(f, x)), y);
        var path = Y.path('/fn/body/arg');
        var result = e1.replace(path, function(expr) { return call(f, x); });
        assertEqual('({x. (f (f x))} y)', result.toString());
        var target = Y.parse('f x = y');
        result = target.replace(Y.path('/right'), function(expr) { return z; });
        Y.assert(target.getLeft() === result.getLeft());
      },

      testPath: function() {
        var p = '/a/b';
        var path = Y.path(p);
        assertEqual(p, path.toString());
        assertEqual('a', path.segment);
        assertEqual('b', path.rest('a').segment);
        Y.assert(path.rest('a').rest('b').isMatch());
        assertEqual('(none)', path.rest('b').toString());
        Y.assert(Y.path('/').isMatch());
        assertEqual('f', Y.path('fn').next(call(f, x)).toString());
        assertEqual('x', Y.path('arg').next(call(f, x)).toString());
        var p2 = '/left/binop';
        assertEqual('/fn/arg/fn/fn', Y.path(p2).toString());
        var p3 = '/arg/fn';
        assertEqual(p3 + p3, Y.path(p3).concat(p3));
      },

      testSearch: function() {
        xPlusX = call('+', x, x)
        var found =
          times2.search(function(expr) { return xPlusX.matches(expr); });
        assertEqual('(x + x)', found.toString());
      },

      testLocate: function() {
        var expr = call('forall', lambda(x, call(p, x)));
        var body = expr.locate(Y.path('/arg/body'));
        assertEqual('(p x)', body.toString());
      },

      testPathTo: function() {
        function findX(expr) {
          return expr == x;
        }
        assertEqual('', '' + x.pathTo(findX));
        assertEqual('/fn', '' + call(x, y).pathTo(findX));
        assertEqual('/arg', '' + call(y, x).pathTo(findX));
        assertEqual('/body', '' + lambda(x, x).pathTo(findX));
        assertEqual('/arg/arg/arg',
                    '' + call(f, call(f, call(g, x))).pathTo(findX));
      },

      testPathToBinding: function() {
        function isX(expr) {
          return expr == x;
        }
        assertEqual(null, x.pathToBinding(isX));
        assertEqual(null, call(x, y).pathToBinding(isX));
        assertEqual('', '' + lambda(x, x).pathToBinding(isX));
        assertEqual('/fn',
                    '' + call(lambda(x, x), z).pathToBinding(isX));
      },

      testMatchAsSchema: function() {
        var bindings = Y.matchAsSchema(p, equal(x, x));
        assertEqual('{p: (x = x)}',
                    Y.debugString(bindings));
        bindings = Y.matchAsSchema(implies(p, q),
                                   Y.parse('x < 1 --> (x = 0)'));
        assertEqual('{p: (x < 1), q: (x = 0)}',
                    Y.debugString(bindings));
      },

      testGeneralizeTF: function() {
        var gen = Y.parse('p T = T').generalizeTF(Y.parse('p F = F'), x);
        assertEqual('((p x) = x)', gen + '');
        try {
          Y.parse('p T = x').generalizeTF(Y.parse('p F = F'), x);
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
        try {
          Y.parse('p T').generalizeTF(Y.parse('p T F'), x);
          Y.Assert.fail('generalizeTF should have failed');
        } catch(e) {}
      },

      testHasArgs: function() {
        Y.assert(Y.parse('f x').hasArgs(1));
        Y.assert(!Y.parse('f x').hasArgs(2));
        Y.assert(Y.parse('x + 1').hasArgs(1));
        Y.assert(Y.parse('x + 1').hasArgs(2));
        Y.assert(!Y.parse('x + 1').hasArgs(3));
      },

      testIsHypotheses: function() {
        var step1 = Y.rules.assume(Y.parse('p x'));
        Y.assert(step1.getLeft().isHypotheses());
        Y.assert(step1.getRight().isHypotheses());
        var conj = Y.infixCall(step1.getLeft(), '&&', step1.getRight());
        Y.assert(conj.isHypotheses());
        var conj2 = Y.infixCall(conj, '&&', conj);
        Y.assert(conj2.isHypotheses());
      },

      testSourceStepLess: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        // Which step came earlier?
        Y.assert(Y.sourceStepLess(step1.getLeft(), step2.getLeft()));
        Y.assert(!Y.sourceStepLess(step2.getLeft(), step1.getLeft()));
      },

      testRepeatedCall: function() {
        try {
          Y.repeatedCall('&&', []);
          Y.Assert.fail('repeatedCall should throw here');
        } catch(e) {}
        assertEqual('x1', Y.repeatedCall('&&', [1]));
        assertEqual('(x3 && x5)', Y.repeatedCall('&&', [3, 5]));
        assertEqual('((x3 && x5) && x19)',
                    Y.repeatedCall('&&', [3, 5, 19]));
      },


      // PARSER

      testTokenize: function() {
        var result = Y.tokenize('a');
        assertEqual('a,(end)', result);
        result = Y.tokenize('(a > b)');
        assertEqual('(,a,>,b,),(end)', result);
        result = Y.tokenize('{x.x}');
        assertEqual('{,x,.,x,},(end)', result);
        result = Y.tokenize('(=>x*)');
        assertEqual('(,=>,x,*,),(end)', result);
      },

      testParse: function() {
        var result = Y.parse('a');
        assertEqual('a', result.dump());
        result = Y.parse('(xx)');
        assertEqual('xx', result.dump());
        result = Y.parse('f x');
        assertEqual('(f x)', result.dump());
        result = Y.parse('not = (F =)');
        assertEqual('((not =) (F =))', result.dump());
        result = Y.parse('{x.x} T');
        assertEqual('({x. x} T)', result);
        result = Y.parse('a + b * c');
        assertEqual('(a + (b * c))', result);
        result = Y.parse('a --> a && c');
        assertEqual('(a --> (a && c))', result);
        // Numbers
        assertEqual(42, Y.parse('42').value);
        var expr = Y.parse('x + 103');
        assertEqual(103, expr.getRight().value);
        assertEqual(undefined, expr.getLeft().value);
      },


      // ALIASES

      testAliases: function() {
        var parse = Y.parse;
        // Printing and parsing should be inverses.
        assertEqual('(a == b)', parse('a == b'));
        // Aliases should not affect meanings of expressions.
        Y.assert(parse('a == b').matches(parse('a = b')));
      },


      // UTILITIES

      testCheckNumber: function() {
        assertEqual(42, Y.checkNumber(42));
        try {
          Y.checkNumber('42');
          Y.Assert.fail('Should throw');
        } catch(e) {}
      },

      testCheckRange: function() {
        assertEqual(42, Y.checkRange(42));
        try {
          Y.checkRange(-Math.pow(2, 53));
          Y.Assert.Fail('Should throw');
        } catch(e) {}
      },


      // CONSTANTS AND DEFINITIONS

      // Actually "proof support" function:
      testIsConstant: function() {
        Y.assert(Y.isConstant('T'));
        Y.assert(Y.isConstant(T));
        Y.assert(Y.isConstant('-->'));
        Y.assert(!Y.isConstant(equal(x, x)));
      },

      testIsDefined: function() {
        Y.assert(Y.isDefined('T'));
        Y.assert(Y.isDefined(T));
        Y.assert(Y.isDefined('-->'));
	Y.assert(Y.isDefined('forall'));
	Y.assert(Y.isDefined(_var('forall')));
        try {
          Y.isDefined(equal(x, x));
          Y.Assert.fail('Name not a variable or string');
        } catch(e) {}
      },


      // TYPES

      testParseType: function() {
        function check(expected, input) {
          assertEqual(expected, Y.parseType(input));
        }
        check('i', 'i');
        check('o', 'o');
        check('R', 'R');
        check('t12', 't12');
        check('(o i)', 'o i');
        check('i', '(i)');
        check('((o R) R)', 'o R R');
        check('((o i) i)', '(o i i)');
        check('(o (o i))', 'o (o i)');
      },

      // TYPE INFERENCE

      testFindType: function() {
        var rules = Y.rules;
        assertEqual('o', Y.findType(T));
        assertEqual('o', Y.findType(Y.parse('x = x')));
        try {
          Y.findType(Y.parse('f f'));
          Y.Assert.fail('Should not unify');
        } catch(e) {}
        // The identity function, problematic for some algorithms.
        var type = Y.findType(Y.parse('{x. x}'));
        Y.assert(type instanceof Y.FunctionType, 'Not a FunctionType');
        Y.assert(type.types[0] instanceof Y.TypeVariable, 'Not a TypeVariable');
        assertEqual(type.types[0], type.types[1]);
        assertEqual('o', Y.findType(rules.axiom1()));
        assertEqual('o', Y.findType(rules.axiom2()));
        assertEqual('o', Y.findType(rules.axiom3()));
        assertEqual('o', Y.findType(rules.axiom4(Y.parse('({x. x} y)'))));
        assertEqual('o', Y.findType(rules.axiom5()));
        function check(expected, expr) {
          expr = (typeof expr == 'string') ? Y.parse(expr) : expr;
          var type = Y.findType(expr);
          // for debugging:
          // Y.log(expected + '/' + type);
          assertEqual(expected, type);
        }
        // Note that all the "> 0" conditions below force variables to
        // be individual variables.
        //
        // From two reals to boolean:
        check('((o i) i)', '{x. {y. x > y && y > 0}}');
        // From set to boolean:
        check('(o (o i))', '{x. x = {y. y > 0}}');
        // From set to individual:
        check('(i (o i))',
              // Max of a set having at least one positive number.
              '{p. the {x. p x && x > 0 && forall {y. p y --> x >= y}}}');
        // From set and individual to boolean, note how the
        // first argument type appears last when written out.
        //         y  x
        check('((o i) (o i))', '{x. {y. (x = (= y)) && (y > 0)}}');
        check('((o i) (o i))', '{x. {y. (x = (> y)) && (y > 0)}}');
        // Successful typing of the identity function
        check('o', '({x. x} p) = p');
        // An example where the type check in Rule R catches improper
        // use of types.
        var step1 = Y.parse('p (f g) --> p g').assert();
        // This is pathological in that p and f each appear on just
        // one side of the equation, which means the value of the
        // expressions containing them are not affected by their
        // values.
        var step2 = Y.parse('p g = g f').assert();
        try {
          Y.rules.r(step2, step1, '/right');
          Y.Assert.fail('Rule R should prohibit this step');
        } catch(e) {}
      },


      // PROOFS

      testRuleR: function() {
        var path = Y.path('/right/left');
        var result = Y.rules.r(times2, bigger, path);
        assertEqual('((x > 0) --> ((2 * x) > x))', result);
      },

      testAxiom4: function() {
        var app = call(lambda(x, call(f, x)), y);
        var result = Y.rules.axiom4(app);
        Y.Assert.isInstanceOf(Y.Call, result);
        assertEqual('=', result.fn.fn.name);
        assertEqual('(({x. (f x)} y) = (f y))', result);
      },

      testAxioms: function() {
        assertEqual('(((g T) && (g F)) = (forall {x. (g x)}))',
                    Y.rules.axiom1());
        assertEqual('((x = y) --> ((h x) = (h y)))',
                    Y.rules.axiom2());
        assertEqual('((f = g) = (forall {x. ((f x) = (g x))}))',
                    Y.rules.axiom3());
        assertEqual('((the (y =)) = y)',
                    Y.rules.axiom5());
      },

      testAxiomArithmetic: function() {
        function check(expected, expr) {
          if (typeof expr == 'string') {
            expr = Y.parse(expr);
          }
          var result = Y.rules.axiomArithmetic(expr);
          // Y.log(result);
          assertEqual(expected, result);
        }
        var neg5 = Y.rules.axiomArithmetic(Y.parse('neg 5')).getRight();
        check('((2 + 2) = 4)', '2 + 2');
        check('((5 * 4) = 20)', '5 * 4');
        check('((5 - 4) = 1)', '5 - 4');
        check('((5 / 4) = 1)', '5 / 4');
        check('((neg 5) = -5)', 'neg 5');
        check('((-5 / 4) = -1)', Y.infixCall(neg5, '/', _var('4')));
        check('((4 / -5) = 0)', Y.infixCall(_var('4'), '/', neg5));
        check('((-5 / -5) = 1)', Y.infixCall(neg5, '/', neg5));
        check('((5 > 4) = T)', '5 > 4');
        check('((5 >= 4) = T)', '5 >= 4');
        check('((5 < 4) = F)', '5 < 4');
        check('((5 <= 4) = F)', '5 <= 4');
      },

      testAsHypotheses: function() {
        var step1 = Y.assert('p = p');
        try {
          Y.rules.asHypotheses(step1);
          Y.Assert.fail('Should throw');
        } catch(e) {}
        var step2 = Y.assert('p --> p');
        try {
          Y.rules.asHypotheses(step2);
          Y.Assert.fail('Should throw');
        } catch(e) {}
        var step3 = Y.rules.assume('p');
        var step4 = Y.rules.assert('p --> q');
        var step5 = Y.rules.modusPonens(step3, step4);
        var step6 = Y.rules.asImplication(step5);
        var result = Y.rules.asHypotheses(step6);
        assertEqual('(p --> q)', result);
        Y.assert(result.hasHyps);
      },

      testApplyBoth: function() {
        assertEqual('((f x) = (g x))', Y.rules.applyBoth(call('=', f, g), x));
      },

      testEqSelf: function() {
        var result = Y.rules.eqSelf(call(f, y));
        assertEqual('((f y) = (f y))', result);
        assertEqual('(x = x)', Y.rules.eqSelf(x));
      },

      testR5201a: function() {
        var result = Y.rules.replaceWhole(call(p, x),
                                          call('=', call(p, x), call(q, x)));
        assertEqual('(q x)', result);
      },

      testR5201b: function() {
        var inf = Y.rules.eqnSwap(call('=', p, q));
        assertEqual('(q = p)', inf);
      },

      testR5201c: function() {
        var inf = Y.rules.eqnChain(call('=', p, q), call('=', q, r));
        assertEqual('(p = r)', inf);
      },

      testR5201d: function() {
        var inf = Y.rules.applyBySides(call('=', p, q), call('=', 'a', 'b'));
        assertEqual('((p a) = (q b))', inf);
      },

      testR5201e: function() {
        var inf = Y.rules.applyBoth(call('=', p, q), r);
        assertEqual('((p r) = (q r))', inf);
      },

      testR5201f: function() {
        var inf = Y.rules.applyToBoth(p, call('=', q, r));
        assertEqual('((p q) = (p r))', inf);
      },

      testUseDefinition: function() {
        var inf =
          Y.rules.useDefinition(call('not', equal(p, equal(F, p))), '/fn');
        assertEqual('(F = (p = (F = p)))', inf);
      },

      testInstEqn: function() {
        var c = new Y.Var('c');
        var inf = Y.rules.instEqn(Y.parse('g y = c'),
                                  Y.parse('f x'),
                                  'y');
        assertEqual('((g (f x)) = c)', inf);
      },

      testEqT: function() {
        assertEqual('(T = (b = b))', Y.rules.eqT('b'));
	var step = Y.rules.eqT(call(f, x));
        assertEqual('(T = ((f x) = (f x)))', step);
	var controller = Y.renderInference(step, Y.one(document.body));
        var step2 = Y.rules.instVar(step.details, y, x);
        // Add a step and immediately remove it.  See that at least
        // there are no exceptions.
        controller.addStep(step2);
        controller.removeStep(step2.rendering);
      },

      testR5211: function() {
        assertEqual('((T && T) = T)', Y.rules.r5211());
      },

      testRuleT: function() {
        assertEqual('T', Y.rules.t());
      },

      testR5212: function() {
        assertEqual('(T && T)', Y.rules.r5212());
      },

      testEqnIsTrue: function() {
        var inf = Y.rules.toTIsEquation(call('=', p, q));
        assertEqual('(T = (p = q))', inf);
      },

      testR5213: function() {
        var inf = Y.rules.r5213(call('=', p, q),
                                call('=', q, r));
        assertEqual('((p = q) && (q = r))', inf);
      },

      testChangeVar: function() {
        var expr = equal(lambda(z, z), lambda(y, y));
        var result = Y.rules.changeVar(expr, '/left', x);
        assertEqual('({x. x} = {y. y})', result);
      },

      testBindEqn: function() {
        var inf = Y.rules.bindEqn(call('=', f, g), x);
        assertEqual('({x. f} = {x. g})', inf);
      },

      testInstForall: function() {
        var result = Y.rules.instForall(call('forall', lambda(y, call(p, y))),
                                        call(f, y))
        assertEqual('(p (f y))', result);

        // Hypotheses
        var hyps = Y.rules.assume('p y');
        var step1 = Y.rules.assert('forall {y. p y}');
        var step2 = Y.rules.appendStepHyps(step1, hyps);
        var result = Y.rules.instForall(step2, call(f, y));
        assertEqual('((p y) --> (p (f y)))', result)
        Y.assert(result.hasHyps);
      },

      testAndTBook: function() {
        var inf = Y.rules.andTBook(p);
        assertEqual('((T && p) = p)', inf);
      },

      testAndT: function() {
        var inf = Y.rules.andT(p);
        assertEqual('((T && p) = p)', inf);
      },

      testR5217Book: function() {
        assertEqual('((T = F) = F)', Y.rules.r5217Book());
      },

      testEquationCases: function() {
        var inf = Y.rules.equationCases(equal(T, T), equal(F, F), 'z');
        assertEqual('(z = z)', inf);
      },

      testR5218: function() {
        var inf = Y.rules.r5218(p);
        assertEqual('((T = p) = p)', inf);
      },

      testToTIsA: function() {
        var inf = Y.rules.toTIsA(p);
        assertEqual('(T = p)', inf);
        // Hyps
        var step1 = Y.rules.assume(p);
        var result = Y.rules.toTIsA(step1);
        assertEqual('(p --> (T = p))', result);
      },

      testFromTIsA: function() {
        var inf = Y.rules.fromTIsA(call('=', T, p));
        assertEqual('p', inf);
        // Hyps
        var step1 = Y.rules.assume(p);
        var step2 = Y.rules.toTIsA(step1);
        var result = Y.rules.fromTIsA(step2);
        assertEqual('(p --> p)', result);
      },

      testAddForall: function() {
        var inf = Y.rules.addForall(call(p, y), y);
        assertEqual('(forall {y. (p y)})', inf);

        // Hypotheses
        var step1 = Y.rules.assume(Y.parse('x = 0'));
        var wff = Y.parse('x = 0 --> y > x');
        wff.hasHyps = true;
        wff.getLeft().sourceStep = step1;
        assertEqual('((x = 0) --> (forall {y. (y > x)}))',
                    Y.rules.addForall(wff, 'y'));
      },

      testInstVar: function() {
        var result = Y.rules.instVar(call(p, y), call(f, x), y);
        assertEqual('(p (f x))', result);

        // Hypotheses
        // TODO: Make this really test with hypotheses.
        var step1 = Y.rules.axiom('axiom2');
        result = Y.rules.instVar(step1, call(p, x), x);
      },

      testInstMultiVars: function() {
        var map = {p: Y.parse('forall {x. T || b}'),
                   q: Y.parse('forall {x. b}')
        };
        var result = Y.rules.instMultiVars(implies(p, call('||', T, q)), map);
        assertEqual('((forall {x. (T || b)}) --> (T || (forall {x. b})))',
                    result);

        // Hypotheses
        // TODO: Make this really test with hypotheses.
        var step = Y.rules.axiom('axiom2');
        var map2 = {x: call(p, x),
                    y: call(p, y)};
        var result = Y.rules.instMultiVars(step, map2);
        assertEqual('(((p x) = (p y)) --> ((h (p x)) = (h (p y))))', result);
      },

      testCases: function() {
        var result = Y.rules.cases(equal(call(p, T), T),
                                   equal(call(p, F), F),
                                   x);
        assertEqual('((p x) = x)', result);

        // Hypotheses
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F')
        result = Y.rules.cases(step1, step2, 'x');
        // TODO: In tests with hypotheses, allow order of hypotheses
        //   to vary.
        assertEqual('(((p T) && (p F)) --> (p x))', result);
        Y.assert(result.hasHyps);
      },

      testModusPonens: function() {
        var result = Y.rules.modusPonens(p, implies(p, q));
        assertEqual('q', result);

        // Hypotheses
        var step1 = Y.rules.assume('p --> not p');
        // A tautology, but don't rely on the tautology rule here.
        var step2 = Y.rules.assert('(p --> not p) --> not p');
        result = Y.rules.modusPonens(step1, step2);
        assertEqual('((p --> (not p)) --> (not p))', result);
        Y.assert(result.hasHyps);
      },

      testR5230TF: function() {
        assertEqual('((T = F) = F)', Y.rules.r5230TF());
      },

      testR5230FT_alternate: function() {
        assertEqual('((F = T) = F)', Y.rules.r5230FT_alternate());
      },

      testR5231T: function() {
        assertEqual('((not T) = F)', Y.rules.r5231T());
      },

      testR5231F: function() {
        assertEqual('((not F) = T)', Y.rules.r5231F());
      },

      testFalseEquals: function() {
        assertEqual('((F =) = not)', Y.rules.falseEquals());
      },

      testTrueEquals: function() {
        assertEqual('((T =) = {x. x})', Y.rules.trueEquals());
      },

      testEvalBool: function() {
        var inf = Y.rules.evalBool(call('not', T));
        assertEqual('((not T) = F)', inf);
        inf = Y.rules.evalBool(call('&&', F, T));
        assertEqual('((F && T) = F)', inf);
        inf = Y.rules.evalBool(Y.parse('(p (F || T))'));
        assertEqual('((p (F || T)) = (p T))', inf);
        taut = Y.parse('(p --> not p) --> not p');
        inf = Y.rules.evalBool(taut.subst(T, p, {}));
        assertEqual('T', inf.getRight());
        inf = Y.rules.evalBool(taut.subst(F, p, {}));
        assertEqual('T', inf.getRight());
      },

      testTautology: function() {
        var wff = T;
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);
        var wff = equal(x, x);
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);
        var wff = Y.parse('(p --> not p) --> not p');
        Y.log('Tautology: ' + wff);
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);
        var wff = Y.parse('(p && q --> r) = (p --> (q --> r))');
        Y.log('Tautology: ' + wff);
        var inf = Y.rules.tautology(wff);
        assertEqual(wff.toString(), inf);
      },

      testMakeConjunction: function() {
        var result = Y.rules.makeConjunction(p, q);
        assertEqual('(p && q)', result);

        // With hypotheses:
        var step1 = Y.rules.assume(p);
        var step2 = Y.rules.assume(q);
        result = Y.rules.makeConjunction(step1, step2);
        assertEqual('((p && q) --> (p && q))', result);
      },

      testTautInst: function() {
        var b = call(p, x);
        var map1 = {
          p: Y.parse('forall {x. T || p x}'),
          q: Y.parse('forall {x. p x}')
        };
        var result = Y.rules.tautInst(Y.parse('p --> T || q'), map1);
        var expected =
          '((forall {x. (T || (p x))}) --> (T || (forall {x. (p x)})))';
        assertEqual(expected, result);

        // With hypotheses:
        var h_taut = Y.parse('x > 0 --> (p --> p)');
        h_taut.hasHyps = true;
        var result = Y.rules.tautInst(h_taut, {p: q});
        assertEqual('((x > 0) --> (q --> q))', result);
        Y.assert(result.hasHyps);
      },

      testAnyImpliesTheorem: function() {
        var thm = Y.rules.theorem('t');
        var result = Y.rules.anyImpliesTheorem(Y.parse('x > 0'), thm);
        assertEqual('((x > 0) --> T)', result);
      },

      testR5235: function() {
        var inf = Y.rules.r5235(x, p, call(q, x));
        var wff =
          '((forall {x. (p || (q x))}) --> (p || (forall {x. (q x)})))';
        assertEqual(wff, inf);
      },

      testImplyForallThm: function() {
        var result = Y.rules.implyForallThm(x, p, call(q, x));
        var wff =
          '((forall {x. (p --> (q x))}) --> (p --> (forall {x. (q x)})))';
        assertEqual(wff, result);
      },

      testImplyForall: function() {
        var result = Y.rules.implyForall(x, Y.parse('p --> q x'));
        assertEqual('(p --> (forall {x. (q x)}))', result);

        // With hypotheses:
        var step1 = Y.rules.assert('y > 0 --> (p --> q x)');
	var step2 = Y.rules.assume('y > 0');
	var step3 = Y.rules.modusPonens(step2, step1);
        result = Y.rules.implyForall(x, step3);
        assertEqual('((y > 0) --> (p --> (forall {x. (q x)})))', result);
      },

      testP: function() {
        var inf = Y.rules.p(Y.parse('p x && (p x --> q x)'),
                            Y.parse('a && (a --> b) --> b'));
        assertEqual('(q x)', inf);

        // With hypotheses:
        var step1 = Y.rules.assert('h x --> (p x && (p x --> q x))');
	var step2 = Y.rules.assume('h x');
	var step3 = Y.rules.modusPonens(step2, step1);
        var result = Y.rules.p(step3,
                               Y.parse('a && (a --> b) --> b'));
        assertEqual('((h x) --> (q x))', result);
        Y.assert(result.hasHyps);
      },

      testR5238a: function() {
        var inf = Y.rules.r5238a(y, call(p, y), call(q, y));
        var wff =
          '(({y. (p y)} = {y. (q y)}) = (forall {y. ((p y) = (q y))}))';
        assertEqual(wff, inf);
      },

      testR5238: function() {
        var result = Y.rules.r5238(['x1', 'x2'],
                                   call(p, _var('x1')),
                                   call(p, _var('x2')));
        var wff =
          ('(({x1. {x2. (p x1)}} = {x1. {x2. (p x2)}}) = '
           + '(forall {x1. (forall {x2. ((p x1) = (p x2))})}))');
        assertEqual(wff, result);
      },

      testR5239: function() {
        var inf = Y.rules.r5239(equal(p, q),
                                lambda(p, equal(q, p)),
                                '/body/right');
        var expected =
          '((forall {p. (p = q)}) --> ({p. (q = p)} = {p. (q = q)}))';
        assertEqual(expected, inf);

        inf = Y.rules.r5239(equal(p, q), equal(r, p), '/right');
        assertEqual('((p = q) --> ((r = p) = (r = q)))', inf);

        // Here 'y' is bound in C and free in A = B.
        inf = Y.rules.r5239(Y.parse('(T = (y > x))'),
                            Y.parse('{y. T}'),
                            '/body');
        var expected =
          '((forall {y. (T = (y > x))}) --> ({y. T} = {y. (y > x)}))';
        assertEqual(expected, inf);
      },

      testReplace: function() {
        var result = Y.rules.replace(Y.parse('x > 0 --> (x = (abs x))'),
                                     Y.parse('x > 0 --> ((x + x) > x)'),
                                     '/right/right');
        assertEqual('((x > 0) --> ((x + x) > (abs x)))', result);
      },

      testBubbleLeft: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        function bubble(string) {
          return Y.rules.bubbleLeft(Y.rules.assert(string), less);
        }
        var result = bubble('l = a && b');
        assertEqual('(l = (a && b))', result);
        var result = bubble('l = b && a');
        assertEqual('(l = (a && b))', result);

        result = bubble('l = a && b && c');
        assertEqual('(l = ((a && b) && c))', result);
        result = bubble('l = a && c && b');
        assertEqual('(l = ((a && b) && c))', result);
        result = bubble('l = b && c && a');
        assertEqual('(l = ((a && b) && c))', result);

        result = bubble('l = b && c && d && a');
        assertEqual('(l = (((a && b) && c) && d))', result);
        result = bubble('l = a && c && d && b');
        assertEqual('(l = (((a && b) && c) && d))', result);

        // With simplification.
        var result = bubble('l = a && a');
        assertEqual('(l = a)', result);
        var result = bubble('l = a && b && b');
        assertEqual('(l = (a && b))', result);
        result = bubble('l = a && c && d && a');
        assertEqual('(l = ((a && c) && d))', result);
        result = bubble('l = b && a && d && a');
        assertEqual('(l = ((a && b) && d))', result);
      },

      testMergeRight: function() {
        var result = Y.rules.mergeRight(Y.parse('l = (a && b) && (c && d)'));
        assertEqual('(l = (a && ((c && d) && b)))', result);
        var result = Y.rules.mergeRight(Y.parse('l = a && (b && c && d)'));
        assertEqual('(l = (((b && c) && d) && a))', result);
      },

      testMergeConj: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        function merge(string) {
          return Y.rules.mergeConj(Y.rules.assert(string), less);
        }
        var result = merge('l = (a && b) && (c && d)');
        assertEqual('(l = (((a && b) && c) && d))', result);
        var result = merge('l = a && (c && d)');
        assertEqual('(l = ((a && c) && d))', result);
        var result = merge('l = (a && b && c) && (a && b && c)');
        assertEqual('(l = ((a && b) && c))', result);
        var result = merge('l = (b && b && a) && (a && b && c)');
        assertEqual('(l = ((a && b) && c))', result);
      },


      // END OF RULES AND THEOREMS

      // Looking at what can be done with Andrews' definition of "and".
      // From here you can get counterexamples to the possibilities
      // that ordered pairs other than TT satisfy the definition.
      testFunWithAnd: function() {
        var result = Y.rules.funWithAnd();
      }
    });

  Y.Test.Runner.add(testCase);
  Y.Test.Runner.run();
  Y.Test.Runner.subscribe(Y.Test.Runner.COMPLETE_EVENT, function(event) {
      // Y.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      console.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      document.body.style.backgroundColor = 
        (event.results.failed == 0 && event.results.passed > 0)
        ? '#0C0'
        : '#F00';
    });
});

</script>
</body>
</html>
