<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Builder Tests</title>

  <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui-min.js"></script>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="proofdisplay.js"></script>
  <script src="expr.js"></script>
  <script src="proof.js"></script>
  <script src="q0.js"></script>

<style type="text/css">

   h1 { color: black }
   body { xbackground-color: #EEF }

</style>
  
</head>
<body style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Test Results</h1>

<div id=log class="yui3-skin-sam">
</div>


<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'q0', 'test', 'console', 'proof',
        function(Y) {

  // Initialize the console
  var yconsole = new Y.Console({
      style: 'block',
      height: '600px',
      width: '700px',
      newestOnTop: false                   
    });
  yconsole.render('#log');

  // Make "Y" available globally.
  window.Y = Y;

  function assertEqual(a, b) {
    Y.Assert.areEqual(a, b);
  }

  // Logs the result of each top-level step of an ifnerence.
  function logDetails(inference) {
    var details = inference.details;
    for (var i = 0; i < details.length; i++) {
      var step = details[i];
      Y.log(step.result + ' ' + step.name);
    }
  }

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Example equation: x + x = 2 * x
  var times2 = call('=', call('+', x, x), call('*', '2', x));

  // Example WFF: x > 0 --> x + x > x
  var bigger = call('-->', call('>', x, '0'),
                    call('>', call('+', x, x), x));

  var testCase = new Y.Test.Case({

      name: "Proof Tests",

      setUp: function() {
        tracing = false;
      },

      testTrue: function() {
        Y.Assert.areEqual(true, true);
      },
      test11: function() {
        Y.Assert.areEqual(1, 1);
      },
      testTrue1: function() {
        Y.Assert.areEqual(true, 1);
      },

      testVar: function() {
        assertEqual('x', x.toString());
      },

      testApp: function() {
        var app = call(f, x);
        assertEqual(f, app.fn);
        assertEqual(x, app.arg);
        assertEqual('(f x)', app.toString());
      },

      testLambda: function() {
        var abs = lambda(x, f);
        assertEqual(x, abs.bound);
        assertEqual(f, abs.body);
        assertEqual('{x : f}', abs.toString());

        assertEqual('{x : (f x)}', lambda(x, call(f, x)));
      },

      testFreeNames: function() {
        var wff = lambda(x, call(f, x));
        var map = wff.freeNames();
        var fVar = map['f'];
        Y.Assert.isInstanceOf(Y.Var, fVar);
        assertEqual('f',fVar.name);
        assertEqual(undefined, map['x']);
      },

      testSubFree: function() {
        var v = _var('v');
        var target = call(lambda(v, v), x);
        // Now substitute in 'a different v':
        var result = Y.subFree(_var('v'), x, target);
        // We see that it replaces just the free occurrence, and renames
        // the bound occurrence.
        assertEqual('({v_1 : v_1} v)', result.toString());
      },

      testSame: function() {
        var y = _var('y');
        var e1 = call(lambda(x, call(f, x)), y);
        var x2 = _var('x2');
        var e2 = call(lambda(x2, call(f, x2)), y);
        Y.Assert.isTrue(e1.same(e2));
        var e3 = call(lambda(x2, call(f, x2)), _var('y2'));
        Y.Assert.isFalse(e1.same(e3));
      },

      testNormalize: function() {
        var e1 = call(lambda(x, call(f, x)), _var('y'));
        var result = Y.normalized(e1);
        assertEqual('({$1 : (f $1)} y)', result.toString());
      },

      testIsCall2: function() {
        Y.Assert.isTrue(times2.isCall2('='), 'Times2 not an equation?');
      },

      testReplace: function() {
        var y = _var('y');
        var e1 = call(lambda(x, call(f, x)), y);
	var path = Y.path('/fn/body/arg');
        var result = e1.replace(path, function(expr) { return call(f, x); });
	assertEqual('({x : (f (f x))} y)', result.toString());
      },

      testPath: function() {
        var p = '/a/b';
        var path = Y.path(p);
        assertEqual(p, path.toString());
        assertEqual('a', path.segment);
        assertEqual('b', path.rest('a').segment);
        Y.assert(path.rest('a').rest('b').isMatch());
        assertEqual('(none)', path.rest('b').toString());
        Y.assert(Y.path('/').isMatch());
        assertEqual('f', Y.path('fn').next(call(f, x)).toString());
        assertEqual('x', Y.path('arg').next(call(f, x)).toString());
        var p2 = '/left/binop';
        assertEqual('/fn/arg/fn/fn', Y.path(p2).toString());
      },

      testSearch: function() {
        xPlusX = call('+', x, x)
        var found =
          times2.search(function(expr) { return xPlusX.matches(expr); });
        assertEqual('(x + x)', found.toString());
      },

      testLocate: function() {
        var expr = call('forall', lambda(x, call(p, x)));
        var body = expr.locate(Y.path('/arg/body'));
        assertEqual('(p x)', body.toString());
      },

      testRuleR: function() {
        var path = Y.path('/right/left');
        var withTimes = Y.ruleFns.r(times2, bigger, path);
        assertEqual('((x > 0) --> ((2 * x) > x))', withTimes.toString());
      },

      testAxiom4: function() {
        var y = _var('y');
        var app = call(lambda(x, call(f, x)), y);
        var result = Y.ruleFns.axiom4(app);
        Y.Assert.isInstanceOf(Y.Call, result);
        assertEqual('=', result.fn.fn.name);
        assertEqual('(({x : (f x)} y) = (f y))', result.toString());
      },

      testAxioms: function() {
        var rules = Y.ruleFns;
        assertEqual('(((g T) && (g F)) = (forall {x : (g x)}))',
                    rules.axiom1());
        assertEqual('((x = y) --> ((h x) = (h y)))',
                    rules.axiom2());
        assertEqual('((f = g) = (forall {x : ((f x) = (g x))}))',
                    rules.axiom3());
        assertEqual('((the (= y)) = y)',
                    rules.axiom5());
      },

      testAndTrue: function() {
        assertEqual('((T && p) = p)', rules.defAndTrue());
      },

      testAndFalse: function() {
        assertEqual('((F && p) = F)', rules.defAndFalse());
      },

      testApplyBoth: function() {
        var inf = Y.makeInference('applyBoth',
                                  [call('=', f, g),
                                   x]);
        logDetails(inf);
      },

      testAxiom3a: function() {
        var inf = Y.makeInference('axiom3a',
                                  [lambda(x, T),
                                   lambda(x, x),
                                   call(p, y)]);
        logDetails(inf);

        var rules = Y.ruleFns;
        var fa = rules.defForall();
        
        var step2 = rules.rRight(fa, inf.result, '/left/fn');
        var step3 = rules.rRight(fa, step2, '/right/fn');
        Y.log(step3);
      },

      testEqSelf: function() {
        var result = Y.ruleFns.eqSelf(call(f, y));
        assertEqual('((f y) = (f y))', result);
        assertEqual('(x = x)', Y.ruleFns.eqSelf(x));
      },

      testR5201a: function() {
        assertEqual('(q x)',
                    Y.ruleFns.replaceWhole
                    (call(p, x), call('=', call(p, x), call(q, x))));
      },

      testR5201b: function() {
        var result = Y.ruleFns.eqnSwap(call('=', p, q));
        assertEqual('(q = p)', result.toString());
      },

      testR5201c: function() {
        var result = Y.ruleFns.eqnChain(call('=', p, q), call('=', q, r));
        assertEqual('(p = r)', result.toString());
      },

      testR5201d: function() {
        var result =
          Y.ruleFns.applyBySides(call('=', p, q), call('=', 'a', 'b'));
        assertEqual('((p a) = (q b))', result.toString());
      },

      testR5201e: function() {
        var result = Y.ruleFns.applyBoth(call('=', p, q), r);
        assertEqual('((p r) = (q r))', result.toString());
      },

      testR5201f: function() {
        var result = Y.ruleFns.applyToBoth(p, call('=', q, r));
        assertEqual('((p q) = (p r))', result);
      },

      testR5209: function() {
        var b = new Y.Var('b');
        var c = new Y.Var('c');
        var result = Y.ruleFns.r5209(call('=', call(g, y), c), call(f, x), y);
        assertEqual('((g (f x)) = c)', result.toString());
      },

      testEqT: function() {
        var b = new Y.Var('b');
        var result = Y.ruleFns.eqT(b);
        assertEqual('(T = (b = b))', result);
        assertEqual('(T = ((f x) = (f x)))', Y.ruleFns.eqT(call(f, x)));
      },

      testR5211: function() {
        var inf = Y.makeInference('r5211', []);
        assertEqual('((T && T) = T)', inf.result);
      },

      testRuleT: function() {
        assertEqual(T, Y.ruleFns.t());
      },

      testR5212: function() {
        var inf = Y.makeInference('r5212', []);
        assertEqual('(T && T)', inf.result);
      },

      testR5213: function() {
        var inf = Y.makeInference('r5213',
                                  [call('=', p, q),
                                   call('=', q, r)]);
        assertEqual('((p = q) && (q = r))', inf.result);
      },

      testDefAnd: function() {
        var inf = Y.makeInference('defAnd', []);
        assertEqual('(&& = {x : {y : ({g : (g T T)} = {g : (g x y)})}})',
                    inf.result);
      },

      testBindEqn: function() {
        var inf = Y.makeInference('bindEqn', [call('=', f, g), x]);
        assertEqual('({x : f} = {x : g})', inf.result);
      },

      testR5214: function() {
        var inf = Y.makeInference('r5214', []);
        assertEqual('((T && F) = F)', inf.result);
      },

      testForallInst: function() {
        var inf = Y.makeInference('forallInst',
                                  [call('forall', lambda(y, call(p, y))),
                                   call(f, y)])
        assertEqual('(p (f y))', inf.result);
      },

      testAndT: function() {
        var inf = Y.makeInference('andT', [p]);
        assertEqual('((T && p) = p)', inf.result);
      },

      testMakeInference: function() {
        var inf = Y.makeInference('eqT', [x]);
        Y.log(inf.toString());
        assertEqual('eqT', inf.name);
        assertEqual(1, inf.inputs.length);
        assertEqual('x', inf.inputs[0].name);
      }
  });

  var tracing = false;
  var rules = {};
  for (var key in Y.ruleFns) {
    (function(k) {
      rules[k] = function() {
        var result = Y.ruleFns[k].apply(null, arguments);
        if (tracing) {
          Y.log(result);
        }
        return result;
      }
    })(key);
  };


  Y.Test.Runner.add(testCase);
  Y.Test.Runner.run();
  Y.Test.Runner.subscribe(Y.Test.Runner.COMPLETE_EVENT, function(event) {
      // Y.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      console.log(Y.Test.Runner.getResults(Y.Test.Format.TAP));
      document.body.style.backgroundColor = 
        (event.results.failed == 0 && event.results.passed > 0)
        ? '#0D0'
        : '#F00';
    });
});

</script>
</body>
</html>
