// Copyright Crispin Perdue.  All rights reserved.
//
// Here be core facilities such as declaring rules, theorems, facts,
// and definitons, matching and fact management that can be separated
// from actual deduction.

'use strict';

// Set all of this up immediately upon load, but avoiding changes
// to the global environment (except through the "Toy" namespace).
(function() {

//// THEOREMS AND RULES

var assert = Toy.assertTrue;
const abort = Toy.abort;

//  Make some useful names available here.
var assertEqn = Toy.assertEqn;
var varify = Toy.varify;
var constify = Toy.constify;
var termify = Toy.termify;
var mathParse = Toy.mathParse;
var call = Toy.call;
var equal = Toy.equal;
var implies = Toy.implies;
var lambda = Toy.lambda;

var Expr = Toy.Expr;
var Atom = Toy.Atom;
var Call = Toy.Call;
var Lambda = Toy.Lambda;

var memo = Toy.memo;

// Predefine some common constants.
var T = constify('T');
var F = constify('F');

// Map from tautology string representation to tautology,
// for proved tautologies.  Private to the tautology rule.
var _tautologies = new Map();


//
// Expr methods for inference
//

/**
 * Returns a shallow copy of this, annotating the copy with the rule
 * name, rule arguments, and dependencies (ruleName,
 * ruleArgs, ruleDeps).  "This" becomes the "details" property if it
 * already has a justification.  (Axioms, definitions and assertions
 * are not generated by rules, though theorems are.)  The ruleDeps
 * array is optional, empty if not given.
 *
 * If this is identical to one of its ruleDeps, returns this unchanged
 * unless "retain" is true, making the step a no-op.  (The purpose is
 * to reduce clutter for readers of the proof.)
 *
 * TODO: Make a Step class for proof steps, and have this method
 * return a new one.
 *
 * TODO: Consider always recording the step, but skipping the display
 * in proof.jsc.  Some steps, especially simplifications, do this
 * same thing internally by skipping the call to "justify".
 *
 * TODO: Add a "justify0" method that never modifies assumptions,
 * or alternatively, never "arrange" them here, leaving that task
 * to rules such as "replace".
 */
Expr.prototype.justify = function(ruleName, ruleArgs, ruleDeps, retain) {
  // Note: when splitting Step and Expr, make a version of this just
  // for rules.assert, and use that in any primitive inference rules.
  var ruleDeps = Array.from(ruleDeps || []);
  if (!retain) {
    for (var i = 0; i < ruleDeps.length; i++) {
      const dep = ruleDeps[i];
      if (dep.sameAs(this)) {
        // If the step returns an input step, return it as-is,
        // obliterating the putative new step.  The resulting proof
        // object may occasionally surprise the author of a proof.
        return dep;
      }
    }
  }
  var step = this;
  // At this spot we could conditionally run arrangeAsms in case the
  // step being justified is conditional.  Omitting that automagic
  // behavior for now.
  //
  // TODO: Consider modifying arrangeAsms to flag its result as
  //   "arrangedAsms", and to check on entry if a step's asms are
  //   flagged.  If so it would immediately return its input
  //   unmodified.  Presumably arrangeAsms is a pure
  //   rewriter/simplifier and thus does not introduce conditional
  //   steps, so calling it here would not result in recursive calls
  //   to it.

  // Allocate a new object to be the new Step.
  const result = (step instanceof Call
                  ? new Call(step.fn, step.arg)
                  : step instanceof Atom
                  ? new Atom(step.pname)
                  // Impossible for a step!
                  : abort('Internal'));
  result._typeFrom(step);

  // The beginnings of a Step class.  Only steps will have the
  // following properties, with .wff accessing the top expression
  // (wff).
  //
  // Note: Likely additional Step methods: freeVars. 
  result.wff = result;
  // TODO: The "rendering" (and also "original") property is quite
  //   sparse.  Consider eliminating "original" for non-rendered steps
  //   and storing "rendering" in a WeakMap.
  result.rendering = null;
  // Record the step as details.
  // Note that above, primitive rules have no deps.
  if (Toy.isProved(this)) {
    // Except for primitive rules listed just below.
    result.details = step;
  } else {
    switch(ruleName) {
    case 'axiom4':
    case 'assert':
    // TODO: "define" should not have to be a special case here.
    case 'define':
    case 'definition':
    case 'r':
      break;
    default:
      assert(false, 'Input to "justify" should be a step ({1})', step);
    }
  }
  // Give the new step the specified ruleName.
  result.ruleName = ruleName;
  // Make the step be its own original, for uniform access to an original.
  // TODO: Stop doing this, to distinguish StepDisplay objects from Steps.
  result.original = result;
  // Give this step its own new ordinal.
  result.ordinal = stepCounter++;
  // Carry other information forward.
  result.ruleArgs = Array.from(ruleArgs);
  result.ruleDeps = ruleDeps;
  return result;
};

//
// Utility functions
//

/**
 * Processes an object/set or string as a set of labels.  If it is a
 * string, converts it to an object/set by treating it as a
 * space-separated list of words.  If the object/set is empty
 * returns one containing just "none", for convenience.
 */
function processLabels(labels) {
  switch(typeof labels) {
  case 'string':
    var result = {};
    const array = labels.split(/\s+/);
    if (array.length) {
      array.forEach(function(label) { result[label] = true; });
      return result;
    } else {
      return {none: true};
    }
  case 'object':
    return labels;
  default:
    assert(!labels, 'Bad labels: {1}', labels);
    return {none: true};
  }
}

// Computes the fact's set of menu categories based on its metadata
// and goal, and stores them as info.categories.  The categories are
// like menus, but can be more fine-grained, each menu displaying a
// characteristic set of categories.
function computeMenuCategories(info, isConverse) {
  const goal = info.goal;
  const categories = new Set;

  for (let label in info.labels) {
    const category = categoryOfLabel[label];
    assert(category, 'No category for label {1}', label);
    if (category !== 'default') {
      categories.add(category);
    }
  }

  if (categories.size === 0) {
    // If there is no explicit category, look for implicit ones
    // based on the statement of the rule and metadata other than
    // labels.  (Currently there is at most one.)
    const category =
          (info.desimplifier ? 'desimplifier'
           : info.simplifier ? 'simplifier'
           : (goal.matchSchema('a = the b') ||
              goal.matchSchema('a = the1 b')) ? 'advanced'
           : hasSubgoal(goal) ? 'backward'
           // If it adds no subgoal, but has a type ("real")
           // assumption, show only if it has a label.
           : hasTypeAsm(goal) ? 'realType'
           : info.goal.matchPart().isVariable() ? 'varMatch'
           : 'other'
          );
    if (category) {
      categories.add(category);
    }
  }

  info.categories = categories;
}

// Private to computeMenuCategories.
const categoryOfLabel = {
  // The "none" label is assigned automatically when no labels
  // are given.
  none: 'default',
  // The "none" category means "do not offer this fact".
  primitive: 'none',
  // The remaining labels occur in one or more facts today.
  display: 'edit',
  uncommon: 'other',
  advanced: 'other',
  algebra: 'algebra',
  // The algebra2 name suggests "algebra, but not usually a good idea".
  algebra2: 'other',
  general: 'general',
  basic: 'general',
  higherOrder: 'default',
  // The "backward" label is for facts useful for backward reasoning,
  // though it usually can be inferred from the assumptions of the fact.
  backward: 'backward',
  forward: 'forward',
};

/**
 * Tests whether the given goal (wff) has a subgoal within its
 * assumptions, currently defined as anything other than a real number
 * assumption or an inequality condition.
 */
function hasSubgoal(goal) {
  const asms = goal.getAsms();
  return asms && asms.scanConj(x => x.likeSubgoal());
}

/**
 * Tests whether the given goal (wff) has a type (real number)
 * assumption.
 */
function hasTypeAsm(goal) {
  const asms = goal.getAsms();
  return asms && asms.scanConj(t => {
      return !!t.matchSchema('R x');
    });
}

// Used to order execution of proof steps so they can display
// in order of execution in an automatically-generated proof.
// This increments on every call to "justify".
// Conceptually it could be incremented just by rule R.
var stepCounter = 1;

function getStepCounter() {
  return stepCounter;
}

/**
 * A simplification function that does nothing, useful as the
 * auto-simplifier for rules that want to suppress simplification.
 */
function noSimplify(step) {
  return step;
}

/**
 * Adjusts a path to account for application of a typical rewrite rule
 * that could prefix the path with /right, given a step that is the
 * input to the rewrite and a step that is the result of the rewrite.
 * Apply the adjustment to get the corresponding part of the output
 * given a path into the input step.
 *
 * Caution, currently unused.
 */
Toy.Path.prototype.adjustForRewrite = function(input, output) {
  return (!input.isCall2('=>') && output.isCall2('=>')
          ? Toy.asPath('/right').concat(this)
          : this);
};

/**
 * These become methods on steps, set up by Step.justify.
 */
var ruleMethods = {

  /**
   * Applies the named rule to this Expr and any other given arguments
   * as if by a call to Toy.rules[name](args).
   */
  andThen: function(name, arg1) {
    var nm = name;
    arguments[0] = this;
    var rule = rules[nm];
    assert(rule, 'No rule with name "{1}"', nm);
    var result = rule.apply(rules, arguments);
    return result;
  },
      
  /**
   * Swaps the sides of an equational fact.  Mainly useful when the
   * fact is named.
   */
  swap: function swap_method() {
    return rules.eqnSwap(this);
  },

  /**
   * Applies rules.rewrite to this Expr passing in a path and
   * fact to use.
   */
  rewrite: function rewrite_method(path, fact) {
    return rules.rewrite(this, path, fact);
  }
};
Toy.addMethods(Expr, ruleMethods);


//
// Inference rules, axioms, theorems
//

// Map from rule name to function used in all proofs.
// This is a central global variable.
var rules = {};

//// RULE PROPERTIES

// The following rule properties are available directly when calling
// addRule.
//
// Properties:
//
// action: function implementing the inference rule.
//
// proof: for a theorem (no args), use this instead of "action".  Do
//   not call "justify", that is done automatically and the proof is
//   memoized.  For a theorem, this may be given as an array of steps
//   encoded as text in the usual manner.
//
// name: name of the rule, axiom or theorem; required if it is a rule
//   of inference with one or more arguments (see below).  Used to
//   look up the rule in "rules".
//
// statement: for a theorem, this string optionally states the theorem
//   proved.  In this case the theorem is also added as a fact.  If
//   the value is an equation, with or without assumptions, if its
//   converse is not already added when the theorem is added, its
//   converse will be added as a fact.  Also used by tests.  TODO:
//   Consider checking during actual proof of the theorem.
//
// goal: synonym for statement.
//
// definition: for a definition, this is a statement, often of the
//   form <name> = <term>, that defines the new constant name.  Once
//   the definition is made, this statement is taken as true, as if it
//   were a new axiom, but without danger of creating a contradiction.
//   Other forms can also be used as definitions if justifying facts
//   are proved.  See the function "definition" for more details.
//   
// precheck: if present, a function that must accept the same
//   arguments as the main action.  When the rule action is called, it
//   will call this automatically, followed immediately by the
//   declared action function.  The RuleMenu uses it as well, to rule
//   out inapplicable rules.
//
//   This is expected to return a falsy value if the rule is not
//   applicable to the arguments, in which case the rule will fail
//   with Toy.abort.  Otherwise it should return any data useful to the
//   main action function, which will have access to that result
//   through the global temporary Toy._actionInfo.
//
//   To call the precheck directly, refer to rules.<rulename>.precheck.
//   A call to rules.<rulename>.main will automatically receive the
//   result of the most recent precheck.
//
//   TODO: Consider supporting generator functions for a similar
//   purpose.  The first result is the result of the precheck, the
//   second and final result is the result of using the full rule.
//
// main: If the rule has a precheck, this will have the main action as
//   its value, and client code may call it after the precheck and
//   before invoking any other rule.
//
// onFail: if a rule's action function is called in the ordinary
//   manner, and it has precheck, and the precheck fails, then its
//   onFail action will run with access to the rule object as "this".
//   If no onFail action is given, a rule with a precheck will
//   return a strict error on failure of the precheck.
//
// inputs: map from type to argument number(s), either a single number
//   or an array if more than one such argument.  These currently
//   determine whether a step accepts a selected step or site, also
//   parsing of items in forms.  Most rules accept arguments in string
//   form and convert them as needed internally.
//
//   The supported types are:
//     step: Matches any proof step.
//     equation: Matches a proof step that is an equation.
//     implication: Matches a proof step that is a conditional
//     term: Matches any term.
//     reducible: Matches a call to anonymous function (lambda)
//     varName: Name suitable for a variable.
//     string: Arbitrary nonempty string.
//     optString: Optionally empty arbitrary string.
//     site: Term in a step; the rule expects the term's step and path
//       to the term as inputs.
//     bindingSite: Matches a variable binding in a step (as in "renameBound").
//
// TODO: Consider defining a new form of input descriptor.  Every rule
//   with the new property would be a "fancy" rule whose action
//   function has the appropriate name, that automatically converts
//   its inputs based on its input descriptor.  For each of these
//   define a rule 'fast_' + name to be the simplest form.
//
// data: TODO: obsolete, remove this.
//   If a rule has a "data" property, set rules[ruleName] to a
//   wrapper function that runs the user-written action function with
//   "this" bound to the wrapper and the "data" object as the "data"
//   property of "this".  If the value of the info data property is a
//   function, this.data will the result of applying it to no
//   arguments once during rule setup.
//
// minArgs: Number of required args for the action.  Supply a
//   value here to make trailing arguments optional in the step editor.
//
// maxArgs: Optional maximum number of args to pass to the rule.
//   Unless already present, added automatically by addRule when
//   making a rule, based on the number of declared function
//   arguments.
//
// toOffer: function of displayable step and optional term within the
//   step, or a string containing expression to return from such a
//   function, with arguments "step", and "term".  The step and term
//   in this case belong to the rendering of the step, and have type
//   annotations.  These are assigned the selected step and term, or
//   null if not selected, and if the function returns a falsy value,
//   the step editor will not offer it.
//
// form: HTML template for the rule's input form to be presented by
//   the step editor, as a template allowing {term} for the selected
//   term.  StepEditor will never offer a rule without a form
//   property, at least an empty one.
//   TODO: Separate out this kind of non-offerability.
//
// menu: plain text for the rule's menu item (may become HTML in the future),
//   as a template allowing {term} for the selected term or {right}
//   for a possible term to its right ("group with").
//
// menuGen: function to return zero or more menu entries for
//   application(s) of the rule.  It will be passed the ruleName,
//   step, selected term or null if none, and the ProofEditor for which
//   it is generating the menu.  A falsy value indicates no
//   menu entries; a non-empty string is for one entry.
//
// tooltip: plain text to become the title attribute of mentions of the
//   rule name in proof displays and the description in subproof displays.
//
// result: For theorems with no parameters only; this is the statement
//   of the theorem.  If given as text in ruleInfo, converted into an
//   expression in "rules".
//
// description: HTML word or phrase for use in one-line description,
//   or function to compute it, as in rules.fact.  If beginning with
//   "=", name of a "step formatter" in stepFormatters follows.
//   Either sort of function receives the step as argument.
//
// labels: space-separated list of words to categorize the rule,
//   influencing the rules modes in which it will be offered.  If none
//   are given, effectively a single label "none".  See processLabels
//   for more details.
//
// isRewriter: true to highlight on hover like a rewrite rule.
//   TODO: Consider removing this as unnecessary.
//
// using: if present, normally the equation or implication used for
//   the rule, as for rewriters.  The equation may have conditions.
//   When working forward the left side of the main equation must
//   match the site to be operated on.
//
// inputSide: may be 'right' to indicate that the rule uses
//   the converse equality (rewrites matching the right side of the
//   equation rather than the left side).
//
// noSuggest: pseudo-rules may have side effects and return true on
//   success rather than a new step.  Such should have this property
//   with value true, and the rule itself should return true.  This
//   property prevents the rule from running to produce a suggestion.
//
// internal: write-only property, set to true for rules that have
//   no inputs property given.

// Rule definitions that have statements (and are thus theorems)
// support the same properties as facts, specifically: simplifier,
// desimplifier, noSwap, labels, and converse (for properties of facts
// that have a swapped version).  For more information see addFact.

/**
 * Process the given info into form for inclusion into Toy.rules and
 * add the resulting rule or rules.  This does not do inference, so it
 * can be called before any theorems are proved.
 */
function addRule(info) {
  var name = info.name;
  if (name && rules[name]) {
    console.warn('Inference rule with name', name,
                 'already declared; ignoring.');
    return;
  }

  if (info.definition) {
    definition(info.definition);
    return;
  }
  var proof = info.proof;
  var statement = info.statement || info.goal;
  if (info.statement && info.goal) {
    console.warn('Fact has both statement and goal', info.goal.toString());
  }

  // This will become the "rule object":
  var rule;
  // This will become the "main function" -- the action or proof property
  // with user-written code.
  var main;
  // True iff the main function has access to the rule object as "this".
  var mainHasThis = false;
  // If the rule (theorem) has an explicit statement (which should be
  // provably true), coerce the statement to an Expr if given as a
  // string.
  if (typeof statement === 'string') {
    statement = info.statement = Toy.mathParse(statement);
  }
  if (proof) {
    // The proof should have no arguments, and should not do its
    // own call to "justify".
    //
    // TODO: In the future, allow type parameters and memoize
    //   as appropriate.
    // TODO: Consider checking that "actions" _do_ have parameters.
    if (typeof proof === 'function') {
      assert(proof.length == 0, 'Proof of {1} requires parameters', name);
      assert(!info.action, 'Both proof and action for {1}', name);
      // User-supplied proof function is the main.
      main = proof;
    } else if (Array.isArray(proof)) {
      const steps = proof;
      proof = function() { return Toy.decodeProof(steps); }
      main = proof;
    } else {
      assert(false,
             'Proof of {1} should be a function or array of steps', name);
    }
  }
  if (statement) {
    if (!proof) {
      // If there is a statement but no proof, just assert the statement.
      proof = function() {
        return rules.assert(statement);
      }
      main = proof;
      if (!info.axiom) {
        console.warn('No proof for', name || statement.toUnicode());
      }
    }
    // Add it as a fact also, and potentially "swapped".
    // A fact needs a statement, so we rely here on having a statement given.
    //
    // TODO: Use factProperties and remove this.
    var factXferProps = {
      axiom: true,
      description: true,
      simplifier: true,
      desimplifier: true,
      noSwap: true,
      labels: true,
      converse: true
    };
    // Accept selected fact properties in the rule metadata.
    var properties = {goal: statement, proof: proof};
    for (var k in factXferProps) {
      if (k in info) {
        // Uncomment this for detailed tracing.
        // console.warn('Adding', k, 'to', name);
        properties[k] = info[k];
      }
    }
    addFact(properties);
    if (!properties.noSwap) {
      addSwappedFact(properties);
    }
    // There is a proof but no name, so we are done.
    if (!name) {
      return;
    }
  }
  if (proof) {
    // There is a proof _and_ a name.
    // 
    // TODO: Merge the proof code here with the similar code
    //   in factProverWrapper.
    rule = function() { 
      if (rule.result === undefined) {
        const info = resolveToFactInfo(statement);
        // Just execute the proof on first use, but re-justify on each
        // use so the result will have its own ordinal.
        try {
          info.inProgress = true;
          rule.result = proof();
        } finally {
          info.inProgress = false;
        }
      }
      if (rule.result instanceof Error) {
        // Abort if there is no statement!
        assert(statement, 'Failed to prove {1}');
        console.error(Toy.format('Failed to prove {1}, asserting instead'));
        // Assert it on every use.
        return rules.assert(statement);
      }
      // TODO: Handle mismatches here as in asFactProver.
      if (statement && !rule.result.matches(statement)) {
        console.error(Toy.format(
          'Failed to prove {1},\n  instead proved {2},\n  asserting instead',
          statement, rule.result));
        debugger;
        // Assert it on every use.
        return rules.assert(statement);
      }
      return rule.result.justify(name, []);
    };
    // Describe theorems as "theorem" by default.
    // The theorem name will be added as ruleName into the tooltip.
    if (!('description' in info)) {
      info.description = 'theorem ' + name
    }
  } else {
    // It is a rule of inference, not an axiom, theorem, or fact.
    assert(name, 'Inference rule must have a name', info);
    // The action property is the user code to run it.
    main = info.action;
    assert(typeof main === 'function',
           'Rule action must be a function: {1}', name);

    if (info.precheck) {
      // There is a precheck.
      var checker = function(_args) {
        return Toy._actionInfo = info.precheck.apply(main, arguments);
      }
      // TODO: Consider communicating through the "this" argument
      //   to the main rule instead of the global variable, e.g.
      //   this.precheck.
      rule = function(_args) {
        checker.apply(null, arguments);
        const checks = Toy._actionInfo;
        return (checks && !(checks instanceof Error)
                ? main.apply(rule, arguments)
                : checks instanceof Error
                ? checks
                : info.onFail
                ? info.onFail.call(rule)
                : Toy.newError('Rule {1} not applicable', name));
      }
      if (info.maxArgs == null) {
        info.maxArgs = main.length;
      }
      // Set properties on the outer action to give access to the
      // main from the the precheck.
      rule.precheck = checker;
      rule.main = main;
      // Assert that the main code has access to data and metadata
      // through "this".
      mainHasThis = true;
    }
  }

  // The following code applies to all rules, axioms, theorems and
  // inference rules.

  if (info.data) {
    // Set the "data" property of the outer action so the main
    // and precheck can access it.  If it is a function, call it
    // and use the result.
    if (typeof info.data === 'function') {
      info.data = info.data.call();
    }
    if (!mainHasThis) {
      // Make the outer action function available to the main
      // function as "this".
      rule = function(_args) {
        return main.apply(rule, arguments);
      };
      mainHasThis = true;
    }
    // Also make the data a property of "this".
    rule.data = info.data;
  }
  // Even if there is no wrapping, set up "rule".
  rule || (rule = main);

  // Set up remaining metatadata.

  // Give every info "inputs".
  if (!info.inputs) {
    info.internal = true;
    info.inputs = {};
  }

  // Default the description to the marked up formula or the ruleName.
  if (!('description' in info)) {
    // The name could be undefined.
    info.description = name;
  }
  // Remember the basic tooltip
  info.basicTooltip = info.tooltip;

  // If there is a toOffer property with string value, coerce it
  // to a function of step and path.
  if (typeof info.toOffer === 'string') {
    info.toOffer = new Function('step, term', info.toOffer);
  }
  // Make the action function available here also as "this".
  if (typeof info.toOffer === 'function') {
    info.toOffer = info.toOffer.bind(rule);
  }

  info.labels = processLabels(info.labels);

  // Add all metadata as the function's "info" property.
  rule.info = info;
  
  if (name) {
    // Include the rule name in the tooltip.
    info.tooltip = Toy.format('{1} ({2})', (info.tooltip || ''), name);

    // Assign a name to the wrapper and main.
    if (rule !== main) {
      Object.defineProperty(rule, 'name',
                            {value: name + '_wrapper'});
      Object.defineProperty(main, 'name', {value: name});
    } else {
      Object.defineProperty(rule, 'name', {value: name});
    }

    // Finally install the rule into the rules.
    rules[name] = rule;
  }
}

/**
 * Takes an arbitrary number of arguments, each in the form
 * accepted by addRule, and performs addRule on each.
 *
 * Prefer this over addRule, addRules, addFact, or addFactsMap for
 * adding new facts, rules, and definitions.
 */
function declare(_declarations) {
  for (const decl of arguments) {
    addRule(decl);
  }
}


// Essentially unique

// This concept applies to a carrier set and one or more functions of
// one or more arguments from that set, a.k.a. a "structure".
//
// The objects satisfying some property, or wlog some conjunction of
// properties, are essentially unique iff all such structures
// associated with those properties are isomorphic to each other.
//
// A structure is associated with a conjunction of properties iff the
// properties are true of its carrier set, functions, and predicates.


/**
 * Adds the given definition as a new fact provided it meets the
 * requirements for definitions.  It must define a named constant that
 * is neither already defined nor otherwise known as a constant.  The
 * argument is a wff to be asserted as true.  The new constant name
 * must be the one and only free new name.  If the wff is in string
 * form, this parses with termify.
 *
 * If it is of the form:
 *
 * <name> = <term>
 *
 * where <name> is a (new) constant name and <name> does not occur
 * free in <term>, this accepts the equational definition.  It also
 * adds related facts using addDefnFacts if the definition is a
 * function or predicate defined equal to a lambda.
 *
 * If it is of the form:
 *
 * <name> <var> . . . = <term>
 *
 * where the <var>'s are variable names, this converts the equation to
 * the equivalent first form and processes the result accordingly.
 * (This is the idiomatic traditional form of function and predicate
 * definitions.)
 *
 * If the definition has some other form, then there must be a
 * recorded fact of the form: exists {<var>. <condition2>}, where
 * <var> is a variable name that does not occur free in the condition,
 * and condition2 is the result of substituting <var> for <name> in
 * the condition.  Of course the recorded fact could use exists1 in
 * place of exists.
 *
 * TODO: If there is an "exists1" fact, this should automatically
 * generate a fact, with proof, that anything having the property is
 * equal to the new constant.
 *
 * TODO: Just existence does not seem to be enough to make such a
 * "constant" worth defining, so scratch that.
 *
 * TODO: Support pseudo-constants based on structures, where a
 * structure is a carrier set and a set of functions from the set to
 * itself, of one or more arguments.  If the structure is "essentially
 * unique", meaning all such structures are isomorphic, define a
 * new constant.
 *
 * TODO: Perhaps appropriate top-level forms might be: "fact", "rule",
 * and "definition".  Each would just add its item to a global list,
 * perhaps even the same global list.  Additionally, the top-level
 * form might do some bookkeeping and report errors, at least for
 * definitions.  These can run at top-level in modules where the logic
 * is available.
 *
 * TODO: Considering allowing a "properties" argument for properties
 * for generated facts, or provide a way to declare fact properties
 * separately from proof of the fact.
 *
 * Returns the newly-defined name.
 */
function definition(defn_arg) {
  const definitions = Toy.definitions;
  const candidate = termify(defn_arg).typedCopy();
  // Free occurrences of names of constants that do not have
  // definitions.  We check this before adding any facts that
  // may reference the defined name.
  const news = candidate.newConstants();
  // This has the values in the set, in insertion order.
  const newList = Array.from(news);
  assert(newList.length > 0,
         'Definition {1} needs a fresh constant name.', defn_arg);
  assert(newList.length === 1,
         'Definition {1} has multiple new constants {2}',
         defn_arg, newList.join(', '));
  // Register the single new name as a constant.
  Toy.addConstants(newList);
  // Register the type of the new constant.
  candidate.registerConstants();
  // Notice that all of this constant registration is done before the
  // definition is potentially asserted as true in normalizeDefn.
  const name = newList[0];

  // Normalizing does some deduction, so defer it until logic
  // is loaded.
  const addFacts = () => {
    const defined = new Atom(name);
    // The defn is the definition in standard form: <constant> = <term>.
    const defn = normalizeDefn(candidate);
    if (defn.isCall2('=') && defn.getLeft().isNamedConst()) {
      // Allow benign redefinition same as an existing one.
      const name = defn.getLeft().name;
      const prev = definitions[name];
      if (prev instanceof Expr && prev.matches(defn)) {
        // If it does not match, later checks will flunk it.
        console.log('Benign redefinition of', name);
        return name;
      }
    }
    if (defn.isCall2('=') &&
        defn.getLeft().matches(defined) &&
        Toy.isEmpty(defn.getRight().newConstants())) {
      // It is a classic equational definition.
      // Add it to the facts andthe definitions database.
      addFact({goal: defn, definition: true,
               desimplifier: !(defn.getRight() instanceof Atom)});
      definitions[name] = defn;
      addDefnFacts(defn);
    } else {
      // It is not a classic equational definition.
      var x = Toy.genVar('x', defn.allNames());
      // Substitute the fresh variable for the constant name.
      var body = defn.subFree1(x, name);
      var exists1 = Toy.call('exists1', Toy.lambda(x, body));
      if (isRecordedFact(exists1)) {
        // TODO: Add the fact that only one value has the property.
        console.warn('Not using exists1 fact for {1}.', defn);
      } else {
        var exists = Toy.call('exists', Toy.lambda(x, body));
        assert(isRecordedFact(exists),
               'Definition {1} needs an existence fact.', defn);
      }
      // Assert that the definition is true, and add to the definitions.
      addFact({goal: defn, definition: true});
      definitions[name] = defn;
    }
  };
  if (deferringDefnFacts) {
    deferredDefnFacts.push(addFacts);
  } else {
    addFacts();
  }
  return name;
}

/**
 * Converts an equational wff in the traditional idiomatic form for
 * function and predicate definitions into the basic form accepted
 * above.  Private to "definition" above.
 *
 * If the input is an equation, asserts it and (attempts to) return a
 * proved statement based on that assertion.  If not in that form,
 * just returns its argument.
 *
 * Happily this makes good use of equations with "==", as for "in" /
 * "element of", defining a boolean-valued function (predicate).
 */
function normalizeDefn(defn_arg) {
  const normed = defn => {
    let left = defn.getLeft();
    if (left instanceof Call) {
      const arg = left.arg;
      if (arg.isVariable()) {
        const bound = rules.bindEqn(defn, arg);
        const reduced = rules.rewriteOnly(bound, '/left', 'eta');
        // The reduced has an extra layer of lambda on the right
        // and one less variable on the left.
        return normed(reduced);
      }
    }
    return defn;
  };
  const converted = defn_arg.isCall2('=') &&
    normed(rules.assert(defn_arg));
  return converted || defn_arg;
}

// Set to false when defn facts can be proved immediately.
let deferringDefnFacts = true;

// Functions to compute defnFacts when the needed support is ready.
const deferredDefnFacts = [];

/**
 * Call this to prove deferred facts and cease deferrals.
 */
function enableDefnFacts() {
  deferringDefnFacts = false;
  deferredDefnFacts.forEach(function(f) { f(); });
  deferredDefnFacts.length = 0;
}

/**
 * This function only has effect for equational definitions
 * of the form <atom> = <term>, in Expr form.
 *
 * If it is a function definition (the term is a lambda), it generates
 * a basic equational fact for application of the function or
 * predicate to arguments.  In other words if f = {x. <term>},
 * generates the fact f x = <term>, and similarly if there are
 * multiple arguments.
 *
 * This is intended mainly for use from Toy.definition.
 */
function addDefnFacts(definition) {
  if (definition.isCall2('=') && definition.getLeft().isNamedConst()) {
    // Add the converse as a simplifier.
    const eqn0 = rules.fact(definition);
    let eqn = eqn0;
    let lambda = eqn.getRight();
    addSwappedFact({goal: definition,
                    desimplifier: !(lambda instanceof Atom),
                    definitional: true});
    while (lambda instanceof Lambda) {
      eqn = (rules.applyBoth(eqn, lambda.bound)
             .andThen('reduce', '/right'));
      lambda = eqn.getRight();
    }
    // TODO: Consider adding a fact unconditionally, and treating
    //   it automatically as a desimplifier.
    if (eqn != eqn0) {
      // Flag the fact as being essentially the same as the definition
      // of the function or predicate.
      addFact({goal: eqn, definitional: true});
      addSwappedFact({goal: eqn, definitional: true});
    }
  }
}


//// FACTS

//// About fact info objects.  These are plain objects with properties:
//
// synopsis (optional): synopsis string
// goal: Expr statement of the fact, with all assumptions.  All
//   variables are exactly as declared, though functions such as
//   mathParse may add assumptions before returning the Expr.
// labels: object / set of labels like the ones for rules
// simplifier: true if this is an equation that simplifies
// desimplifier: true if this is an equation that "desimplifies"
// noSwap: if true, inhibits automatic generation of a fact
//   with equation LHS and RHS swapped
// prover: function intended to prove the fact
// proved: proved statement or falsy if not yet proved
// keyInfo: key and asmSet information as for factRecords.

//// About standard forms of statements, including fact declarations
//
// 

// Every fact declared by addFact or addRule is recorded under a
// string key that represents the consequent of the fact if it is
// conditional, and otherwise the full fact.  In either case the
// fact's (unique) fact properties object is the stored value.  This
// maps from fact key to an array of fact property objects as
// described above.  Private to factsExtending, setFactInfo, and
// eachFact (but see also factSquish).
//
// This structure be eliminated, using _resolutionsByKey in its place.
var _factsByKey = new Map();

// Fact declarations and fact references:

// A fact declaration, as in addFact, is an unabbreviated statement of
// the fact.  (If the statement is to be parsed, the parsing code
// may fill in parts, such as type assumptions, that are implicit
// in the string form.)

// Fact references appear where a fact is used, as in rules.fact or in
// rules.rewrite and its variants.  A fact reference is a wff, in the
// form of an Expr or string, and resolves to a recorded fact by the
// following matching process:
// 
// If a fact reference is not conditional, treat it as a conditional
// with an empty set of assumptions.
//
// A reference resolves to a recorded fact if and only if there is
// exactly one such fact for which: 1) the consequent of the reference
// exactly matches the consequent of the fact, and 2) the assumptions
// of the reference, taken as a set, are a subset or equal to the set
// of assumptions of the fact that is referred to.  The matching
// allows for changes of variable names between the recorded fact and
// the reference.

/**
 * Map from string representing the body / "main" part of a statement
 * to array of records each describing the association from a
 * statement to the fact it references.  This contains a record for
 * each statement that has been resolved to a fact, where the
 * statements with different order of assumptions and/or changes of
 * variable names are considered to be the same statement.  Each
 * record is an Object with properties "resInfo" and "factInfo", where
 * "resInfo" is a "statement resolution information" object and
 * "factInfo" is the object with all the properties of the fact.
 *
 * This could also be used to look up factInfo from a fact goal or
 * equivalent that may have different variable names or order of
 * assumptions, but that is more directly supported through
 * _factsByKey.
 * 
 * This supports fairly efficient resolution of actual or proposed
 * fact references to facts, and is used to ensure that no fact
 * reference ever becomes ambiguous.
 *
 * TODO: With _factsByKey giving access to factInfo and
 * _resolutionsByKey giving access to resInfo, possibly this could
 * store just pairs of statement and fact goal.
 */
const _resolutionsByKey = new Map();

/**
 * This returns an array of fact information objects of recorded facts
 * that match the given resInfo.  The facts extend the resInfo in that
 * they have the same key ("main part") and possibly additional
 * assumptions.
 *
 * TODO: See TODO for resolveToFactInfo.
 */
function factsExtending(resInfo) {
  const factPropsList = _factsByKey.get(resInfo.key) || [];
  const results = factPropsList.filter(function(factProps) {
      const stmtInfo = getResInfo(factProps.goal);
      return (stmtInfo.key == resInfo.key &&
              stmtInfo.asmSet.superset(resInfo.asmSet));
    });
  return results;
}

/**
 * Returns the "expansion" of a statement, preferably given as a wff.
 * The result is a version of the full declared fact of the statement,
 * with free variables as in the given statement rather than the
 * declaration.  Returns null if there is no such declared fact.
 */
function factExpansion(stmt) {
  const resInfo = getResInfo(stmt);
  const expanded = resInfo._expansion;
  if (expanded) {
    return expanded;
  }
  const factInfo = resolveToFactInfo(stmt);
  if (factInfo) {
    const asStated = factInfo.goal.getMain();
    const asRequested = resInfo.stmt.getMain();
    // This check is OK as it is just a renaming.
    const map = asRequested.matchSchema(asStated);
    const expansion = factInfo.goal.subFree(map);
    resInfo._expansion = expansion;
    return expansion;
  } else {
    return null;
  }
}

/**
 * This returns information about the recorded fact the given
 * statement is considered to refer to.
 *
 * A statement is considered to properly refer to a fact iff there is
 * exactly one fact such that the fact's main part exactly matches the
 * statement's main part and the assumptions of the fact are a
 * superset of the assumptions of the statement, both of these
 * allowing for renaming of variables.
 *
 * Returns the desired fact info, or null if there is no such fact or
 * the reference is ambiguous.
 *
 * If the fact has in its assumptions any free variables that are not
 * also free in the consequent, and if a fact reference also has the
 * assumption, they currently must have the same name.
 *
 * TODO: Consider strengthened support for references to facts that
 *   have free variables that occur in the assumptions but not the
 *   consequent.  That requires more detailed matching of assumptions
 *   in factsExtending.
 */
function resolveToFactInfo(stmt) {
  // The resInfo is "fact resolution information" for the statemement.
  const resInfo = getResInfo(stmt);
  const resolutions = _resolutionsByKey.get(resInfo.key) || [];
  // This gets a non-null value iff stmt has already been resolved.
  const resolvent = resolutions.find(function(rec) {
      //  Use of object identity here is OK because _statementResInfos
      //  ensures that repeated lookups of the same statement object
      //  result in the same resInfo object.  Also, factExpansion
      //  currently expects distinct statement objects to have
      //  distinct resInfo objects, and sharing of resInfos among
      //  different statements would be incompatible with that.
      return rec.resInfo == resInfo;
    });
  if (resolvent) {
    return resolvent.factInfo;
  }
  const candidates = factsExtending(resInfo);
  if (candidates.length == 1) {
    resolutions.length > 0 || _resolutionsByKey.set(resInfo.key, resolutions);
    resolutions.push({resInfo: resInfo, factInfo: candidates[0]});
    return candidates[0];
  }
  return null;
}

/**
 * Resolves the given statement wff to a full fact statement if
 * possible, otherwise returns null.  Like resolveToFactInfo, but
 * returns just the goal.
 */
function resolveToFact(stmt) {
  const info = resolveToFactInfo(stmt);
  return info ? info.goal : null;
}

/**
 * Returns true iff the given wff exactly matches a recorded fact in
 * the sense that, when its variables are renamed to be the standard
 * variables, its main part exactly matches a recorded fact and its
 * set of assumptions is equal to the set of assumptions of the result
 * of standardizing the variables of the recorded fact.
 *
 * NOTE: In the unlikely event that the recorded fact has multiple
 * variables that are free only in its assumptions, the result could
 * be false even though the statements have the same assumptions.
 * This would be due to different ordering of assumptions between the
 * given statement and the recorded fact, and thus different
 * assignments of variable names.
 *
 * Also note that any assumption with free variable(s) in the LHS can
 * be converted to an existential term where the variable is bound,
 * making this scenario particularly unlikely.
 */
function isRecordedFact(stmt) {
  // First check that the statement resolves to a specific fact.
  const factInfo = resolveToFactInfo(stmt);
  if (factInfo) {
    // Then verify that the statement and the fact are indeed
    // equivalent.
    const asms = getResInfo(stmt).asmSet;
    const factAsms = getResInfo(factInfo.goal).asmSet;
    return asms.equals(factAsms);
  }
  return false;
}


/**
 * Like getResult, below, but always proves the statement if it has
 * an associate prover function.
 */
function proveResult(stmt) {
  return getResult(stmt, true);
}

/**
 * Accepts an already-proved step or the full statement of some
 * recorded fact.  Returns a proof of the step, or one like it except
 * for changes of names of variables including free variables.  Throws
 * an exception in case of failure.
 *
 * Note that the facts database currently looks up facts by their
 * "main" part, ignoring any assumptions.
 *
 * The optional second argument, for internal use only, if true,
 * overrides any setting of Toy.assertFacts and assures that a proved
 * result will be returned (if there is a prover function).
 *
 * TODO: Consider renaming to something like "stepify" and using as
 *   a conversion for inputs to steps in the vein of "termify".
 */
function getResult(statement, mustProve) {
  if (Toy.isProved(statement)) {
    return statement;
  }
  var info = resolveToFactInfo(statement);
  assert(info, 'Not a recorded fact: {1}', statement);
  // TODO: Consider more precise checking of the result of the lookup.
  if (info.proved) {
    return info.proved;
  }
  var prover = info.prover;
  if (Toy.assertFacts && !mustProve) {
    var result = rules.assert(info.goal);
    return result;
  }
  try {
    info.inProgress = true;
    // Get the proved result of the fact.
    info.proved = prover();
    assert(info.proved.isProved(), 'Proof failed: {1}', statement);
    info.inProgress = false;
  } finally {
    if (info.inProgress) {
      console.error(new Error('Proof of fact failed' + statement));
      // Ensure that the proof is not in progress upon completion.
      info.inProgress = false;
    }
  }
  return info.proved;
}

/**
 * Returns true iff a proof of this statement is underway but not
 * completed.  Can be used to prevent infinite regress, as in the case
 * of simplifiers that might be skipped during their own proof.
 */
function isInProgress(stmt) {
  if (!resolveToFactInfo(stmt)) {
    // It could be a tautology, but not a recorded fact.
    return false;
  }
  const info = resolveToFactInfo(stmt);
  return info && info.inProgress;
}

/**
 * JS Map from statement in wff (or currently string) form to
 * information about the statement.  The information is a resInfo
 * object, for getResInfo.  This serves as a cache to accelerate these
 * calculations, especially given that the same statements tend to be
 * used over and over.  Private to getResInfo.
 *
 * The resInfo is a plain object with properties "key", "asmSet", and
 * "stmt", all related to a particular fact statement, plus one
 * property internal to factExpansion.  The asmSet is a TermSet of the
 * statement's assumptions, the key is its "fact key", the stmt is the
 * wff statement it comes from.
 *
 * This can support string keys, but mathParse already accelerates
 * conversion of strings to wffs.
 */
const _statementResInfos = new Map();

const noTerms = new Toy.TermSet();

/**
 * Given a wff (or currently a string that parses to one using
 * mathParse), returns a "resInfo" or "fact resolution information"
 * object, which has information useful for resolving exactly which
 * fact the statement is intended to refer to.  The result is a
 * resInfo object as described just above.
 * 
 * The key is a string that represents the main/body of the wff, with
 * all variables of that part replaced with standard variables so the
 * key does not depend on the names of variables supplied as the
 * statement.  The asmSet is a TermSet of the assumptions, also using
 * standard variable names.
 *
 * This remembers the association between the given statement object
 * and the resInfo to speed repeated lookups, which is the usual case
 * for fact references in rewriting rules or fact lists.
 */
function getResInfo(stmt) {
  // Computes the resolution info for the statement and caches the
  // association in _statementResInfos.
  function computeStatementInfo(stmt) {
    if (typeof stmt == 'string') {
      // Uncomment this line to get the warnings back.
      // console.warn('Deprecated: resInfo of string:', stmt);
    }
    // TODO: Fix higher-level code to do the parsing, so different
    //   type assumptions and such can be inserted at that level.
    const wff = mathParse(stmt);
    const main = wff.getMain();
    const hasAsms = wff.isCall2('=>');
    // This makes a wff with main first, and also has
    // any assumptions, ordered after the main part.  We
    // do not expect this to be a theorem.
    const wff2 = (hasAsms
                  ? Toy.infixCall(main, '&', wff.getLeft())
                  : wff);
    const standard = Toy.standardVars(wff2);
    const asmSet = (hasAsms
                    ? Toy.makeConjunctionSet(standard.getRight())
                    : noTerms);
    // Uses toKey so that aliases, in particular "==" for "=", are
    // treated the same.
    const key = (hasAsms ? standard.getLeft() : standard).toKey();
    const info = {key: key, asmSet: asmSet,
                  standardVars: standard,
                  // _expansion will be initialized later.
                  stmt: wff, _expansion: null};
    _statementResInfos.set(stmt, info);
    return info;
  }
  return (_statementResInfos.get(stmt) ||
          computeStatementInfo(stmt));
}


//// Finding matching facts

/**
 * Finds a single LHS match within the given term with one of the
 * given facts.  Returns the value of the successful call to
 * findMatchingFact, with a "path" property added indicating the path
 * from the term argument to the matched term, or a falsy value if no
 * call succeeded.
 *
 * All arguments other than the term are passed via "info".  If it is
 * a plain object, it interprets the following properties:
 *
 * facts: List of facts in the format accepted by findMatchingFact.
 * context: Context information for "where" clauses as
 *   accepted by findMatchingFact.
 *   TODO: (BUG!) Accept an "isQuantified" property here, or more 
 *      detailed information, to indicate enclosing bound variables.
 * searchMethod: Name of method to apply to the term to control
 *   which subexpressions of the term to apply findMatchingFact to;
 *   defaults to 'searchMost', which searches through calls.
 *
 * If the info is an array, it must be the list of facts.
 *
 * TODO: Consider changing this to something like applyMatchingFactIn,
 *   doing essentially the same search, but attempting to apply the
 *   first fact that seems to match, and continuing the search if
 *   application fails.
 */
function searchForMatchingFact(term, info) {
  var allFacts, searchMethod;
  var cxt = {};
  if (info.constructor === Object) {
    allFacts = info.facts;
    info.context && Object.assign(cxt, info.context);
    searchMethod = info.searchMethod;
  } else {
    allFacts = info;
  }
  // If set to non-null, just unconditional facts.  At present only
  // includes facts that are just a statement in string form.
  // Computed here for efficiency.
  //
  // TODO: Handle more complicated facts (as needed).
  var pureFacts = null;
  function isPureFact(fact) {
    if (typeof fact === 'string' || fact instanceof Expr) {
      // This next line supports ordinary facts and also tautologies.
      // It relies on resolveToFact to return a conditional whenever
      // it is given a statement that has implicit assumptions.
      var fullFact = resolveToFact(fact) || termify(fact);
      return fullFact && fullFact.isCall2('=');
    } else if (fact.constructor === Object && fact.pure) {
      return true;
    }
  }
  searchMethod = searchMethod || 'searchMost';
  function factFinder(term, revPath, isQuantified) {
    if (isQuantified) {
      pureFacts = pureFacts || allFacts.filter(isPureFact);
    }
    // If some free variables of a conditional fact do not appear in
    // the assumptions, this may exclude it unnecessarily.
    //
    // TODO: Consider a more precise check here.
    var facts = isQuantified ? pureFacts : allFacts;
    var result = findMatchingFact(facts, cxt, term, isQuantified);
    if (result) {
      result.path = revPath.reverse().concat(result.path);
    }
    return result;
  }
  // TODO: Accurately determine quantification of the term,
  //   and use the proper information rather than a boolean
  //   to control "purity" of facts in each context.
  return term[searchMethod](factFinder, Toy.Path.empty, false);
}

// This finds the fact part to match.  If the fact is not an equation,
// uses the main part instead of the LHS.
function schemaPart(fact) {
  var main = fact.getMain();
  return (main.isCall2('=')
          ? main.getLeft()
          : main);
}

/**
 * Searches the given pattern list for one whose "schema part" matches
 * the given term.  If it finds one, returns info about it in a plain
 * object in the format described below.  The schema part of a
 * (possibly conditional) equational fact is the LHS of the equation.
 * Otherwise it is the main part: the consequent if conditional,
 * otherwise the entire fact.
 *
 * TODO: This and its users can now produce a substitution that fails
 * on account of unification.  Implement an approach to deal with
 * this issue.
 *
 * The context argument is available to "where" arguments as "cxt",
 * and any "factLists" property of the context defines lists of named
 * patterns accessible by using the name in place of an explicit list.
 * The value of the factLists property is a plain object mapping from
 * list name to a list (array) value.  In this way lists can be
 * reused, and also enables them to be effectively recursive.
 *
 * Each pattern argument can be an argument acceptable to
 * resolveToFact, or:
 *
 * A plain object with properties as follows:
 *
 * stmt: value acceptable to resolveToFact.  Unless "match" is also
 *   given this will need to be an equation.
 * where: optional string to evaluate, with "subst" 
 *   argument to findMatchingFact available as "$" and cxt and term
 *   available as free variables for use in the string.
 *   OR if it is a function, call it with the substition, cxt, and
 *   term as arguments.
 *
 * For fact statements passed as list elements or the "stmt" property
 * of a list element, if proof of the fact is in progress at the time,
 * the fact is ignored in the search.  This provides a crude mechanism
 * for avoiding infinite regress, for example when simplifying steps
 * of the proof of a simplifier fact.
 *   
 * Or it can be a plain object with a single property, either:
 *
 * descend: a plain object with properties "schema", a schema
 *   (possibly in string form) to match against the term, and "parts",
 *   a plain object mapping from variable names in this schema each to
 *   a pattern list as described above. If the search reaches this
 *   "descend" item and the schema matches the term, the search
 *   descends into the parts of the term, applying each schema
 *   variable's list of facts to the part of the term matching that
 *   schema variable.
 *
 * TODO: Consider replacing "schema" and "parts" with "match"
 *   and additional properties named after some of the variables
 *   in the schema, as in walkPatterns.
 *
 * apply: a function to apply to the input term and context, which
 *   must return an equation whose LHS is the same as the term except
 *   for possible changes of bound variables, or a falsy value if it
 *   fails to produce such an equation.  The call is done by
 *   Toy.normalReturn, and this uses the value returned from that.
 *
 * The value returned is falsy if no match is found, else a plain
 * object with properties:
 * 
 * stmt: Relevant fact statement, proved or not, or the equation
 *   returned by an "apply" pattern.
 * term: the term argument to findMatchingFact.
 * subst: substitution that makes the given term match the fact (empty for
 *   "apply" patterns).
 * path: path to the portion of the given term that matched some pattern.
 *
 * If pureOnly is true, this only accepts a fact that is a pure
 * equation, with no conditions on it.
 */
function findMatchingFact(facts_arg, cxt, term, pureOnly) {
  // This function interprets a fact statement as a wff.
  // Currently it uses mathParse.
  // TODO: Use the context (cxt) and perhaps other information to determine
  //   this aspect of the interpretation of a fact statement, enabling
  //   fact statements here that are not interpreted as relating to real
  //   numbers.
  function interpret(stmt) {
    return mathParse(stmt);
  }
  function apply$(expr, $) {
    if (typeof expr === 'function') {
      return expr($, cxt, term);
    } else {
      // Suppress acccess to the enclosing "facts" variable.
      // OK for str to refer to "cxt" or "term".
      var facts;
      return eval(expr);
    }
  }
  var facts = facts_arg;
  if (typeof facts_arg == 'string' && Toy.isIdentifier(facts_arg)) {
    facts = cxt.factLists && cxt.factLists[facts_arg];
  }
  for (const factMatcher of facts) {
    if (factMatcher.constructor !== Object) {
      // The factMatcher is a string or wff.
      // The stmt is a wff, so there will be no need for lower-level code
      // to decide how to "interpret" / parse it.
      var stmt = interpret(factMatcher);
      if (!isInProgress(stmt)) {
        // TODO: Change this to match before checking for inProgress,
        //   and warn when a match is rejected due to fact proof in
        //   progress.
        var fullFact = (factExpansion(stmt) ||
                        rules.arithFact(stmt) ||
                        rules.tautology(stmt));
        if (Toy.isError(fullFact)) {
          continue;
        }
        if (!(pureOnly && fullFact.isCall2('=>'))) {
          var schema = schemaPart(fullFact);
          // This substitution might not work.
          // TODO: Consider how to handle its potential failure.
          var subst = term.matchSchema(schema);
          if (subst) {
            var result = {stmt: fullFact,
                          term: term,
                          path: Toy.asPath(''),
                          subst: subst};
            return result;
          }
        }
      }
    } else if (factMatcher.apply) {
      // "apply"
      var eqn = Toy.normalReturn(factMatcher.apply, term);
      if (eqn && !(pureOnly && eqn.isCall2('=>'))) {
        var result = {
          stmt: eqn,
          term: term,
          path: Toy.asPath(''),
          subst: {}
        };
        return result;
      }
    } else if (factMatcher.descend) {
      // "descend"
      var partInfo = factMatcher.descend;
      // TODO: Handle pureOnly here.
      var result = _locateMatchingFact(term,
                                       partInfo.schema,
                                       partInfo.parts,
                                       cxt);
      if (result) {
        return result;
      }
    } else {
      const stmt = interpret(factMatcher.stmt);
      if (!stmt) {
        console.warn('Nothing to do in fact matcher:',
                     factMatcher);
        return null;
      }
      const factInfo = resolveToFactInfo(stmt);
      if (!factInfo) {
        console.error('No such fact:', ''+stmt);
        return null;
      }
      if (factInfo.inProgress) {
        return null;
      }
      if (pureOnly && factInfo.goal.isCall2('=>')) {
        return null;
      }
      const expansion = factExpansion(stmt);
      const schema = schemaPart(expansion);
      // This substitution might fail.
      // TODO: consider how to handle its potential failure.
      const subst = term.matchSchema(schema);
      const where = factMatcher.where;
      if (subst && (!where || apply$(where, subst))) {
        var result = {stmt: expansion,
                      term: term,
                      path: Toy.asPath(''),
                      subst: subst};
        return result;
      }
    }
  }
  // If no match found the value will be falsy.
};

/**
 * This handles "descend" patterns in findMatchingFact, and is private
 * to it.
 *
 * Arguments are the term argument to findMatchingFact, the schema
 * property of the "descend" pattern, the "parts" property of the
 * "descend" pattern, and the context argument to findMatchingFact.
 */
function _locateMatchingFact(expr, schema_arg, varsMap, context) {
  var schema = termify(schema_arg);
  var factLists = context.factLists;
  var subst;
  // This substitution might fail.
  // TODO: Consider how to handle its potential failure.
  if ((subst = expr.matchSchema(schema))) {
    return Toy.withExit(exit => {
        // Checks if the given term of the schema matches some fact in
        // the appropriate factsList.  Only schema variables are
        // eligible to match.
        function checkTerm(schemaTerm, revPath) {
          if (schemaTerm.isVariable()) {
            var list = varsMap[schemaTerm.name];
            if (typeof list == 'string' && Toy.isIdentifier(list)) {
              list = factLists[list];
            }
            if (list) {
              var result =
                findMatchingFact(list, context, expr.get(revPath.reverse()));
              if (result) {
                result.path = revPath.reverse().concat(result.path);
                exit(result);
              }
            }
          }
        }
        // TODO: Consider replacing this use of Expr.traverse with
        //   Expr.searchMost.
        schema.traverse(checkTerm);
      });
  }
}

/**
 * Beta-reduces the given term if it is a call to a lambda,
 * otherwise returns a falsy value.
 */
function tryReduce(term) {
  return term.isLambdaCall() && rules.axiom4(term);
}

/**
 * Find and apply one of the facts to the part of the step at the
 * given path, returning the result, or null if none of the
 * facts apply.  Note: uses rules.rewrite by default; supply
 * a ruleName (fourth arg) if desired.
 */
function applyMatchingFact(step, path, facts, rule_arg) {
  const ruleName = rule_arg || 'rewrite';
  const info = findMatchingFact(facts, null, step.get(path));
  return info && rules[ruleName](step, path, info.stmt);
}

/**
 * Apply the list of fact rewrites to the "focal" part of the step
 * until none of them any longer is applicable, returning the result.
 */
function applyToFocalPart(step, facts) {
  return applyFactsWithinSite(step, step.pathToFocalPart(), facts);
}

/**
 * Apply the list of facts as rewrites to the given part of the step
 * until none of them any longer is applicable, returning the result,
 * with asms deduped but not simplified. (?)  Returns its input step
 * if no matches are found.
 */
function applyFactsWithinSite(step, path_arg, facts) {
  var path = Toy.asPath(path_arg);
  var eqn1 = rules.considerPart(step, path);
  var eqn2 = applyFactsWithinRhs(eqn1, facts);
  return (eqn2 == eqn1 ? step : rules.replace(step, path, eqn2));
}

/**
 * Apply the list of facts as rewrites to the RHS of the given step,
 * which must be an equation.  Repeats until none of them is
 * applicable, returning the result.  Returns its input step if no
 * matches are found.  Uses rules.rewrite, not rewriteOnly.
 */
function applyFactsWithinRhs(step, facts) {
  var rhs;
  var info;
  var eqn = step;
  while (rhs = eqn.asPath('/main/right'),
         info = searchForMatchingFact(eqn.get(rhs), facts)) {
    var fullPath = rhs.concat(info.path);
    eqn = rules.rewrite(eqn, fullPath, info.stmt);
  }
  return eqn;
}

/**
 * Apply the function to the subexpression of step at path.  The
 * function should return a possibly conditional equation whose LHS is
 * the same as the target subexpression.  This replaces the
 * subexpression using the returned equation.
 *
 * If the function returns a falsy value, this returns that.
 */ 
function convert(step, path, fn) {
  var expr = step.get(path);
  assert(expr, 'Bad path {1}', path, step);
  var eqn = fn(expr);
  return eqn && rules.replace(step, path, eqn);
}

/**
 * Proves that the given term is equal to something by taking it as
 * equal to itself, applying the given equation throughout its RHS,
 * rewriting the result with the given fact, then applying the reverse
 * of the equation throughout the resulting RHS.  The term can be
 * a string, while the equation can be proved steps or statements
 * of any recorded equational fact.
 *
 * Intended to capture a design pattern for proving facts about
 * "inverse" functions such as division and subtraction.
 */
function transformApplyInvert(term_arg, eqn_arg, fact) {
  var term = termify(term_arg);
  var eqn = getResult(eqn_arg);
  var revEqn = rules.eqnSwap(eqn);
  var step1 = rules.consider(term);
  var step2 = applyFactsWithinRhs(step1, [eqn]);
  var step3 = rules.rewrite(step2, '/main/right', fact);
  var step4 = applyFactsWithinRhs(step3, [revEqn]);
  return step4;
}

/**
 * Apply the given simplification function to the step repeatedly
 * until the result of the call is falsy or identical to its input.
 * Return the result of the last call that was not falsy or same.
 */
function repeatedly(step, fn) {
  var simpler = step;
  var next;
  while (true) {
    next = fn(simpler);
    if (!next || next.matches(simpler)) {
      return simpler;
    }
    simpler = next;
  }
}

/**
 * Applies the given facts repeatedly to the RHS of the given equation
 * until none matches, each time replacing the RHS with the result of
 * applying the matching fact.  Returns the last version created.
 */ 
function arrangeRhs(eqn_arg, context, facts) {
  var rhsPath;
  var info;
  var eqn = eqn_arg;
  while (rhsPath = eqn.asPath('/main/right'),
         info = findMatchingFact(facts, context, eqn.get(rhsPath))) {
    var fullPath = rhsPath.concat(info.path);
    const next = rules.rewrite(eqn, fullPath, info.stmt);
    eqn = next;
  }
  return eqn; 
}

/**
 * Arranges the given part of the given step by repeatedly applying
 * the given facts until none matches, returning a step with the part
 * replaced by the result of the rearrangement.
 *
 * As a good practice, this considers the part in isolation, only
 * replacing it in the step when done applying facts.
 */
function arrange(step, path, context, facts) {
  var eqn = rules.consider(step.get(path));
  var arranged = arrangeRhs(eqn, context, facts);
  return rules.replace(step, path, arranged);
}

/**
 * Call the given function for each recorded fact, passing
 * it the info object stored for the fact.
 */
function eachFact(fn) {
  _factsByKey.forEach(function(list) {
      list.forEach(function(info) {
          fn(info);
        });
    });
}

/**
 * Checks that the named rule is a theorem (i.e. takes no arguments),
 * and gets its result.  Returns null if there is not a theorem
 * of that name.
 */
function getTheorem(name) {
  var action = rules[name];
  if (!action || action.length !== 0) {
    return null;
  }
  return action();
}


//// UTILITY FUNCTIONS

/**
 * Searches the list of equational facts in order for one that matches
 * a subexpression of the given step.  In particular, the part of the
 * step at path must match with the variable in the LHS of the fact
 * having the given name, which should occur exactly once in the
 * fact's LHS.
 *
 * If this finds such a fact it returns a function of no arguments
 * that applies the fact to the step using rules.rewrite and returns
 * the result of the rewrite.
 *
 * TODO: Consider how to make sure the facts in factList are
 *   interpreted appropriately.
 *
 * TODO: If useful, extend to facts that are not equations.  Probably
 *   rethink and rewrite along with all or most uses of
 *   matchSchemaPart.
 */
function matchFactPart(step, path, factList, name) {
  return Toy.each(factList, function(fact_arg) {
    var schema = factExpansion(fact_arg).getMain().getLeft();
    var info = step.matchSchemaPart(path, schema, name);
    if (info) {
      return function() {
        return rules.rewrite(step, info.path, fact_arg);
      };
    }
  });
}

/**
 * Build a schema for a conjunction of assumptions, ensuring all are
 * in the TermMap, with optional exclusions, a TermSet.  The schema is
 * of the form a1 & ... & an, where the "a"s are variables for the
 * terms for each of the assumptions.
 */
function buildHypSchema(hyps, map, exclusions) {
  var schema = null;
  hyps.scanConj(function(hyp) {
      var v = map.addTerm(hyp);
      if (!exclusions || !exclusions.has(hyp)) {
        schema = schema ? Toy.infixCall(schema, '&', v) : v;
      }
    });
  return schema;
}

/**
 * Returns the given conjunction of assumptions except any appearing in
 * the exclusions TermSet.  If there are no such assumptions, returns
 * T.
 */
function hypsExcept(hyps, exclusions) {
  var result = null;
  hyps.scanConj(function(hyp) {
      if (!exclusions.has(hyp)) {
        result = result ? Toy.infixCall(result, '&', hyp) : hyp;
      }
    });
  return result;
}

/**
 * Makes a facts map into a list of the fact keys.
 */
function listFacts(map) {
  var list = [];
  for (var key in map) {
    list.push(key);
  }
  return list;
}

/**
 * Developer utility function that modifies the named rule to emit
 * information about calls to it.
 */
function traceRule(name) {
  var rule = rules[name];
  function timed() {
    console.log('Enter', name);
    for (var i = 0; i < arguments.length; i++) {
      console.log(i, arguments[i] + '');
    }
    var t = new Toy.NestedTimer(name);
    t.start();
    var result = rule.apply(rules, arguments);
    var elapsed = t.end();
    console.log('=', result + '');
    console.log('Exit', name, elapsed, 'ms');
    return result;
  }
  timed.info = rule.info;
  rules[name] = timed;
}

/**
 * Returns the plain object with various information about the rule
 * applied to create the given step.
 */
function getRuleInfo(step) {
  return rules[step.ruleName].info;
}

/**
 * If the given step has a "site" input, this returns the path
 * of the site argument, a string or Path object.  This uses the
 * "inputs" information of the rule that generated the step to
 * determine which argument to access.
 */
function getStepSite(step) {
  var inputs = getRuleInfo(step).inputs;
  for (var type in inputs) {
    if (type in Toy.siteTypes) {
      var args = step.ruleArgs;
      // Assumes there can be only one "site" argument.
      var index = inputs[type];
      return args[index];
    }
  }
}

/**
 * Returns an array of the (regular) steps leading up to and including
 * the given plain / unrendered step, sorted by ordinal.
 */
function proofOf(step) {
  // See also the similar Toy.unrenderedDeps.
  const visited = new Set();
  var result = [];
  // Traverses the dependencies graph, recording each step found
  // and building an array of them.
  function visitWithDeps(step) {
    if (!visited.has(step)) {
      result.push(step);
      visited.add(step);
      step.ruleDeps.forEach(function(dep) { visitWithDeps(dep); });
    }
  }
  visitWithDeps(step);
  result.sort(function(s1, s2) {
      return s1.ordinal - s2.ordinal;
    });
  return result;
}

/**
 * Returns an array of "assume" steps in the proof of the given step
 * (see Toy.proofOf) that create an assumption of the step.  Assumes
 * that the assumptions are a chain of conjuncts, which is true of
 * normalized assumptions.  Used in rendering to highlight the sources
 * of assumptions.
 */
function assumptionsUsed(step) {
  var asms = step.asmPart();
  if (!asms) {
    return [];
  }
  var asmList = [];
  asms.scanConj(function (expr) { asmList.push(expr); });

  var steps = proofOf(step);
  var result = [];
  for (var i = 0; i < steps.length; i++) {
    var step = steps[i];
    if (step.ruleName === 'assume') {
      for (var j = 0; j < asmList.length; j++) {
        var asm = asmList[j];
        // Note that every "assume" step is a conditional.
        if (step.getRight().sameAs(asm)) {
          result.push(steps[i]);
        }
      }
    }
  }
  return result;
}

/**
 * The given Expr is treated as the root of a tree of conjuncts.
 * This searches for a direct or indirect conjunct of it that
 * passes the test.  Returns a (pretty) path to the node found,
 * or null if none is found.
 */
function pathToConjunct(root, test) {
  var Path = Toy.Path;
  function pathFrom(node) {
    if (test(node)) {
      return Path.empty;
    }
    if (node.isCall2('&')) {
      var rpath = pathFrom(node.getRight());
      if (rpath) {
        return new Path('right', rpath);
      }
      var lpath = pathFrom(node.getLeft());
      if (lpath) {
        return new Path('left', lpath);
      }
    }
    return null;
  }
  return pathFrom(root);
}

/**
 * Builds and returns a propositional schema from the given term,
 * with the structure of the tree of conjunctions rooted at the term.
 * Matching parts get the same variable letter.
 */
function conjunctionSchema(term) {
  var map = new Toy.TermMap();
  var infixCall = Toy.infixCall;
  function makeSchema(term) {
    if (term.isCall2('&')) {
      return infixCall(makeSchema(term.getLeft()), '&',
                       makeSchema(term.getRight()));
    } else {
      map.addTerm(term);
      return map.get(term);
    }
  }
  return makeSchema(term);
}

/**
 * Returns a Map with information about the bindings of variables that
 * are bound in the scope of the given path.  Keys of the map are
 * variable names, and each value is a path to the site where the
 * variable of that name is bound.
 *
 * The path must only have segments fn, arg, and/or body.
 */
Expr.prototype.pathBindings = function(path_arg) {
  const Path = Toy.Path;
  const bindings = new Map();
  let path = Toy.asPath(path_arg);
  let revPath = Path.empty;
  let term = this;
  while (!path.isEnd()) {
    const segment = path.segment;
    path = path.rest;
    switch(segment) {
    case 'fn':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('fn', revPath);
      term = term.fn;
      break;
    case 'arg':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('arg', revPath);
      term = term.arg;
      break;
    case 'body':
      assert(term instanceof Lambda, 'Not a Lambda: {1}', term);
      bindings.set(term.bound.name, revPath.reverse());
      revPath = new Path('body', revPath);
      term = term.body;
      break;
    default:
      assert(false, 'Bad segment {1} in path {2}', segment, path_arg);
    }
  }
  return bindings;
}


//// Simplification facts

/**
 * Simplification facts for algebra, used in _simplifyOnce
 * simplifier: true are added to this list.
 *
 * TODO: Consider whether x - 7 is simpler than x + -7.
 * TODO: Declare number facts as simplifiers rather than adding here.
 */
var basicSimpFacts = [
                      'T & a == a',
                      'a & T == a',
                      'F & a == F',
                      'a & F == F',
                      'T | a == T',
                      'a | T == T',
                      'F | a == a',
                      'a | F == a',
                      'a & a == a',
                      'a | a == a',
                      'a | not a == T',
                      'not T == F',
                      'not F == T',
                      '(a == T) == a',
                      'not (not a) == a',
                      'x = x == T',
                      'T => a == a',
                      'not (a = b) == a != b',
                      'if T x y = x',
                      'if F x y = y',
                      {stmt: '@a + neg b = a - b',
                       // This condition makes extra-sure there will be
                       // no circularity during simplification.
                       // Negation of a numeral will be simplified by
                       // other rules.
                       where: '!$.b.isNumeral()'},
                      {stmt: '@a - b = a + neg b',
                       // This one is an exception to the general rule
                       // that simplifiers make the expression tree
                       // smaller; but arithmetic will follow this, and
                       // with high priority.
                       where: '$.b.isNumeral() && $.b.getNumValue() < 0'},
                      {apply: function(term, cxt) {
                          return (Toy.isArithmetic(term) &&
                                  rules.axiomArithmetic(term));
                        }
                      }
                      // {apply: arithRight} Done in numbers.js.
                      ];


//// Support for adding facts

/**
 * Treats each key in the map as a synopsis of a mathematical
 * statement, and treats its value as a function to prove the
 * statement.  Uses addRule to add each statement and its proof
 * function to the internal database of provable facts.  Applies
 * mathParse to the statement.
 *
 * TODO: Eventually support processing of the synopsis by other than
 *   mathParse, e.g. based on an additional property in the info.
 */
function addFactsMap(map) {
  for (var synopsis in map) {
    var info = map[synopsis];
    info.statement = Toy.mathParse(synopsis);
    addRule(info);
  }
}

// Object / set of property names supported in fact info data, used
// for validation of fact properties.  See addFact.
var factProperties = {
  goal: true,
  proved: true,
  axiom: true,
  statement: true,
  proof: true,
  definition: true,
  simplifier: true,
  desimplifier: true,
  noSwap: true,
  labels: true,
  description: true,
  definitional: true,
  // autoSimplify: true,
  // afterMatch: true,
  converse: true
};

/**
 * Adds an entry to the facts database given information in the format
 * of fact entries in facts maps, assuming here that the synopsis is
 * already added to the info as a synopsis property.  Can use the
 * synopsis property to generate a goal and the proof property as the
 * prover.  Top-level code, as in files of theorems, definitions, and
 * inference rules, should use addRule (or addFactsMap) as they
 * support rules of inference,and do additional useful work such as
 * automatically adding appropriate swapped facts.  The goal as stored
 * in the database has type information.
 *
 * Returns the fully-processed "info".
 *
 * This does no inference, so it can be called before proving any
 * theorems.
 *
 * Currently recognizes input properties as follows:
 *
 * goal: if present, can generate the synopsis; if proved, becomes
 *   the proved result, and any proof function will be ignored,
 *   otherwise a WFF.
 * axiom: true if this is an axiom.
 * synopsis:  string for input to mathParse.  Must parse to a
 *   complete statement of the fact, to be used as the goal.
 * proof: function to return the proved fact, matching the goal.
 *   If not present, one will be generated to assert the goal.
 * description: string or function as for a rule description.
 * simplifier: true iff this fact is a simplifier.
 * desimplifier: true iff this fact is the "converse" of a simplifier.
 * definition: true if this fact is introduced as a definition.
 *   Currently just affects the message.
 * definitional: the fact is "basically" a definition of a
 *   function or predicate.  Used for presentation of the fact
 *   in a menu.
 * autoSimplify: if given, a simplifier function that takes the
 *   result of a rewrite with this fact as its input and applies it
 *   as the interactive auto-simplifier.
 * labels: Optional object/set of label names.  If given as a string,
 *   parses space-separated parts into a set.  The result constains just
 *   "none" if none are given.
 * converse.labels: Like labels, but applies to a "swapped" version
 *   of the fact, if any.
 */
function addFact(info) {
  // This function adds to the info and supplies it to setFactInfo.

  // This will be the same as the goal if the goal is proved.
  info.proved = info.goal && info.goal.isProved() && info.goal;

  // Ensure that the goal has types.
  info.goal = (info.proved ||
               // TODO: Consider how to possibly better ensure that
               // types in the goal are identical with types in the
               // proved fact.  (Always prove on first use?)
               info.goal.typedCopy() ||
               mathParse(info.statement));
  for (var key in info) {
    if (!(key in factProperties)) {
      var id = info.goal ? info.goal.$$ : info.synopsis;
      console.warn('In fact', id, 'extra info key:', key);
    }
  }

  if (info.proof) {
    // Give the proof function a useful and pretty name for stack
    // traces.
    const stmt = info.statement || info.goal.toUnicode();
    Object.defineProperty(info.proof, 'name', {value: 'proof of ' + stmt});
  }

  // Adding new constants.  Doing it here adds them before asserting
  // the fact.  Also rules.assert can add constants in case it is used
  // without registering a fact. (And Toy.define also adds the defined
  // constant as it bypasses this code.)
  // TODO: If there is no proof, assert the fact immediately and skip
  //   this code.
  info.goal.registerConstants();
  const names = info.goal.newConstants();
  if (names.size > 0) {
    if (info.definition) {
      console.log('Defining',
                  Array.from(names).join(', '));
    } else {
      console.log('In fact', info.goal.toString(), 'introducing constants:',
                  Array.from(names).join(', '));
    }
    Toy.addConstants(names);
  }
  if (!info.proved) {
    if (!info.axiom && !info.definition && !info.proof) {
      console.warn('No proof for', info.goal.toUnicode());
    }
    info.prover = asFactProver(info.proof, info.goal);
  }
  // This will be set to true when starting to attempt a proof and
  // reset to false when the proof succeeds.  In findMatchingFact
  // facts with proof currently in progress are not considered, e.g.
  // affecting simplification.
  info.inProgress = false;

  info.labels = processLabels(info.labels);
  computeMenuCategories(info);

  if (isRecordedFact(info.goal)) {
    console.info('Fact', info.goal.$$, 'already recorded, skipping.');
  } else {
    if (info.simplifier) {
      // This puts a string onto basicSimpFacts for fast cached
      // lookups, but watch out for cases where toString and parse are
      // not inverses.
      basicSimpFacts.push('@' + info.goal.toString());
    }
    setFactInfo(info);
  }
  return info;
}

/**
 * Record the given fact information; private to addFact.  See
 * comments on _factsByKey and fact management functions for the
 * expectations on the argument.
 *
 * Returns truthy for success, falsy if the new fact statement is not
 * allowable: either already recorded or alters the meaning of a
 * statement already referring to a different fact.
 */
function setFactInfo(info) {
  if (isRecordedFact(info.goal)) {
    console.log('Already recorded fact:', info.goal.toString());
    return false;
  }
  const key = getResInfo(info.goal).key;
  const facts = _factsByKey.get(key) || [];
  // Ensure that the key has an array of facts.
  facts.length > 0 || _factsByKey.set(key, facts);
  // Tentatively add the fact to the list.
  facts.push(info);
  const resolutions = _resolutionsByKey.get(key);
  // If foundRef becomes non-null, this will become an array of the
  // facts that it could refer to.
  var extFacts;
  if (resolutions) {
    // If found, this is a ref whose statement would refer to a
    // different fact in the presence of the tentative new fact.
    const foundRef = resolutions.find(function(rec) {
        extFacts = factsExtending(rec.resInfo);
        return (extFacts.length != 1 ||
                extFacts[0].factInfo != rec.factInfo);
      });
    if (foundRef) {
      // There was an issue.  Immediately remove the fact from the list.
      facts.pop();
      // Then complain and return false.
      console.error('New fact', info.goal.toString());
      // TODO: Make available info to improve the following message.
      //   Reference to the stated fact reference would be helpful.
      console.log('  would confound references to',
                  foundRef.resInfo.stmt.toString(),
                  'info:', foundRef.resInfo);
      return false;
    }
  }
  return true;
}

/**
 * Add the "converse" of an equational fact if it is not already
 * recorded.  Determines the statement from the info's goal.  If it is
 * an equation, adds a fact with its LHS and RHS swapped, otherwise
 * does nothing.
 *
 * If the fact to be swapped is a simplifier or desimplifier, the
 * newly-created fact will be appropriately labeled as the opposite,
 * and converses of primitive facts are also labeled as primitive.
 */  
function addSwappedFact(info) {
  var stmt = info.goal;
  if (stmt.isEquation()) {
    var swapped = Toy.commuteEqn(stmt);
    if (!isRecordedFact(swapped)) {
      function proveSwapped() {
        return rules.fact(stmt).andThen('eqnSwap');
      }
      var labels2 = processLabels(info.converse && info.converse.labels);
      if (info.labels && info.labels.primitive) {
        labels2.primitive = true;
      }
      computeMenuCategories(info, true);
      var info2 = {proof: proveSwapped,
                   goal: swapped,
                   simplifier: !!info.desimplifier,
                   desimplifier: !!info.simplifier,
                   description: info.description,
                   labels: labels2
      };
      addFact(info2);
    }
  }
}

/**
 * Accepts a "prover" function of no arguments and a goal statement
 * (Expr).  The prover may be null, in which case this generates
 * a trivial prover that asserts the goal.
 *
 * Returns a function to construct and return a proved statement from
 * the arguments.  The returned function runs the prover to prove the
 * goal.  When running the prover, the returned function also attempts
 * to use exactly the free variables in the goal, and arranges the
 * assumptions accordingly.  It warns if assumptions do not match up
 * with the goal, and raises an error if it cannot make the main part
 * match exactly.
 *
 * Internal to addFact.
 */
function asFactProver(prover, goal) {
  assert(!prover || typeof prover === 'function',
         'Not a function: {1}', prover);
  // This function wraps around the user-supplied fact prover
  // to do the generic parts of the work.
  function factProverWrapper() {
    var result;
    if (goal.isProved()) {
      result = goal;
    } else if (!prover) {
      // The proof is just a stub not yet filled in.
      return rules.assert(goal);
    }
    var result = prover();
    // Seek a substitution into the result that yields the goal.
    var subst = result.alphaMatch(goal);
    // TODO: Check that substitutions exist, but don't actually do
    //   substitutions here.  Now rules.fact substitutes as needed to
    //   use the variables desired at each use.
    if (subst) {
      return rules.instMultiVars(result, subst);
    } else {
      // Try matching the main parts of the result and goal.
      // Reorder any assumptions as needed.
      var subst2 = result.getMain().alphaMatch(goal.getMain());
      if (subst2) {
        // The main parts match up to change of variables.
        // Conceivably the assumptions could have other free variables
        // that could still be reconciled, but we are not that
        // ambitious at present.
        var proved = (rules.instMultiVars(result, subst2)
                       .andThen('arrangeAsms'));
        if (proved.matches(goal)) {
          return proved;
        }
        let okAsms = true;
        // Check if the proved can match the goal by rearranging
        // assumptions.
        const goalAsms = goal.asmSet();
        const factAsms = proved.asmSet();
        if (!goalAsms.superset(factAsms)) {
          console.error('Fact requires unstated assumptions.',
                        '\nProved:', proved.toString(),
                        '\nStated:', goal.toString());
          okAsms = false;
        }
        if (!factAsms.superset(goalAsms)) {
          console.error(
            'Ignoring unneeded assumptions in the fact statement.',
            '\nProved:', proved.toString(),
            '\nStated:', goal.toString()
          );
          // This is a pretty innocuous issue so we let it pass.
          // okAsms = false;
        }
        if (okAsms) {
          // The assumptions can match if rearranged.
          return proved;
        }
      }
    }
    console.error(Toy.format('Instead of {1}\n proved {2}', goal, result));
    if (Toy.assertOnMismatch) {
      return rules.assert(goal);
    } else {
      abort('Proof mismatch');
    }
  }
  return factProverWrapper;
}


//// SOME DEFINITIONS

/**
 * Dumps out fact resolutions as a debugging aid.
 */
function dumpFactResolutions() {
  const map = _resolutionsByKey;
  map.forEach(function(list, k) {
      console.log('Key', k);
      let goal = null;
      list.forEach(function(resItem) {
          if (!goal) {
            goal = resItem.factInfo.goal;
            console.log('  fact ' + resItem.factInfo.goal);
          }
          const resInfo = resItem.resInfo;
          console.log('  from ' + resInfo.stmt);
          if (resInfo._expansion) {
            console.log('  as ' + resInfo._expansion);
          }
        });
    });
}

//// Export public names.

Toy.rules = rules;
Toy._factsByKey = _factsByKey;

Toy.factsExtending = factsExtending;
Toy.factExpansion = factExpansion;

// Settable variables, export right here:

// If true, facts are only proved when explicitly requested,
// as when displaying the proof, but not when used in another
// proof.  Matching never causes a fact to be proved.
Toy.assertFacts = false;

// Assert requested facts that don't match the result of the proof.  
// This can be temporarily set to true to work around failures
// of proofs that might obscure other bugs that need to be fixed.
Toy.assertOnMismatch = false;

Toy.getStepCounter = getStepCounter;
Toy.noSimplify = noSimplify;

Toy.declare = declare;
Toy.addRule = addRule;
Toy.definition = definition;
Toy.deferredDefnFacts = deferredDefnFacts;
Toy.enableDefnFacts = enableDefnFacts;
Toy.addDefnFacts = addDefnFacts;
Toy.resolveToFactInfo = resolveToFactInfo;
Toy.resolveToFact = resolveToFact;
Toy.addFact = addFact;
Toy.addFactsMap = addFactsMap;
Toy.isRecordedFact = isRecordedFact;
Toy.proveResult = proveResult;
Toy.getResult = getResult;
Toy.eachFact = eachFact;
Toy.getTheorem = getTheorem;
Toy.getResInfo = getResInfo;
Toy.convert = convert;
Toy.schemaPart = schemaPart;
Toy.findMatchingFact = findMatchingFact;
Toy.tryReduce = tryReduce;
Toy.applyFactsWithinSite = applyFactsWithinSite;
Toy.applyFactsWithinRhs = applyFactsWithinRhs;
Toy.applyMatchingFact = applyMatchingFact;
Toy.applyToFocalPart = applyToFocalPart;
Toy.repeatedly = repeatedly;
Toy.arrange = arrange;
Toy.arrangeRhs = arrangeRhs;
Toy.listFacts = listFacts;
Toy.transformApplyInvert = transformApplyInvert;
Toy.matchFactPart = matchFactPart;
Toy.searchForMatchingFact = searchForMatchingFact;
Toy.getRuleInfo = getRuleInfo;
Toy.getStepSite = getStepSite;
Toy.proofOf = proofOf;
Toy.assumptionsUsed = assumptionsUsed;

Toy.definition = definition;

Toy.basicSimpFacts = basicSimpFacts;

Toy.traceRule = traceRule;

Toy.buildHypSchema = buildHypSchema;
Toy.pathToConjunct = pathToConjunct;

// For communication between an action precheck and the rule's main
// action function.
Toy._actionInfo;

// For debugging.
Toy._statementResInfos = _statementResInfos;
Toy._resolutionsByKey = _resolutionsByKey;
Toy.dumpFactResolutions = dumpFactResolutions;

// For testing.
Toy._tautologies = _tautologies;
Toy._locateMatchingFact = _locateMatchingFact;
Toy._conjunctionSchema = conjunctionSchema;

})();
