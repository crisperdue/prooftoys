// Copyright 2011 - 2018 Crispin Perdue.
// All rights reserved.
//
// This file implements the logic, its axioms, basic theorems,
// inference rules and other machinery that is relatively
// independent of the problem domain.

// This could be organized as something like:
//
// Subcore: rules and theorems needed to prove the various facts
// about truth tables.
//
// Booleans: truth table facts and probably the tautology checker.
//
// Core: full replacement, cases, and other basics.
//
// Assumptions: management and simplification of assumptions.
//
// Facts: support for facts and rewriting.

// Set all of this up immediately upon load, but avoiding changes
// to the global environment (except through the "Toy" namespace).
(function() {

//// THEOREMS AND RULES

var assert = Toy.assertTrue;

//  Make some useful names available here.
var assertEqn = Toy.assertEqn;
var varify = Toy.varify;
var constify = Toy.constify;
var termify = Toy.termify;
var call = Toy.call;
var equal = Toy.equal;
var implies = Toy.implies;
var lambda = Toy.lambda;

var Expr = Toy.Expr;
var Atom = Toy.Atom;
var Call = Toy.Call;
var Lambda = Toy.Lambda;

var memo = Toy.memo;

// Predefine some common constants.
var T = constify('T');
var F = constify('F');

// Map from tautology string representation to tautology,
// for proved tautologies.  Private to the tautology rule.
var _tautologies = {};

// Interactive testing support.
window.Thtest = function(x) {
  setTimeout(function() { console.log(window.Tval = eval(x)); });
};


//
// Expr methods for inference
//

/**
 * Returns a shallow copy of this, annotating the copy with the rule
 * name, rule arguments, hasHyps flag, and dependencies (ruleName,
 * ruleArgs, ruleDeps).  "This" becomes the "details" property if it
 * already has a justification.  (Axioms, definitions and assertions
 * are not generated by rules, though theorems are.)  The ruleArgs and
 * ruleDeps arrays are both optional, empty if not given.
 *
 * If this is identical to one of its ruleDeps, returns this unchanged
 * unless "retain" is true, making the step a no-op.  (The purpose is
 * to reduce clutter for readers of the proof.)
 *
 * TODO: Make a Step class for proof steps, and have this method
 * return a new one.
 *
 * TODO: Consider always recording the step, but skipping the display
 * in proof.jsc.  Some steps, especially simplifications, do this
 * same thing internally by skipping the call to "justify".
 *
 * TODO: Add a "justify0" method that never modifies assumptions,
 * or alternatively, never "arrange" them here, leaving that task
 * to rules such as "replace".
 */
Expr.prototype.justify = function(ruleName, ruleArgs, ruleDeps, retain) {
  // Note: when splitting Step and Expr, make a version of this just
  // for rules.assert, and use that in any primitive inference rules.
  var ruleDeps = jQuery.makeArray(ruleDeps || []);
  if (!retain) {
    for (var i = 0; i < ruleDeps.length; i++) {
      if (ruleDeps[i] == this) {
        // If the step returns an input step, return it as-is.
        // TODO: Consider eliminating this "optimization" and rely instead
        //   on eliding no-op steps from display.  (There is already an
        //   implementation.)
        return this;
      }
    }
  }
  var step = this;
  // At this spot we could conditionally run arrangeAsms, but omitting
  // that automagic behavior for now.

  // Allocate a new object to be the new Step.
  var result = (step instanceof Call
              ? new Call(step.fn, step.arg)
              : step instanceof Atom
              ? new Atom(step.pname)
              // Impossible for a step!
              : null);

  // The beginnings of a Step class.  Only steps will have the
  // following properties, with .wff accessing the top expression
  // (wff).
  //
  // Note: Likely additional Step methods: freeVars. 
  result.wff = result;
  // TODO: The "rendering" (and also "original") property is quite
  //   sparse.  Consider eliminating "original" for non-rendered steps
  //   and storing "rendering" in a WeakMap.
  result.rendering = null;
  // Record the step as details.
  // Note that above, primitive rules have no deps.
  if (Toy.isProved(this)) {
    // Except for primitive rules listed just below.
    result.details = step;
  } else {
    switch(ruleName) {
    case 'assert':
    // TODO: "define" should not have to be a special case here.
    case 'define':
    case 'definition':
    case 'r':
      break;
    default:
      assert(false, 'Input to "justify" should be a step ({1})', step);
    }
  }
  // Give the new step the specified ruleName.
  result.ruleName = ruleName;
  // Make the step be its own original, for uniform access to an original.
  // TODO: Stop doing this, to distinguish StepDisplay objects from Steps.
  result.original = result;
  // Give this step its own new ordinal.
  result.ordinal = stepCounter++;
  // Carry other information forward.
  result.hasHyps = step.hasHyps;
  result.ruleArgs = jQuery.makeArray(ruleArgs || []);
  result.ruleDeps = ruleDeps;

  return result;
};

//
// Utility functions
//

/**
 * Process a value as a set of labels.  If it is a string, convert it
 * to an object/set by treating it as a space-separated list of words.
 */
function processLabels(labels) {
  switch(typeof labels) {
  case 'string':
    var result = {};
    labels.split(/\s+/)
      .forEach(function(label) { result[label] = true; });
    return result;
  case 'object':
    return labels;
  default:
    if (labels) {
      console.error('Bad labels', labels);
    }
    return {};
  }
}

// Used to order execution of proof steps so they can display
// in order of execution in an automatically-generated proof.
// This increments on every call to "justify".
// Conceptually it could be incremented just by rule R.
var stepCounter = 1;

function getStepCounter() {
  return stepCounter;
}

/**
 * A simplification function that does nothing, useful as the
 * auto-simplifier for rules that want to suppress simplification.
 */
function noSimplify(step) {
  return step;
}

/**
 * Adjusts a path to account for application of a typical rewrite rule
 * that could prefix the path with /right, given a step that is the
 * input to the rewrite and a step that is the result of the rewrite.
 *
 * This could give incorrect results currently in case the first step
 * is conditional but without hyps, but this will be correct when hyps
 * are gone.
 */
Toy.Path.prototype.adjustForRewrite = function(step1, step2) {
  return (!step1.isCall2('=>') && step2.isCall2('=>')
          ? Toy.path('/right').concat(this)
          : this);
};

/**
 * These become methods on steps, set up by Step.justify.
 */
var ruleMethods = {

  /**
   * Applies the named rule to this Expr and any other given arguments
   * as if by a call to Toy.rules[name](args).
   */
  andThen: function(name, arg1) {
    var nm = name;
    arguments[0] = this;
    var rule = Toy.rules[nm];
    assert(rule, 'No rule with name "{1}"', nm);
    var result = rule.apply(Toy.rules, arguments);
    return result;
  },
      
  /**
   * Applies rules.rewrite to this Expr passing in a path and
   * fact to use.
   */
  rewrite: function rewrite_method(path, fact) {
    return Toy.rules.rewrite(this, path, fact);
  },

  /**
   * Applies rules.replace to this Expr passing in a path and
   * equation to use.
   */
  rplace: function(path, eqn) {
    return Toy.rules.rplace(eqn, this, path);
  }
};
Expr.addMethods(ruleMethods);

// Caches (details of) results of rules.fact that are given a string
// as input, for performance of functions such as findMatchingFact.
// Used in rules.fact to quickly get the proof of a fact given as a
// string.  Not to be confused with _factsMap, which contains information
// about facts as they are stated, not as they are looked up.
var _factMap = {};

//
// Inference rules, axioms, theorems
//

// Map from rule name to function used in all proofs.
// This is a central global variable.
// Generated from ruleInfo by addRulesMap, below.
var rules = {};

/**
 * Given a ruleInfo object, add its information to the "rules" object.
 * The "rules" object maps from rule name to function.  Each function
 * has an "info" property containing all the properties present in the
 * ruleInfo object entry for the name.  If not supplied in the rule
 * definition, the info.inputs is defaulted to an empty object here.
 */
function addRulesMap(ruleInfo) {
  for (var key in ruleInfo) {
    var value = ruleInfo[key];
    if (value.constructor != Object) {
      console.warn('Old-style rule action', key);
    }
    var info = value.constructor == Object ? value : {action: value};
    if (info.ruleName) {
      console.warn('Property "ruleName" found for rule with key', key);
    }
    info.name = key;
    addRule(info);
  }
}

/**
 * Adds an array of rules (axioms and theorems/facts, named or not),
 * each in the form of a plain object with properties.  If a fact has
 * a name, the name appears as a "name" property.
 *
 * TODO: Convert addFactsMap to use this internally instead of addFact.
 */
function addRules(ruleList) {
  ruleList.forEach(addRule);
}

/**
 * Process the given info into form for inclusion into Toy.rules and
 * add the result there.  For details see the comments for ruleInfo.
 */
function addRule(info) {
  var name = info.name;
  if (name && rules[name]) {
    console.warn('Inference rule with name', name, 'already declared');
  }

  if (info.definition) {
    definition(info.definition);
    return;
  }

  var proof = info.proof;
  var statement = info.statement;
  // This will become the "rule object":
  var rule;
  // This will become the "main function" -- the action or proof property
  // with user-written code.
  var main;
  // True iff the main function has access to the rule object as "this".
  var mainHasThis = false;
  // If the rule (theorem) has an explicit statement (which should be
  // provably true), coerce the statement to an Expr if given as a
  // string.
  if (typeof statement === 'string') {
    statement = info.statement = Toy.mathParse(statement);
  }
  if (proof) {
    // The proof should have no arguments, and should not do its
    // own call to "justify".
    //
    // TODO: In the future, allow type parameters and memoize
    //   as appropriate.
    // TODO: Consider checking that "actions" _do_ have parameters.
    assert(typeof proof === 'function',
           'Proof of {1} should be a function', name);
    assert(proof.length == 0, 'Proof of {1} requires parameters', name);
    assert(!info.action, 'Both proof and action for {1}', name);
    // User-supplied proof function is the main.
    main = proof;
  }
  if (statement) {
    if (!proof) {
      // If there is a statement but no proof, just assert the statement.
      proof = function() {
        var result = rules.assert(statement);
        return (result.isCall2('=>')
                ? rules.asHypotheses(result)
                : result);
      }
      main = proof;
      if (!info.axiom) {
        if (typeof name !== 'string') {
          console.warn('No proof for', statement.$$);
        } else if (!name.startsWith('axiom')) {
          console.warn('No proof for', name);
        }
      }
    }
    // Add it as a fact also, and potentially "swapped".
    // A fact needs a statement, so we rely here on having a statement given.
    var factProps = {
      description: true,
      simplifier: true,
      desimplifier: true,
      noSwap: true,
      labels: true,
      converse: true
    };
    // Accept selected fact properties in the rule metadata.
    var properties = {goal: statement, proof: proof};
    for (var k in factProps) {
      if (k in info) {
        // Uncomment this for detailed tracing.
        // console.warn('Adding', k, 'to', name);
        properties[k] = info[k];
      }
    }
    addFact(properties);
    if (!properties.noSwap) {
      addSwappedFact(properties);
    }
  }
  if (proof) {
    // A statement or proof was given.
    // 
    // Don't rerun the proof every time, but do re-justify on each
    // call so each use will return a step with its own ordinal.
    rule = function() { 
      if (rule.result === undefined) {
        rule.result = proof();
        if (statement) {
          assert(rule.result.matches(statement),
                 'Failed to prove {1},\n  instead proved {2}',
                 statement, rule.result);
        }
      }
      return rule.result.justify(name, []);
    };
    // Describe theorems as "theorem" by default.
    // The theorem name will be added as ruleName into the tooltip.
    if (!('description' in info)) {
      info.description = 'theorem'
    }
  } else {
    // It is a rule of inference, not an axiom or theorem.
    assert(name, 'Inference rule must have a name', info);
    // The action property is the user code to run it.
    main = info.action;
    assert(typeof main === 'function',
           'Rule action must be a function: {1}', name);

    if (info.precheck) {
      // There is a precheck.
      var checker = function(_args) {
        return Toy._actionInfo = info.precheck.apply(main, arguments);
      }
      rule = function(_args) {
        checker.apply(null, arguments);
        return (Toy._actionInfo
                ? main.apply(rule, arguments)
                : info.onFail
                ? info.onFail.call(rule)
                : Toy.fail(Toy.format('Rule {1} not applicable', name)));
      }
      if (info.maxArgs == null) {
        info.maxArgs = main.length;
      }
      // Set properties on the outer action to give access to the
      // main from the the precheck.
      rule.precheck = checker;
      rule.main = main;
      // Assert that the main code has access to data and metadata
      // through "this".
      mainHasThis = true;
    }
  }

  // The following code applies to all rules, axioms, theorems and
  // inference rules.

  if (info.data) {
    // Set the "data" property of the outer action so the main
    // and precheck can access it.  If it is a function, call it
    // and use the result.
    if (typeof info.data === 'function') {
      info.data = info.data.call();
    }
    if (!mainHasThis) {
      // Make the outer action function available to the main
      // function as "this".
      rule = function(_args) {
        return main.apply(rule, arguments);
      };
      mainHasThis = true;
    }
    // Also make the data a property of "this".
    rule.data = info.data;
  }
  // Even if there is no wrapping, set up "rule".
  rule || (rule = main);

  // Set up remaining metatadata.

  // Give every info "inputs".
  if (!info.inputs) {
    info.inputs = {};
  }

  // Default the description to the marked up formula or the ruleName.
  if (!('description' in info)) {
    // The name could be undefined.
    info.description = name;
  }
  // Remember the basic tooltip
  info.basicTooltip = info.tooltip;

  // If there is a toOffer property with string value, coerce it
  // to a function of step and path.
  if (typeof info.toOffer === 'string') {
    info.toOffer = new Function('step, term', info.toOffer);
  }
  // Make the action function available here also as "this".
  if (typeof info.toOffer === 'function') {
    info.toOffer = info.toOffer.bind(rule);
  }

  info.labels = processLabels(info.labels);
  if (info.form !== undefined && Toy.isEmpty(info.labels)) {
    // Anything conceivably offerable (with a form), default to
    // "basic" if no other labels.
    info.labels.basic = true;
  }

  // Add all metadata as the function's "info" property.
  rule.info = info;
  
  if (name) {
    // Include the rule name in the tooltip.
    info.tooltip = Toy.format('{1} ({2})', (info.tooltip || ''), name);

    if (rule && rule.length === 0 && name.slice(0, 5) === 'axiom') {
      info.labels.axiom = true;
    }

    // Assign a name to the wrapper and main.
    if (rule !== main) {
      Object.defineProperty(rule, 'name',
                            {value: name + '_wrapper'});
      Object.defineProperty(main, 'name', {value: name});
    } else {
      Object.defineProperty(rule, 'name', {value: name});
    }

    // Finally install the rule into the rules.
    rules[name] = rule;
  }
}

/**
 * Add the given definition to the system.  It must define a named
 * constant that is not already defined.  The argument is a WFF that
 * will become true as the definition of the new constant.  The WFF
 * must contain a (free) occurrence of exactly one new constant name.
 * If it is of the form:
 *
 * <name> = <term>
 *
 * and <name> does not occur free in <term>, the equational definition
 * is accepted.
 *
 * If the definition has some other form, then there must be a
 * recorded fact of the form: exists {<var>. <condition2>}, where
 * <var> is a variable name that does not occur free in the condition,
 * and condition2 is the result of substituting <var> for <name> in
 * the condition.
 *
 * TODO: Perhaps appropriate top-level forms might be: "fact", "rule",
 * and "definition".  Each would just add its item to a global list,
 * perhaps even the same global list.  Additionally, the top-level
 * form might do some bookkeeping and report errors, at least for
 * definitions.  These can run at top-level in modules where the logic
 * is available.
 */
function definition(defn_arg) {
  var isRecorded = Toy.isRecordedFact;
  var definitions = Toy.definitions;
  var defn = termify(defn_arg);
  // Free occurrences of names of constants that do not have
  // definitions.
  var undefs = defn.undefNames();
  var undefList = Object.keys(undefs);
  assert(undefList.length > 0,
         'Definition {1}\n  needs a fresh constant name.', defn);
  assert(undefList.length === 1,
         'Definition {1} has multiple new constants {2}',
         defn, undefList.join(', '));
  var name = undefList[0];
  var defined = new Atom(name);
  if (defn.isCall2('=') &&
      defn.getLeft().matches(defined) &&
      Toy.isEmpty(defn.getRight().undefNames())) {
    // It is a classic equational definition.
    // Add it to the definitions database.
    definitions[name] = defn;
    addDefnFacts(defn);
  } else {
    // It is not a classic equational definition.
    var x = Toy.genVar('x', defn.allNames());
    // Substitute the fresh variable for the constant name.
    var body = defn.subFree1(x, name);
    var exists1 = Toy.call('exists1', Toy.lambda(x, body));
    if (isRecorded(exists1)) {
      // TODO: Add the fact that only one value has the property.
    } else {
      var exists = Toy.call('exists', Toy.lambda(x, body));
      assert(isRecorded(exists), 'Definition {1} needs an existence fact.', defn);
    }
    definitions[name] = defn;
    addFact({goal: rules.definition(name)});
  }
}

/**
 * This function only has effect for equational definitions
 * of the form <atom> = <term>.
 *
 * If it is a function definition (the term is a lambda), it generates
 * basic equational facts.  In other words if f = {x. <term>},
 * generates the fact f x = <term>, and so on if there are multiple
 * arguments.
 *
 * After unwrapping any lambdas, lIf the definition has one of the
 * specific forms:
 *
 * <name> = the <condition>; or
 * <name> = iota <condition>
 *
 * and if there is a recorded fact of the form exists1 <condition>, it
 * proves the additional fact that <condition>(<name>).  If there is a
 * recorded fact <precond> => exists1 <condition>, it proves a fact
 * that <precond> => <condition>(<name>).  If the definition uses
 * "the" rather than "iota", it proves [if <precond> then
 * <condition>(<name>) else null].
 *
 * Definitions of this kind using "the", or perhaps iota, will only go
 * through properly once basic logic with facts about quantifiers and
 * unique existence are in place.  This seems a reasonable
 * requirement.  Omitting the accompanying unique existence fact will
 * prevent the system from failing in its automatic proof.
 *
 * TODO: Consider supporting "the" better by using available facts
 *   that show when the needed exists1 property does and does not
 *   apply.
 *
 * TODO: Implement the <precond> support.  Consider extending this for
 *   additional cases TBD.
 */
function addDefnFacts(definition) {
  // This relies on having applyBoth and simpleApply available whenever
  // a function is defined.
  if (definition.isCall2('=') && definition.getLeft() instanceof Atom) {
    var defined = definition.getLeft();
    var name = defined.name;
    var eqn = definition;
    var lambda = definition.getRight();
    while (lambda instanceof Lambda) {
      var bound = lambda.bound;
      eqn = (rules.applyBoth(eqn, bound)
             .andThen('simpleApply', '/right'));
      lambda = eqn.getRight();
    }
    // TODO: Consider adding a fact unconditionally, and treating
    //   it automatically as a desimplifier.
    if (eqn != definition) {
      addFact({goal: eqn});
      addSwappedFact({goal: eqn});
    }
    // From here on, if the remaining RHS is a "the" or "iota", and
    // there is an appropriate "exists1" fact for its property, we
    // generate a fact that having the described property is
    // equivalent to being the value of the RHS.
    var rhs = eqn.getRight();
    if (rhs.isCall1('the') || rhs.isCall1('iota')) {
      // The definition looks like <name> = the . . .
      // Add the standard fact for definitions of this kind.
      var condition = rhs.arg;
      var ex1 = Toy.call('exists1', condition);
      if (isRecordedFact(ex1)) {
        var step = rules.fact(ex1);
        var step1 = (rhs.isCall1('iota')
                     ? rules.rewriteOnly(step, '/rt/right', 'exists1The')
                     : step);
        var v = step1.get('/rt/arg/bound');
        var ex2 = (rules.exists1Forall()
                   .andThen('instForall', '/right', v));
        var step2 = (step1.wff.isCall2('=>')
                     ? rules.forwardChain2(step1, ex2)
                     : rules.forwardChain(step1, ex2));
        var result = (rules.simpleApply(step2, '/right/left')
                      .rewrite('/rt/right/right', rules.eqnSwap(eqn)));
        // Add the key fact for this definition, equivalence between being
        // equal to the new constant and having its property.
        console.info('For', name, 'adding fact', result.toString());
        addFact({goal: result});
      } else {
        const v = (condition instanceof Lambda
                   ? condition.bound
                   : termify('x'));
        const e1 = rules.consider('v = t == p v');
        const map = {v: v, t: eqn.getLeft(), p: condition};
        const e2 = rules.instMultiVars(e1, map);
        const e3 = (condition instanceof Lambda
                    ? rules.simpleApply(e2, '/right/right')
                    : e2);
        const goal = e3.getRight();
        console.warn('For definition', definition.toString());
        console.warn('  no recorded fact', ex1.toString());
        console.warn('  so not concluding', goal.toString());
      }
    }
  }
}


//// Support for adding facts

/**
 * Treats each key in the map as a synopsis of a mathematical
 * statement, and treats its value as a function to prove the
 * statement.  Uses addFact to add each statement and its proof
 * function to the internal database of provable facts.
 */
function addFactsMap(map) {
  for (var synopsis in map) {
    var info = map[synopsis];
    info.synopsis = synopsis;
    addFact(info);
    if (!info.noSwap) {
      addSwappedFact(info);
    }
  }
}

// Object / set of property names supported in fact info data, used
// for validation of fact properties.  See addFact.
var factProperties = {
  goal: true,
  synopsis: true,
  proof: true,
  simplifier: true,
  desimplifier: true,
  noSwap: true,
  labels: true,
  description: true,
  converse: true
};

/**
 * Adds an entry to the facts database given information in the format
 * of fact entries in facts maps, assuming here that the synopsis is
 * already added to the info as a synopsis property.  Can use the
 * synopsis property to generate a goal and the proof property as the
 * prover.
 *
 * Currently recognizes input properties as follows:
 *
 * goal: if present, can generate the synopsis; if proved, becomes
 *   the proved result, and any proof function will be ignored,
 *   otherwise a WFF.
 * synopsis:  string for input to mathParse.  Must parse to a
 *   complete statement of the fact, to be used as the goal.
 * proof: function to return the proved fact, matching the goal.
 *   If not present, one will be generated to assert the goal.
 * description: string or function as for a rule description.
 * simplifier: true iff this fact is a simplifier.
 * desimplifier: true iff this fact is the "converse" of a simplifier.
 * labels: Object/set of label names, if given as a string, parses
 *   space-separated parts into a set.
 * converse.labels: Like labels, but applies to a "swapped" version
 *   of the fact, if any.
 *
 * TODO: Extend this and/or add other functions to add facts based
 *   on other information such as an already-proved statement.
 */
function addFact(info) {
  for (var key in info) {
    if (!(key in factProperties)) {
      var id = info.goal ? info.goal.$$ : info.synopsis;
      console.warn('In fact', id, 'extra info key:', key);
    }
  }
  info.proved = info.goal && info.goal.isProved() && info.goal;
  // The goal is a rendered Expr just because that makes a complete
  // copy that can be properly annotated with types.
  // TODO: Use expandSynopsis here.
  info.goal = (info.goal ||
               Toy.mathParse(info.synopsis)).copyForRendering(null);
  info.synopsis = info.synopsis || info.goal.toString();
  // Annotate the new goal with type info for type comparison
  // with portions of steps in the UI.
  //
  // Careful: It is very doubtful whether annotated structures can be
  // shared as part of any other steps or Exprs.
  info.goal.annotateWithTypes();
  if (!info.proved) {
    info.prover = asFactProver(info.proof, info.goal);
  }
  // Set to true when starting to attempt a proof, then
  // to false when the proof succeeds.
  info.inProgress = false;
  info.labels = processLabels(info.labels);
  if (isRecordedFact(info.goal)) {
    console.info('Fact', info.goal.$$, 'already recorded, skipping.');
  } else {
    if (info.simplifier) {
      basicSimpFacts.push(info.synopsis);
    }
    setFactInfo(info);
  }
  return info;
}

/**
 * Add the "converse" of an equational fact if it is not already
 * recorded.  Determines the statement from the info's goal.  If it is
 * an equation, switches its LHS and RHS, otherwise does nothing.
 *
 * If the fact to be swapped is a simplifier or desimplifier, the
 * newly-created fact will be appropriately labeled as the opposite.
 */  
function addSwappedFact(info) {
  var stmt = info.goal;
  if (stmt.isEquation()) {
    var swapped = Toy.commuteEqn(stmt);
    if (!isRecordedFact(swapped)) {
      function proof() {
        return rules.fact(stmt).andThen('eqnSwap');
      }
      var labels2 = processLabels(info.converse && info.converse.labels);
      var info2 = {proof: proof,
                   goal: swapped,
                   simplifier: !!info.desimplifier,
                   desimplifier: !!info.simplifier,
                   description: info.description,
                   labels: labels2
      };
      addFact(info2);
    }
  }
}

// ruleInfo:
//
// This is structured as a map from the name of an inference rule or
// theorem to properties of the rule or theorem.
//
// Properties here for each name are as follows.  These properties are
// available directly when calling addRule.  In that case, pass "name"
// as a property along with the others.  When calling addRule, unnamed
// facts and definitions are also supported through the properties.
//
// action: function implementing the inference rule.
//
// proof: for a theorem (no args), use this instead of "action".
//   Do not call "justify", that is done automatically and
//   the proof is memoized.
//
// name: name of the rule, axiom or theorem; required if it is a rule
//   of inference with one or more arguments (see below).  Used to
//   look up the rule in "rules".
//
// statement: for a theorem, this string optionally states the theorem
//   proved.  In this case the theorem is also added as a fact.  If
//   the value is an equation, with or without assumptions, if its
//   converse is not already added when the theorem is added, its
//   converse will be added as a fact.  Also used by tests.  TODO:
//   Consider checking during actual proof of the theorem.
//
// definition: for a definition, this is a statement, often of the
//   form <name> = <term>, that defines the new constant name.  Once
//   the definition is made, this statement is taken as true, as if it
//   were a new axiom, but without danger of creating a contradiction.
//   Other forms can also be used as definitions if justifying facts
//   are proved.  See the function "definition" for more details.
//   
// precheck: if present, a function that must accept the same
//   arguments as the main action.  When the rule action is called, it
//   will call this automatically, followed immediately by the
//   declared action function.  The RuleMenu uses it as well, to rule
//   out inapplicable rules.
//
//   This is expected to return a falsy value if the rule is not
//   applicable to the arguments, in which case the rule will fail
//   with Toy.fail.  Otherwise it should return any data useful to the
//   main action function, which will have access to that result
//   through the global temporary Toy._actionInfo.
//
//   To call the precheck directly, refer to rules.<rulename>.precheck.
//   A call to rules.<rulename>.main will automatically receive the
//   precheck's result information if called before any other rule or
//   precheck.
//
// onFail: if a rule's action function is called in the ordinary manner,
//   and it has precheck, and the precheck fails, then its onFail
//   action will run with access to the same arguments and access
//   to the rule object as "this".
//
// inputs: map from type to argument number(s), either a single
//   number or an array if more than one such argument.
//   The supported types are:
//     step: Matches any proof step.
//     equation: Matches a proof step that is an equation.
//     implication: Matches a proof step that is an implication.
//     term: Matches any term.
//     reducible: Matches a call to anonymous function (lambda)
//     varName: Name suitable for a variable.
//     string: Arbitrary nonempty string.
//     optString: Optional arbitrary string.
//     site: Term in a step; the rule expects the term's step and path
//       to the term as inputs.
//     bindingSite: Matches a variable binding in a step (as in "changeVar").
//
// TODO: Consider defining a new form of input descriptor.  Every rule
//   with the new property would be a "fancy" rule whose action
//   function has the appropriate name, that automatically converts
//   its inputs based on its input descriptor.  For each of these
//   define a rule 'fast_' + name to be the simplest form.
//
// data: If a rule has a "data" property, set rules[ruleName] to a new
// function that binds "this" to the rule's action function, and set
// up the "data" object as the "data" property of the action function.
//
// minArgs: Number of required args for the action.  Supply a
//   value here to make trailing arguments optional in the step editor.
//
// maxArgs: Optional maximum number of args to pass to the rule.
//   Unless already present, added automatically by addRule when
//   making a rule with a "varargs" wrapper.
//
// toOffer: function of step and optional term or string with
//   suitable body for such a function.  If it returns false
//   the rule is not offered in the step editor.
//
// form: HTML template for the rule's input form to be presented by
//   the step editor, as a template allowing {term} for the selected
//   term.  StepEditor will never offer a rule without a form
//   property, at least an empty one.
//   TODO: Separate out this kind of non-offerability.
//
// menu: plain text for the rule's menu item (may become HTML in the future),
//   as a template allowing {term} for the selected term or {right}
//   for a possible term to its right ("group with").
//
// menuGen: function to return zero or more menu entries for
//   application(s) of the rule.  It will be passed the ruleName,
//   step, selected term or null if none, and the ProofEditor for which
//   it is generating the menu.  A falsy value indicates no
//   menu entries; a non-empty string is for one entry.
//
// tooltip: plain text to become the title attribute of mentions of the
//   rule name in proof displays and the description in subproof displays.
//
// result: For theorems with no parameters only; this is the statement
//   of the theorem.  If given as text in ruleInfo, converted into an
//   expression in "rules".
//
// description: HTML word or phrase for use in one-line description,
//   or function to compute it, as in rules.fact.  If beginning with
//   "=", name of a "step formatter" in stepFormatters follows.
//   Either sort of function receives the step as argument.
//
// isRewriter: true to highlight on hover like a rewrite rule.
//   TODO: Consider removing this as unnecessary.
//
// using: if present, normally the equation or implication used for
//   the rule, as for rewriters.  The equation may have conditions.
//   When working forward the left side of the main equation must
//   match the site to be operated on.
//
// inputSide: may be 'right' to indicate that the rule uses
//   the converse equality (rewrites matching the right side of the
//   equation rather than the left side).
//
// offerExample: applies to rules only, not facts.  If true and the
//   rule needs only some sort of selection as input, the step
//   suggester will run it to generate a sample next step and the
//   ruleMenu will not include it in the menu.
//

// Rule definitions that have statements (and are thus theorems)
// support the same properties as facts, specifically: simplifier,
// desimplifier, noSwap, labels, and converse (for properties of facts
// that have a swapped version).

// Conventions for menu items (using "menu:")
// Step templates are in square brackets, such as [T = A].
// Rules (including axiom 4) that take a term as input use A, B to
//   show where the term goes, not enclosed in square brackets.

var ruleInfo = {

  /**
   * The name "assertion" is used in displays to indicate that
   * the result of the inference is an assertion.  If given a string,
   * parses it and uses the result as its input.
   */
  assert: {
    action: function(assertion_arg) {
      var assertion = termify(assertion_arg);
      return assertion.justify('assert', [assertion]);
    },
    inputs: {bool: 1},
    form: ('Assert <input name=bool>'),
    menu: 'assert without proof',
    labels: 'advanced',
    description: 'assert',
    tooltip: 'WFF to assert (possibly to prove later)'
  },

  define: {
    action: function(name, definition) {
      Toy.define(name, definition);
      var defn = rules.definition(name);
      addDefnFacts(defn);
      return defn;
    },
    inputs: {string: 1, term: 2},
    form: ('Define name <input name=string> as <input name=term>'),
    menu: 'define a name',
    // TODO: Consider offering to define a name for the selected term
    //   if circumstances are appropriate.
    // Currently does not offer to define a name if there is any
    // selection.
    toOffer: 'return step == null',
    description: 'define {string}',
    tooltip: 'define a name'
  },

  /**
   * Suppose the given statement to be true.  This is the standard
   * way to introduce hypotheses into proofs.  If given a string,
   * parses it and uses the result.
   */
  assume: {
    action: function(assumption) {
      assumption = termify(assumption);
      var step = rules.tautInst('a => a', {a: assumption});
      // Flag the step as one with hypotheses, and record this step as
      // the source of the assumption.
      var result = rules.asHypotheses(step).justify('assume', arguments);
      assumption.sourceStep = result;
      return result;
    },
    inputs: {bool: 1},
    form: ('Assume <input name=bool>'),
    menu: 'assume',
    tooltip: 'Statement to assume',
    description: 'assumption',
    labels: 'basic'
  },

  /**
   * Suppose the given statement to be true.  The UI will display the
   * statement in each step where it occurs, even though it is among
   * the assumptions.
   */
  assumeExplicitly: {
    action: function(asm_arg) {
      var assumption = termify(asm_arg);
      var step = rules.tautInst('a => a', {a: assumption});
      return step.justify('assumeExplicitly', arguments);
    },
    inputs: {bool: 1},
    form: ('Assume <input name=bool>'),
    menu: 'assume temporarily',
    tooltip: 'Statement to assume (show occurrences)',
    description: 'temporary assumption',
    labels: 'basic'
  },

  copy: {
    action: function(step) {
      // Always make a new step, that is the point.
      return step.justify('copy', arguments, [step], true);
    },
    inputs: {step: 1},
    description: 'copy;; {of step step}'
  },

  /**
   * From an implication or equivalence, derives a step with the LHS
   * as its hypotheses, and the same RHS.  Result is always an
   * implication.
   */
  asHypotheses: {
    action: function(step) {
      step.assertCall2();
      var op = step.wff.getBinOp().pname;
      var step1 = ((op in {'=': true, '==': true})
                   ? rules.forwardChain(step, '(a == b) => (a => b)')
                   : step);
      step1.assertCall2('=>');
      // Always make a new step so we can mark it hasHyps.
      var result = step1.justify('asHypotheses', arguments, [step], true);
      result.hasHyps = true;
      return result;
    },
    inputs: {implication: 1},
    form: ('Convert implication to hypotheses in step '
           + '<input name=implication>'),
    menu: 'convert to hypotheses',
    description: 'convert to hypotheses;; {in step implication}',
  },

  /**
   * Converts a wff with hypotheses to an implication.  If there are
   * no hypotheses, returns its input unchanged.  Rendering displays
   * the result of this in its entirety.
   *
   * TODO: Rename to something like displayAll. 
   */
  asImplication: {
    action: function(step) {
      // Always make a new step so we can mark it as not hasHyps.
      var result = step.justify('asImplication', arguments, [step], true);
      // This is the primitive rule that sets hasHyps to false.
      result.hasHyps = false;
      return result;
    },
    inputs: {step: 1},
    form: ('Convert hypotheses to explicit implication in step '
           + '<input name=step>'),
    tooltip: 'assumptions explicit',
    description: 'assumptions explicit;; {in step step}',
    labels: 'algebra basic'
  },

  /**
   * A no-op step that breaks the cycle of displaying with elision.
   */
  display: {
    action: function(step) {
      // Force "justify" to not ignore this step.
      return step.justify('display', arguments, [step], true);
    },
    inputs: {step: 1},
    form: ('Does nothing, but result will display in full. '
           + '<input name=step>'),
    tooltip: 'show full equation',
    description: 'show full equation;; {in step step}',
    labels: 'display basic'
  },
      
  /**
   * Refer to a theorem by name, for the UI.  Inline.
   *
   * TODO: Consider adding a rule that takes a ruleName as an
   *   argument, also for the UI.
   */
  theorem: {
    action: function(name) {
      assert(rules[name], 'No theorem named {1}', name);
      assert(rules[name].length == 0,
             'Rule needs argument(s): {1}', name);
      return rules[name]();
    },
    inputs: {string: 1},
    form: ('Look up theorem named <input name=string>'),
    menu: 'look up a theorem by name',
    tooltip: (''),
    description: 'theorem',
    labels: 'basic'
  },

  /**
   * Refer to a definition in the definitions database.  If the
   * definition is by cases, takes a second argument of T or F
   * as desired.  Throws an exception if not found.
   */
  definition: {
    action: function(name, tOrF) {
      // The derivations are computed in advance, and have the name or
      // name and true/false as the argument(s).
      var args = arguments.length == 1 ? [name] : [name, tOrF];
      return Toy.getDefinition(name, tOrF).justify('definition', args);
    },
    inputs: {string: 1, optString: 2},
    form: ('Definition of <input name=string> '
           + 'if by cases enter T or F <input name=optString>'),
    menu: 'look up a definition',
    tooltip: 'look up a definition',
    description: '=definition'
  },

  /**
   * Replace the subexpression of the target at the path with the
   * equation's RHS.  This is rule R.  The subexpression must match
   * the equation's LHS, meaning they are the same except possibly
   * in names of vound variables.
   *
   * Extended to work with hypotheses by flagging the result with
   * hypotheses in case the target has them and the result is also
   * a conditional.
   */
  r: {
    action: function(equation, target, path) {
      path = Toy.path(path, target);
      assert(equation.isCall2('='), 'Rule R requires equation: {1}', equation);
      if (equation.getLeft().sameAs(equation.getRight())) {
        // The equation LHS must "match" the site, but can differ in
        // bound variables, so the replacement can only be a no-op if
        // these are identical too.  (This is a cheap but not
        // complete check for a no-op.)
        if (target.get(path).sameAs(equation.getLeft())) {
          // Quick return if the replacement is a no-op.
          return target.justify('r', [equation, target, path],
                                [target, equation]);
        }
      }
      // Logs the location of the test where autoAssert is used.
      function logWhere(term) {
        var e = new Error();
        var lines = e.stack.split('\n');
        // Note that the follwing regex may be Chrome-specific.
        function test(line) { return line.match(/Object.test/); }
        var where = lines.find(test) || 'at unknown location';
        console.warn('Asserting', term.$$, where);
      }
      function replacer(expr) {
        if (expr.matches(equation.getLeft())) {
          return equation.getRight();
        } else {
          assert(false,
                 'Rule R: subexpression {1}\n of {2}\n must match {3}',
                 expr, target, equation.getLeft());
        }
      }
      // Auto-justify input steps if requested by the current configuration.
      if (!equation.isProved()) {
        if (Toy.autoAssert) {
          logWhere(equation);
          equation.assert();
        } else {
          assert(false, 'Rule R unproven equation: {1}', equation);
        }
      }
      if (!target.isProved()) {
        if (Toy.autoAssert) {
          logWhere(target);
          target.assert();
        } else {
          assert(false, 'Rule R unproven target: {1}', target);
        }
      }
      var result = target.replaceAt(path, replacer);
      var lvars = equation.getLeft().freeVars();
      // TODO: Review this assumption.  It appears we really should
      // compare the set of constraints generated by the two sides.
      //
      // If the right side has any free names not in the left side,
      // the result may have constraints not met by the target, so
      // typecheck it.
      var rvars = equation.getRight().freeVars();
      for (var name in rvars) {
        if (!(name in lvars)) {
          Toy.findType(result);
          break;
        }
      }
      var justified = result.justify('r', [equation, target, path],
                                     [target, equation], true);
      justified.hasHyps = target.hasHyps && justified.isCall2('=>');
      justified.details = null;
      return justified;
    },
    inputs: {equation: 1, site: 2},
    // Currently not offered in forms; use "replace".
    // form: ('Replace selection with right side of step <input name=equation>'),
    tooltip: ('Replace an occurrence of a term with an equal term.'),
    menu: 'replace {term} with something equal',
    description: 'replace {site};; {in step siteStep} {using step equation}',
    labels: 'uncommon'
  },

  axiom1: {
    statement: 'g T & g F == forall {a. g a}',
    inputs: {},
    form: '',
    description: 'axiom of T & F',
    tooltip: ('T and F are all the booleans')
  },

  axiom2: {
    statement: 'x = y => h x = h y',
    inputs: {},
    form: '',
    description: 'axiom of function application',
    tooltip: ('functions take equal values to equal values')
  },

  /**
   * Axiom 2 specialized for predicates.  This is actually more like
   * Andrews' axiom 2.
   */
  axiom2a: {
    statement: 'x = y => (p x == p y)',
    action: function() {
      var step1 = rules.instVar(rules.axiom2(), 'p', 'h');
      var step2 = rules.eqIsEquiv();
      var result = rules.replace(step1, '/right/binop', step2);
      return result.justify('axiom2a');
    },
    inputs: {},
    form: '',
    description: 'axiom of predicate application',
    tooltip: ('predicates take equal values to the same truth value')
  },

  axiom3: {
    statement: '(f = g) == forall {x. f x = g x}',
    labels: 'higherOrder',
    converse: {labels: 'higherOrder'},
    inputs: {},
    form: '',
    tooltip: ('extensionality: functions are equal based on equal results'
              + ' on all inputs.'),
    description: 'axiom of equal functions'
  },

  /**
   * Generates an instance of Axiom 4 from an application of a lambda
   * expression to an argument expression, returning a term that
   * expresses the equality of the input and its beta reduction.
   */
  axiom4: {
    action: function(call) {
      call = typeof call == 'string' ? Toy.parse(call) : call;
      assert(call.isOpenCall(),
             'Axiom 4 needs ({v. B} A), got: {1}', call.toString());
      var lambda = call.fn;
      var result =
        (call.arg.name === lambda.bound.name
         // In this case the substitution will have no effect,
         // though subFree might incidentally rename the bound variable.
         ? equal(call, lambda.body)
         : equal(call, lambda.body.subFree1(call.arg, lambda.bound.name)));
      // Always make sure the call has a type.  It came from elsewhere.
      Toy.findType(call);
      return rules.assert(result).justify('axiom4', [call]);
    },
    labels: 'primitive',
    inputs: {term: 1},  // Specifically a Call to a Lambda.
    form: 'Enter {v. body} expr <input name=term>',
    menu: 'apply a lambda to its argument',
    description: 'axiom of substitution',
    tooltip: ('')
  },

  axiom5: {
    statement: 'iota {x. x = y} = y',
    inputs: {},
    form: '',
    tooltip: ('axiom of description'),
    description: 'axiom of description',
    simplifier: true
  },

  // Definition of F, for book-style proofs.
  defFFromBook: {
    statement: 'F = forall {x. x}',
    axiom: true,
    action: function() {
      return rules.assert('F = forall {x. x}').justify('defFFromBook');
    }
  },

  // Book only.
  defAnd: {
    statement: '(&) = {x. {y. ({g. (g T T)} = {g. (g x y)})}}',
    axiom: true,
    action: function() {
      return (rules.assert('(&) = {x. {y. {g. g T T} = {g. g x y}}}')
              .justify('defAnd'));
    }
  },

  // Book only.
  defImplies: {
    statement: '(=>) = {x. {y. (x == (x & y))}}',
    axiom: true,
    action: function() {
      return (rules.assert('(=>) = {x. {y. x == x & y}}')
              .justify('defImplies'));
    }
  },

  //
  // Theorems and rules of inference.
  //

  // Takes an arbitrary expression A, concluding that it is equal
  // to itself. (5200)
  eqSelf: {
    action: function(a) {
      a = termify(a);
      var step1 = rules.axiom4(call(Toy.parse('{x. x}'), a));
      var result = rules.r(step1, step1, '/left');
      return result.justify('eqSelf', arguments);
    },
    inputs: {term: 1},
    form: 'Term to prove equal to itself: <input name=term>',
    menu: 'A = A',
    tooltip: 'Derives A = A.',
    description: 'A = A',
    labels: 'primitive'
  },

  // Consider a term that we may wish to rewrite.  Functionally
  // the same as eqSelf, but display is handled specially.
  consider: {
    action: function(term_arg) {
      term = termify(term_arg);
      var copy = term.copyForRendering(null);
      copy.annotateWithTypes();
      if (copy.isBoolean()) {
        var step = rules.equivSelf(term);
      } else {
        var step = rules.eqSelf(term);
      }
      return step.justify('consider', arguments);
    },
    inputs: {term: 1},
    form: 'Term to consider: <input name=term>',
    menu: 'consider a term to transform',
    toOffer: 'return step == null',
    tooltip: ('consider a term to transform'),
    description: 'consider',
    labels: 'basic'
  },

  // Like "consider", but for formulas (boolean-valued terms)
  // Special case: this is only offerable if there are no steps
  // already in a proof.
  given: {
    action: function(term) {
      term = termify(term);
      var step = rules.equivSelf(term);
      return step.justify('given', arguments);
    },
    inputs: {term: 1},
    form: 'Formula to take as given: <input name=term>',
    menuGen: function(ruleName, step, term, proofEditor) {
      // This rule is only available if the proof is currently empty.
      return (proofEditor.proofDisplay.steps.length == 0
              ? ['problem to solve (givens)']
              : null);
    },
    tooltip: ('statement to take as given'),
    description: 'given',
    labels: 'algebra basic'
  },

  // Similar to "consider", but uses a selected term.
  considerPart: {
    action: function(step, path) {
      return rules.consider(step.get(path)).justify('considerPart', arguments);
    },
    inputs: {site: 1},
    form: '',
    menu: 'consider {term} in isolation',
    tooltip: ('prepare to transform term'),
    description: 'term equal to itself',
    labels: 'display'
  },

  // The two forms of "=" are interchangeable (other than precedence).
  eqIsEquiv: {
    statement: '(=) = (==)',
    proof: function() {
      var step1 = rules.eqSelf(Toy.constify('='));
      var step2 = rules.eqSelf(Toy.constify('=='));
      return rules.r(step2, step1, '/right');
    },
    form: '',
    tooltip: '= and \u21d4 are the same',
    labels: 'uncommon'
  },

  // Given A, proves A == A.  This is intended for use only when
  // A is boolean.
  equivSelf: {
    action: function(a) {
      var step1 = rules.eqSelf(a);
      var eqn = rules.theorem('eqIsEquiv');
      var result = rules.r(eqn, step1, '/binop');
      return result.justify('equivSelf', []);
    },
    inputs: {bool: 1},
    form: 'Statement to prove equal to itself: <input name=bool>',
    menu: 'A \u21d4 A',
    tooltip: 'Derives A \u21d4 A.',
    description: 'A \u21d4 A',
    labels: 'primitive'
  },

  // TODO: Make all forms of r5201 work with conditionals rather
  //   than hypotheses.

  // r5201a is not implemented.  It would be ambiguous in case the
  // "whole" is a conditional.  Use rules.replaceT instead.

  // r5201b, works with conditionals.
  eqnSwap: {
    action: function(h_ab) {
      var ab = h_ab.getMain();
      var op = ab.getBinOp().pname;
      var aa = (op === '=='
                ? rules.equivSelf(ab.getLeft())
                : op === '='
                ? rules.eqSelf(ab.getLeft())
                : assert(false, 'Must be an equiv/equation: {1}', ab));
      var ba = rules.replace(aa, '/main/left', h_ab);
      return ba.justify('eqnSwap', arguments, arguments);
    },
    inputs: {equation: 1},
    form: 'Swap sides in step <input name=equation>',
    menu: '[a = b] to [b = a]',
    tooltip: 'from a = b deduce b = a',
    description: '[a = b] to [b = a]',
    labels: 'basic algebra'
  },

  // r5201c.  Works with conditionals.
  eqnChain: {
    action: function(ab, bc) {
      var ac = rules.replace(ab, '/rt/right', bc);
      return ac.justify('eqnChain', arguments, arguments);
    },
    description: '[a = b] and [b = c] to [a = c]',
    menu: '[a = b] and [b = c] to [a = c]',
    tooltip: 'from a = b and b = c deduce a = c'
  },

  // r5201d, not used.  The current form only works with plain equations.
  applyBySides: {
    action: function(ab, cd) {
      var a = ab.getLeft();
      var b = ab.getRight();
      var c = cd.getLeft();
      var d = cd.getRight();
      var ac = call(a, c);
      var acac = rules.eqSelf(ac);
      var acbc = rules.rplace(ab, acac, '/right/fn');
      var acbd = rules.rplace(cd, acbc, '/right/arg');
      var result = acbd;
      return result.justify('applyBySides', arguments, arguments);
    },
    inputs: {equation: [1, 2]}
  },

  // r5201e.  Works with conditionals.
  applyBoth: {
    action: function(eqn, a) {
      var step1 = rules.eqSelf(call(eqn.eqnLeft(), a));
      var step2 = rules.replace(step1, '/right/fn', eqn);
      return step2.justify('applyBoth', arguments, [eqn]);
    },
    inputs: {equation: 1, term: 2},
    form: ('Apply both sides of step <input name=equation>'
           + ' to term <input name=term>'),
    menu: '[f = g] to [f x = g x]',
    tooltip: 'given f = g, deduce (f x) = (g x)',
    description: '[f = g] to [f x = g x]',
  },

  // r5201f.  Works with a conditional equation.
  // If f is a lambda expression, also applies it to both sides.
  applyToBoth: {
    action: function(f_arg, ab) {
      var f = termify(f_arg);
      var fafa = rules.eqSelf(call(f, ab.eqnLeft()));
      var fafb = rules.replace(fafa, '/right/arg', ab);
      var result = fafb;
      if (f instanceof Toy.Lambda) {
        var step2 = rules.apply(fafb, '/main/left');
        var result = rules.apply(step2, '/main/right');
      }
      return result.justify('applyToBoth', arguments, [ab]);
    },
    inputs: {term: 1, equation: 2},
    form: ('Apply function <input name=term>'
           + ' to both sides of step <input name=equation>'),
    menu: '[a = b] to [f a = f b]',
    tooltip: 'given a = b deduce (f a) = (f b)',
    description: 'from a = b to (f a) = (f b)'
  },

  // Apply a function of 2 args to each side of the given equation,
  // with the side of the equation as first argument and the given
  // term as second argument, resulting in a call to the function
  // with the equation side as first argument and the given
  // second argument.
  // 
  // Works with a conditional equation.
  applyToBothWith: {
    action: function(a_b, f_arg, c_arg) {
      var f = Toy.constify(f_arg);
      var c = termify(c_arg);
      var fn = call(call(termify('{f. {y. {x. f x y}}}'), f), c);
      return (rules.applyToBoth(fn, a_b)
              .andThen('simpleApply', '/rt/right/fn/fn')
              .andThen('simpleApply', '/rt/right/fn')
              .andThen('simpleApply', '/rt/right')
              .andThen('simpleApply', '/rt/left/fn/fn')
              .andThen('simpleApply', '/rt/left/fn')
              .andThen('simpleApply', '/rt/left')
              .justify('applyToBothWith', arguments, [a_b]));
    },
  },

  // Use the definition of the name at the given location in the given
  // step.  If the definition is by cases the location should be a
  // call to the named function, with T or F as the argument.
  // For the benefit of the UI, if the path is to a call, uses
  // the definition of the named function of the call, even if there
  // is more than one argument, by descending into fn parts.
  //
  // TODO: Fix bug here that A != B does not become not (A = B).
  useDefinition: {
    precheck: function(step, path) {
      var term = step.get(path);
      var fn = term.funPart();
      // The fn could be a Lambda, which is not defined.
      // This returns falsy if the function is an "unused" constant.
      return (fn instanceof Atom && Toy.isDefined(fn.name));
    },
    action: function(step, path) {
      var args = [step, path];
      path = Toy.path(path, step);
      var result;
      var target = step.get(path);
      // Undefined if the path refers to an Atom.
      var parent;
      var parentPath;
      // Descend to the named function, even if multiple arguments.
      while (target instanceof Call) {
        parentPath = parentPath ? parentPath.concat('/fn') : path;
        parent = target;
        target = target.fn;
      }
      // At this point the parent (if defined) is a Call.
      // The parentPath is path to the parent if any.
      assert(target instanceof Atom, 'Not a symbol: {1}', target);
      if (Toy.isDefinedByCases(target)) {
        assert(parent, 'To use a definition by cases, refer to a call.');
        result = rules.rplace(rules.definition(target.name, parent.arg),
                               step, parentPath);
      } else {
        result = rules.rplace(rules.definition(target.name), step,
                               parentPath ? parentPath.concat('/fn') : path);
      }
      return result.justify('useDefinition', args, [step]);
    },
    inputs: {site: 1},
    form: '',
    menu: 'replace name with its definition',
    tooltip: (''),
    description: 'definition of {site}'
  },

  // Just applies an anonymous lambda to an argument at the
  // specified location in a step.
  simpleApply: {
    action: function(step, path) {
      // Note that axiom 4 checks validity of its argument.
      var equation = rules.axiom4(step.get(path));
      var result = rules.rplace(equation, step, path);
      return result.justify('simpleApply', arguments, [step]);
    },
    inputs: {reducible: 1},
    isRewriter: true,
    // Not offered interactively.
    // form: '',
    menuGen: function(ruleName, step, term) {
      return Toy.format('apply function of {1}', term.fn.bound);
    },
    tooltip: ('Applies a lambda to its argument'),
    description: '=simpleApply',
    labels: 'uncommon'
  },

  // "Reduces" a call identified by a path within a theorem. If the
  // call is an application of a lambda expression to an argument,
  // beta-reduces it.  If the target expression is a call to a named
  // function supplying one or two arguments, expands the definition
  // and applies the expansions to the argument(s).
  apply: {
    precheck: function(step, path) {
      var term = step.get(path);
      var fn = term.funPart();
      var n = term.argsPassed();
      // The fn could be a Lambda, which is not defined.
      // This returns falsy if the function is an "unused" constant.
      return ((n === 1 || n === 2) &&
              ((fn instanceof Atom && Toy.isDefined(fn.name)) ||
               fn instanceof Lambda));
    },
    action: function(step, path) {
      // Returns an identity with arg as LHS.
      function applier(expr) {
        assert(expr instanceof Toy.Call, 'Not a call: {1}', expr, step);
        var fn = expr.fn;
        if (fn instanceof Toy.Lambda) {
          return rules.axiom4(expr);
        }
        // Call that looks like (<constant> <expr>).
        if (fn.isConst()) {
          var defn = Toy.findDefinition(fn.name);
          if (defn) {
            return (rules.eqSelf(expr)
                    .andThen('useDefinition', '/right/fn')
                    .andThen('simpleApply', '/right'));
          }
        }
        // Call that looks like (<left> <constant> <right>) or
        // equivalently ((<constant> <arg1>) <arg2>).
        if (expr.isCall2()) {
          var call = expr.fn;
          var fn2 = call.fn;
          if (fn2.isConst()) {
            var defn = Toy.findDefinition(fn2.name);
            if (defn) {
              var step1 = rules.eqSelf(call);
              var step2 = rules.useDefinition(step1, '/right/fn');
              var step3 = rules.simpleApply(step2, '/right');
              var step4 = rules.eqSelf(expr);
              var step5 = rules.rplace(step3, step4, '/right/fn');
              return rules.simpleApply(step5, '/right');
            }
          }
        }
        Toy.fail('Cannot apply at {1} in {2}', step.get(path), step);
      }

      return convert(step, path, applier)
        .justify('apply', [step, path], [step]);
    },
    isRewriter: true,
    inputs: {site: 1},
    form: '',
    menuGen: function(ruleName, step, term) {
      var format = Toy.format;
      if (!(term instanceof Call)) {
        return null;
      }
      if (term.fn.isConst()) {
        return format('apply definition of {1}', term.fn);
      } else {
        return format('apply function of {1}', term.fn.bound);
      }
    },
    tooltip: ('Applies a function, named or not, to one or two arguments'),
    description: '=apply'
  },

  /**
   * Change the name of a bound variable.  Replaces the lambda
   * subexpression in expr at path with one that binds newName, which
   * may be a string or Atom, and uses it in place of any references to
   * the old bound variable.
   */
  changeVar: {
    action: function(step, path, newVar) {
      newVar = varify(newVar);
      path = Toy.path(path, step);
      var target = step.get(path);
      // Report the step, but not in the message.
      assert(target instanceof Toy.Lambda, 'Not a function: {1}', target, step);
      assert(!step.freeVars()[newVar.name],
             'New bound variable {1} must not occur free in {2}', newVar.name,
             step);
      var changed = lambda(newVar,
                           target.body.subFree1(newVar, target.bound));
      var step1 = rules.eqSelf(changed);
      var step2 = rules.r(step1, step, path);
      return step2.justify('changeVar', arguments, [step]);
    },
    inputs: {bindingSite: 1, varName: 3},
    form: ('Rename to <input name=varName>'),
    menu: 'rename a bound variable',
    tooltip: ('Change the name of a bound variable.  The new name '
              + 'must not occur free in the target expression.  '
              + 'Uses the fact that the original expression matches '
              + 'the one with changed bound variable.'),
    description: '=changeVar'
  },

  /**
   * From an equation, infers a similar equation with each
   * side wrapped in a binding of the given variable or variable name.
   */
  bindEqn: {
    action: function(h_eqn, v) {
      v = varify(v);
      var eqn = h_eqn.unHyp();
      eqn.assertCall2('=');
      var step1 = rules.eqSelf(lambda(v, eqn.getLeft()));
      var step2 = rules.rplace(h_eqn, step1, '/right/body');
      return step2.justify('bindEqn', arguments, [h_eqn]);
    },
    inputs: {equation: 1, varName: 2},
    form: ('Bind variable <input name=varName> in step <input name=equation>'),
    menu: '[a = b] to [{v. a} = {v. b}]',
    tooltip: ('Makes each side of an equation into a function'
              + ' of the variable you choose.'),
    description: '[a = b] to [{v. a} = {v. b}]',
    labels: 'primitive'
  },

  /**
   * Substitutes term "a" for variable or name "v" in equation b_c,
   * with the result a consequence of b_c.  (5209) Does not support
   * hypotheses.
   */
  instEqn: {
    action: function(b_c_arg, a_arg, v) {
      var b_c = termify(b_c_arg);
      var a = termify(a_arg);
      var bound = rules.bindEqn(b_c, v);
      var step2 = rules.applyBoth(bound, a);
      var step3 = rules.apply(step2, '/left');
      var step4 = rules.apply(step3, '/right');
      return step4.justify('instEqn', arguments, [b_c]);
    },
    inputs: {equation: 1, term: 2, varName: 3},
    form: ('Instantiate <input name=varName> with <input name=term> '
           + 'in step <input name=equation>'),
    menu: 'substitute for a variable in equation',
    tooltip: ('Instantiates a free variable in an equation.'),
    description: 'substitute for {var}',
    labels: 'primitive'
  },

  /**
   * forall {x. x = x}
   * Helper lemma for eqT.
   */
  xAlwaysX: {
    statement: 'forall {x. x = x}',
    proof: function() {
      var a3 = rules.axiom3();
      var step1 = rules.instEqn(a3, 'f', 'g');
      var step2 = rules.instEqn(step1, '{y. y}', 'f');
      var step3 = rules.apply(step2, '/right/arg/body/right');
      var step4 = rules.apply(step3, '/right/arg/body/left');
      var step5 = rules.eqSelf(Toy.parse('{y. y}'));
      return rules.r(step4, step5, '');
    }
  },

  // T = [B = B] (5210)
  eqT: {
    action: function(b) {
      var lemma = rules.theorem('xAlwaysX');
      var step0 = rules.useDefinition(lemma, '/fn')
      var step1 = rules.applyBoth(step0, b);
      var step2 = rules.apply(step1, '/right');
      var step3 = rules.apply(step2, '/left');
      return step3.justify('eqT', arguments, []);
    },
    inputs: {term: 1},
    form: ('Term to prove equal to itself: <input name=term>'),
    menu: '(T = (A = A))',
    tooltip: ('Proves T = [A = A].'),
    description: 'T = (A = A)',
    labels: 'primitive'
  },

  /**
   * "T" is a theorem.  In the book, T is defined as an instance of
   * eqSelf.
   */
  t: {
    statement: 'T',
    proof: function() {
      var step1 = rules.eqSelf(T);
      var step2 = rules.eqT(T);
      return rules.rRight(step2, step1, '');
    }
  },

  // Target is a step of the form forall {x. B}, expr is A, which will
  // replace all occurrences of x.  Uses no book-specific definitions,
  // and relies only on theorem "T", 5200, and reduce. (5215)
  //
  // Accepts a string for the expr, and supports a target that is the
  // RHS of a conditional.
  //
  // TODO: Consider splittnig this into two forms, one where the
  //   target term is at top level, one where it is the conclusion of
  //   a conditional.
  instForall: {
    precheck: function(step, path, expr_arg) {
      var expr = termify(expr_arg);
      var target = step.get(path);
      var pathStr = path.toString();
      var ok = (target &&
                target.isCall1('forall') &&
                target.arg instanceof Toy.Lambda &&
                // TODO: Handle cases where the target is unconditional.
                (pathStr === '' ||
                 (step.wff.isCall2('=>') &&
                  (pathStr === '/right' ||
                   pathStr === '/rt' ||
                   pathStr === '/main' ||
                   pathStr === '/arg'))));
      return ok;
    },
    action: function(step, path, expr_arg) {
      var expr = termify(expr_arg);
      var target = step.get(path);
      var step1 = rules.useDefinition(step, path);
      var step2 = rules.applyBoth(step1, expr);
      var step3 = rules.apply(step2, '/rt/left');
      var step4 = rules.apply(step3, '/rt/right');
      // Rule fromTIsA depends on instForall via tIsXIsX and
      // equationCases, though this next step is a simplified fromTIsA
      // without hypotheses.
      var step5 = rules.replace(rules.theorem('t'), '', step4);
      return step5.justify('instForall', arguments, [step]);
    },
    toOffer: function(step, term) {
      var path = step.prettyPathTo(term);
      return rules.instForall.precheck(step, path, term);
    },
    inputs: {site: 1, term: 3},
    form: ('Instantiate &forall; with term <input name=term>'),
    menu: 'instantiate &forall;',
    tooltip: ('In &forall;, instantiates the bound variable.'),
    description: 'instantiate &forall;'
  },

  // From [A = B] deduce T = [A = B].
  toTIsEquation: {
    action: function(a_b) {
      assertEqn(a_b);
      var step1 = rules.eqT(a_b.get('/left'));
      var step2 = rules.rplace(a_b, step1, '/right/right');
      return step2.justify('toTIsEquation', arguments, [a_b]);
    },
    inputs: {equation: 1},
    form: 'Introduce "T = " into step <input name=equation>',
    menu: '[a = b] to [T = (a = b)]',
    tooltip: ('From [a = b] deduce T = [a = b].'),
    description: 'from a = b to T = (a = b)',
    labels: 'primitive'
  },

  // Deduces the conjunction of two proved equations without hypotheses.
  // Helper for equationCases.
  andEqns: {
    action: function(step1, step2) {
      var step3 = rules.toTIsEquation(step1);
      var step4 = rules.toTIsEquation(step2);
      var step5 = rules.rplace(step3, rules.theorem('r5212'), '/left');
      var step6 = rules.rplace(step4, step5, '/right');
      return (step6.justify('andEqns', arguments, arguments));
    },
    inputs: {step: [1, 2]},
    form: ('Prove conjunction of equation <input name=step1> ' +
           'and equation <input name=step2>'),
    menu: '[a = b] and [c = d] to [a = b & c = d]',
    tooltip: ('Given [a = b] and [c = d], derive [a = b & c = d]'),
    description: 'a = b & c = d;; from steps {step1}, {step2}',
    labels: 'internal'
  },

  // Given two WFFs each of the form A = B that are the result of
  // substituting T and F respectively for a variable, proves the WFF
  // with the variable.  Does not work with hypotheses.
  equationCases: {
    action: function(caseT, caseF, v) {
      v = varify(v);
      var step1 = rules.andEqns(caseT, caseF);
      // Note: If a variable is not in caseT it is also not in caseF.
      var newVar = Toy.genVar('w', caseT.allNames());
      var gen = caseT.generalizeTF(caseF, newVar);
      var lexpr = lambda(newVar, gen);
      var step4 = rules.instEqn(rules.axiom1(), lexpr, 'g');
      var step5 = rules.apply(step4, '/right/arg/body');
      var step6 = rules.apply(step5, '/left/right');
      var step7 = rules.apply(step6, '/left/left');
      var step8 = rules.r(step7, step1, '');
      var step9 = rules.instForall(step8, '', v);
      return step9.justify('equationCases', arguments, [caseT, caseF]);
    },
    inputs: {equation: [1, 2], varName: 3},
    form: ('Cases: true case step <input name=equation1>'
           + ' false case step <input name=equation2>,'
           + ' use variable <input name=varName>'),
    menu: 'proof by cases, for equations',
    tooltip: ('Given two proved equations C and D obtainable by substitution' +
              ' for a free variable of an equation A = B; C by substituting' +
              ' T, and D by substituting F, proves A = B.'),
    labels: 'primitive'
  },

  //// Now onward to proving a few of the usual truth table facts.

  // TODO: Prove 5229, then finish proving r5230FTBook_almost from it.

  // Prove [F = T] = F.  Number reflects dependencies in the book
  // proof, but this proof needs only simple rules and axiomPNeqNotP.
  //
  // (Or r5230TF, see the alternate proof further below.)
  // Bookish: (F = T) = F.
  // TODO: Prove 5229 then complete this.
  r5230FTBook_almost: {
    statement: '(F == T) == F',
    proof: function() {
      var step1 = rules.axiom2();
      var map = {h: Toy.parse('{x. x = F}'),
                 x: F,
                 y: T};
      var step2 = rules.instMultiVars(step1, map);
      var step3 = rules.apply(step2, '/right/right');
      var step4 = rules.apply(step3, '/right/left');
      var step5 = rules.r5218(F);
      var step6 = rules.r(step5, step4, '/right/right');
      var step7 = rules.eqT(F);
      var step8 = rules.rRight(step7, step6, '/right/left');
      var step9 = rules.r(step5, step8, '/right');
      var step10 = rules.defImplies();
      var step11 = rules.r(step10, step9, '/binop');
      var step12 = rules.apply(step11, '/fn');
      var step13 = rules.apply(step12, '');
      // TODO: Infer by cases from 5229 (rules about '&').
      var step14 = rules.tautology('x & F == F');
      var step15 = rules.instEqn(step14, Toy.parse('F = T'), 'x')
      return rules.r(step15, step13, '/right');
    }
  },

  // Prove [F = T] = F from r5217.
  //
  // Note that the proof of r5230TF depends on r5230FT; but if
  // something like r5230TF were an axiom, then this would make sense.
  //  
  // TODO: Is there a more elegant proof of this?
  r5230FT_alternate: {
    statement: '(F = T) = F',
    proof: function() {
      var x = Toy.parse('x');
      // Note: this uses instVar on facts of the form A => B,
      // which is only supported by instVar by using fromTIsA and toTisA.
      // It is applied to steps that have no hypotheses, but still
      // instVar uses toTIsA (and fromTIsA).
      // TODO: Confirm that this is all correct.
      var step1a = rules.instVar(rules.axiom2(), F, x);
      var step1b = rules.instVar(step1a, T, 'y');
      var step1c = rules.instVar(step1b, '{x. x = F}', 'h');
      var step2a = rules.apply(step1c, '/right/left');
      var step2b = rules.apply(step2a, '/right/right');
      var step3aa = rules.eqT(F);
      var step3a = rules.rRight(step3aa, step2b, '/right/left');
      var step3bb = rules.r5218(F);
      var step3b = rules.r(step3bb, step3a, '/right/right');
      var step3c = rules.r(step3bb, step3b, '/right');
      // From this point most of the work is basically a proof
      // that [A => F] => not A, a tautology.
      var step4 = rules.rewriteOnly(step3c, '', 'p == (T == p)');
      // We are going to prove the cases of: (x => F) = (x = F)
      // First with x = F.
      var step11 = rules.definition('=>', F);
      var step12 = rules.applyBoth(step11, F);
      var step13 = rules.apply(step12, '/right');
      var step14 = rules.r(step3aa, step13, '/right');
      // Then with x = T.
      var step21 = rules.definition('=>', T);
      var step22 = rules.applyBoth(step21, F);
      var step23 = rules.apply(step22, '/right');
      var step24 = rules.r5217Book();
      var step25 = rules.rRight(step24, step23, '/right');
      // Now use the cases rule:
      var step5 = rules.equationCases(step25, step14, x);
      // Then instantiate [F = T] for x.
      var step6 = rules.instEqn(step5, equal(F, T), x);
      // And use the fact that [F = T] => F
      var step7 = rules.rRight(step4, step6, '/left');
      return rules.rewriteOnly(step7, '', '(T == p) == p');
    },
    tooltip: ('[F = T] = F')
  },

  // [T & T] = T.  Uses no book-specific definitions.
  // Only used in 5212 and book version of 5216.
  r5211: {
    statement: 'T & T == T',
    proof: function() {
      var step1 = rules.definition('&', T);
      var step2 = rules.applyBoth(step1, T);
      return rules.apply(step2, '/right');
    }
  },

  // Book version of r5211.
  r5211Book: {
    statement: 'T & T == T',
    proof: function() {
      var step1 = rules.instEqn(rules.axiom1(), '{y. T}', 'g');
      var step2a = rules.apply(step1, '/right/arg/body');
      var step2b = rules.apply(step2a, '/left/right');
      var step2c = rules.apply(step2b, '/left/left');
      var step3a = rules.eqT(Toy.parse('{x. T}'));
      var step3b = rules.rRight(rules.definition('forall'), step3a, '/right/fn');
      return rules.rRight(step3b, step2c, '/right');
    }
  },

  // T & T.  Uses no book-specific definitions.
  // Used to prove equationCases.  The "cases" rule
  // and makeConjunction could treat this as a tautology.
  r5212: {
    statement: 'T & T',
    proof: function() {
      return rules.rRight(rules.theorem('r5211'),
                          rules.theorem('t'),
                          '/');
    }
  },

  r5212Book: {
    statement: 'T & T',
    proof: function() {
      var step1 = rules.r5211Book();
      var step2 = rules.theorem('t');
      return rules.rRight(step1, step2, '');
    }
  },

  // Bookish: From theorems A = B and C = D, derives theorem
  // [A = B] & [C = D].  Used in andTBook.
  r5213: {
    action: function(a_b, c_d) {
      assertEqn(a_b);
      var a = a_b.get('/left');
      var b = a_b.get('/right');
      assertEqn(c_d);
      var c = c_d.get('/left');
      var d = c_d.get('/right');
      var step1 = rules.eqT(a);
      var step2 = rules.r(a_b, step1, '/right/right');
      var step3 = rules.eqT(c);
      var step4 = rules.r(c_d, step3, '/right/right');
      var step5 = rules.r(step2, rules.theorem('r5212'), '/left');
      var step6 = rules.r(step4, step5, '/right');
      return step6.justify('r5213', arguments, arguments);
    }
  },

  // Bookish: [T & F] = F
  r5214: {
    statement: 'T & F == F',
    proof: function() {
      var step1 = rules.axiom1();
      var step2 = rules.instEqn(step1, Toy.parse('{x. x}'), 'g');
      var step3 = rules.apply(step2, '/right/arg/body');
      var step4 = rules.apply(step3, '/left/right');
      var step5 = rules.apply(step4, '/left/left');
      var step6 = rules.defFFromBook();
      return rules.rRight(step6, step5, '/right');
    }
  },

  // 5216 by the book: [T & A] = A
  andTBook: {
    action: function(a) {
      var step1 = rules.axiom1();
      var step2 = rules.instEqn(step1, '{x. T & x == x}', 'g');
      var step3 = rules.apply(step2, '/left/left');
      var step4 = rules.apply(step3, '/left/right');
      var step5 = rules.apply(step4, '/right/arg/body');
      var step7 = rules.r5214();
      var step8 = rules.r5213(rules.theorem('r5211'), step7);
      var step9 = rules.r(step5, step8, '/');
      var step10 = rules.instForall(step9, '', a);
      return step10.justify('andTBook', arguments);
    }
  },

  // 5216, using the definition of "true and".  Not used.
  andT: {
    action: function(a) {
      var step1 = rules.applyBoth(rules.definition('&', T), a);
      var step2 = rules.apply(step1, '/right');
      return step2.justify('andT', [a]);
    }
  },

  // r5217 is the same as r5230TF.
  // [T = F] = F
  r5217Book: {
    statement: 'T == F == F',
    proof: function() {
      var step1 = rules.instEqn(rules.axiom1(), '{x. T = x}', 'g');
      var step2a = rules.apply(step1, '/left/left');
      var step2b = rules.apply(step2a, '/left/right');
      var step2c = rules.apply(step2b, '/right/arg/body');
      var step3 = rules.rRight(rules.eqT(T), step2c, '/left/left');
      var step4a = rules.andTBook(equal(T, F));
      var step4b = rules.r(step4a, step3, '/left');
      var step5a = rules.instEqn(rules.axiom3(), '{x. T}', 'f');
      var step5b = rules.instEqn(step5a, '{x. x}', 'g');
      var step6a = rules.apply(step5b, '/right/arg/body/left');
      var step6b = rules.apply(step6a, '/right/arg/body/right');
      var step6c = rules.useDefinition(rules.defFFromBook(),
                                       '/right/fn');
      var step6d = rules.rRight(step6c, step6b, '/left');
      return rules.rRight(step6d, step4b, '/right');
    }
  },

  //// This might be treated as the end of the subcore.

  // [T = x] = x
  // Note that this or 5230TF or symmetry of equality of booleans
  // might be taken as an axiom given r5230FT_alternate.
  tIsXIsX: {
    statement: '(T == x) == x',
    proof: function() {
      // TODO: Switch back to r5230TF whenever desired.
      var step1 = rules.theorem('r5217Book');
      var step2 = rules.eqT(T);
      var step3 = rules.eqnSwap(step2);
      return rules.equationCases(step3, step1, 'x');
    },
    simplifier: true
  },

  // 5218: [T = A] = A
  // Stepping stone to universal generalization.
  r5218: {
    action: function(a) {
      var step1 = rules.theorem('tIsXIsX');
      var step2 = rules.instEqn(step1, a, 'x');
      return step2.justify('r5218', arguments);
    },
    inputs: {bool: 1},
    form: ('Term to use in ((T = A) = A): <input name=bool>'),
    menu: '(T = A) = A',
    labels: 'uncommon',
    tooltip: ('For any expression derives (T = A) = A.'),
    description: '(T = A) = A'
  },

  // 5219: [A] to [T = A].  Works with hypotheses.
  toTIsA: {
    action: function(h_a) {
      var step1 = rules.r5218(h_a.unHyp());
      var step2 = rules.rRight(step1, h_a, '/main');
      return step2.justify('toTIsA', arguments, [h_a]);
    },
    inputs: {step: 1},
    form: 'Introduce "T = " into step <input name=step>',
    menu: '[a] to [T = a]',
    tooltip: ('From A derives T = A'),
    description: '[a] to [T = a];; {in step step}',
    labels: 'primitive'
  },

  // also 5219: [T = A] to [A].  Works with hypotheses.
  fromTIsA: {
    action: function(h_t_a) {
      var t_a = h_t_a.unHyp()
      assertEqn(t_a);
      var left = t_a.get('/left');
      assert(left.isConst('T'),
             'Input should be [T = A]: {1}', t_a,
             h_t_a);
      var a = t_a.get('/right');
      var result = rules.rplace(rules.r5218(a), h_t_a, '/main');
      return result.justify('fromTIsA', arguments, [h_t_a]);
    },
    inputs: {equation: 1, condition: {1: function(h_eqn) {
      var eqn = h_eqn.unHyp();
      var left = eqn.getLeft();
      return left.isConst('T');
    }}},
    form: 'Eliminate "T = " from step <input name=equation>',
    description: '[T = a] to [a]',
    menu: '[T = a] to [a]',
    tooltip: ('From T = A derives A'),
    labels: 'primitive'
  },

  // Replace an occurrence of T at the given path of the given step
  // with the entirety of another step, ignore any hypotheses there.
  replaceT: {
    action: function(step, path, step2) {
      assert(step.get(path).isConst('T'),
             'Site should be T, not {1}', step.get(path));
      var tIsA = rules.toTIsA(rules.asImplication(step2));
      return (rules.r(tIsA, step, path)
              .justify('replaceT', arguments, [step, step2]));
    },
    inputs: {site: 1, step: 3},
    toOffer: 'return term instanceof Toy.Atom && term.pname == "T"',
    form: ('Replace T with step <input name=step>'),
    menu: 'replace T with a true statement',
    tooltip: ('Replaces an occurrence of T with a true statement'),
    description: 'replace T;; {in step siteStep} {with step step}',
    labels: 'basic'
  },

  // We could consider making a rule, something like "trueInFact",
  // that generalizes forwardChain to use a proved value anywhere in a
  // fact, not just as the antecedent in a conditional.  Looking at
  // truth tables with a row containing a T and an F, if the other row
  // contains only F, the formula is a conjunction, and implies a
  // formula with just one variable; similarly if the other row has T
  // and F in the same columns, it is equivalent to a formula with
  // just one variable.  Otherwise it is an equivalence or a
  // conditional, and "trueBy" is readily used in these cases.

  // Replace part of a target step with T if it matches a proved step
  // or the consequent of a proved conditional, taking the proved step
  // as a schema.  If the target term matches the consequent of the
  // proved step, the antecedent becomes an assumption of the
  // resulting statement.
  trueBy: {
    action: function(target, path, step) {
      var term = target.get(path);
      var map = term.matchSchema(step);
      if (map) {
        var step2 = rules.rewriteOnly(step, '', 'p == (p == T)');
        var result = rules.r(step2, target, path);
      } else if (step.isCall2('=>') &&
                 (map = term.matchSchema(step.getRight()))) {
        var step2 = rules.rewriteOnly(step, '/right', 'p == (p == T)');
        var result = rules.replace(target, path, step2);
      } else {
        assert(false, 'Term {1} does not match {2}',
               target.get(path), step);
      }
      return result.justify('trueBy', arguments, [target, step]);
    },
    inputs: {site: 1, step: 3},
    toOffer: 'return term.isBoolean()',
    form: ('Match {term} with proved step <input name=step>'),
    menu: 'replace proved {term} with T',
    description: ('term is known true;; {in step siteStep} {by step step}'),
    labels: 'basic'
  },

  // Lemma helper for toForall; a pure theorem.
  forallXT: {
    statement: 'forall {x. T}',
    proof: function() {
      var step1 = rules.eqSelf(Toy.parse('{x. T}'));
      var fa = rules.definition('forall');
      return rules.rRight(fa, step1, '/fn');
    }
  },

  existsXT: {
    statement: 'exists {x. T}',
    proof: function() {
      return (rules.fact('p x => exists p')
              .andThen('instVar', '{x. T}', 'p')
              .andThen('simpleApply', '/left')
              .andThen('simplifySite', ''));
    }
  },

  // This actually says NOT (forall {x. F}).
  forallXF: {
    statement: 'not (forall {x. F})',
    proof: function() {
      var fact = rules.fact('exists p == not (forall {x. not (p x)})');
      return (fact.andThen('instVar', '{x. T}', 'p')
              .andThen('apply', fact.find('p x'))
              .andThen('simplifySite', fact.find('not (p x)'))
              .andThen('trueBy', '/left', rules.existsXT())
              .andThen('simplifySite', ''));
    }
  },

  // 5220 (universal generalization).  From A deduces forall {v. A}.
  // The variable v may be given as a string, which it converts
  // internally to a variable.  Supports hypotheses.
  // TODO: Remove this in favor of toForall0 and toForall1
  //   or similarly implyForall.
  toForall: {
    action: function(h_a, v) {
      v = varify(v);
      assert(!(h_a.hasHyps && h_a.getLeft().hasFreeName(v.name)),
             '{1} occurs free in hypotheses of {2}', v.name, h_a);
      var step1 = rules.toTIsA(h_a);
      var step2 = rules.theorem('forallXT');
      var step3 = rules.changeVar(step2, '/arg', v);
      var step4 = rules.rplace(step1, step3, '/arg/body');
      return step4.justify('toForall', arguments, [h_a]);
    },
    inputs: {step: 1, varName: 2},
    form: ('In step <input name=step> generalize on variable '
           + '<input name=varName>'),
    menu: 'add \u2200',
    tooltip: ('Universal Generalization, wrap a theorem A in'
              + ' (forall v A) using the variable of your choice.'),
    description: 'add \u2200'
  },

  // 5220 variant that from A deduces forall {v. A} disregarding
  // hypotheses.  The variable v may be given as a string, which it
  // converts internally to a variable.
  toForall0: {
    action: function(step, v) {
      v = varify(v);
      var step1 = rules.rewriteOnly(step, '', 'a == (T == a)');
      var step2 = rules.theorem('forallXT');
      var step3 = rules.changeVar(step2, '/arg', v);
      var step4 = rules.r(step1, step3, '/arg/body');
      return step4.justify('toForall0', arguments, [step]);
    },
    inputs: {step: 1, varName: 2},
    form: ('In step <input name=step> generalize on variable '
           + '<input name=varName>'),
    menu: '[A] to [\u2200{v. A}]',
    tooltip: ('UGen for  a whole step'),
    description: '[A] to [\u2200{v. A}];; {in step step}'
  },

  // 5220 variant, from [A => B] deduces [A => forall {v. B}].
  // The variable v may be given as a string, which it converts
  // internally to a variable.
  toForall1: {
    precheck: function(step, v_arg) {
      var v = varify(v_arg);
      var format = Toy.format;
      if (!step.isCall2('=>')) {
        this.failure = format('Not a conditional: {1}', step);
      }
      if (step.getLeft().hasFreeName(v.name)) {
        this.failure = format('{1} occurs free in LHS of {2}', v.name, step);
      }
      return !this.failure;
    },
    action: function(step, v) {
      // Step is a conditional.
      v = varify(v);
      var step1 = rules.rewriteOnly(step, '/right', 'a == (T == a)');
      var step2 = rules.theorem('forallXT');
      var step3 = rules.changeVar(step2, '/arg', v);
      // var step4 = rules.replace(step3, '/main/arg/body', step1);
      var step4 = rules.rplace(step1, step3, '/main/arg/body');
      return step4.justify('toForall1', arguments, [step]);
    },
    inputs: {step: 1, varName: 2},
    form: ('In step <input name=step> generalize on variable '
           + '<input name=varName>'),
    menu: '[A => B] to [A => \u2200{v. B}]',
    tooltip: ('UGen for [A => B]'),
    description: '[A => B] to [A => \u2200{v. B}];; {in step step}',
  },

  // 5221 (one variable), in the given step substitute term A for free
  // variable v, which may also be a string, which will be converted
  // to a variable.  In case the step has hypotheses, allows
  // substitution for a variable even if free in the hypotheses.
  instVar: {
    action: function(step, a, v) {
      a = termify(a);
      v = varify(v);
      var map = {};
      map[v.name] = a;
      var result = rules.instMultiVars(step, map);
      return result.justify('instVar', arguments, [step]);
    },
    inputs: {step: 1, term: 2, varName: 3},
    form: ('In step <input name=step>, for variable <input name=varName> '
           + 'substitute <input name=term>'),
    menu: 'substitute for a free variable',
    tooltip: ('In a theorem substitute an expression for'
              + ' all occurrences of a free variable.'),
    description: 'substitute for {var};; {in step step}'
  },

  // Same functionality as instVar, but with a site (step+path) and a
  // term as the arguments.
  instantiateVar: {
    action: function(step, path, term) {
      v = step.get(path);
      assert(v.isVariable(), 'Not a variable: {1}', v);
      var map = {};
      map[v.name] = term;
      var result = rules.instMultiVars(step, map);
      return result.justify('instantiateVar', arguments, [step]);
    },
    inputs: {site: 1, term: 3},
    toOffer: 'return term.isVariable()',
    form: ('Substitute <input name=term> for {term}'),
    menu: 'substitute for {term}',
    tooltip: ('In a theorem substitute an expression for'
              + ' all occurrences of a free variable.'),
    description: 'substitute for {site};; {in step siteStep}',
    labels: 'basic'
  },

  // More like the book's 5221.  For each name in the map (a string),
  // substitutes the expression associated with it in the map, using
  // simultaneous substitution.  Handles hypotheses, allowing
  // substitution for variables that are free in the hypotheses.
  // Parses string values in the map.
  //
  // Optimized to avoid substitutions that have no effect, returning
  // its input, justified as "instMultiVars".
  instMultiVars: {
    action: function(b, map) {
      assert(map && map.constructor && map.constructor === Object,
             'Non-map argument to instMultiVars: {1}', map);
      var hyps = b.hasHyps;
      var isEqn = b.isCall2('=');
      var step = isEqn ? b : rules.rewriteOnly(b, '', 'a == (T == a)');
      var namesReversed = [];
      for (var name in map) {
        if (name === '%expansions') {
          continue;
        }
        var value = termify(map[name]);
        if (value.isVariable() && value.name === name) {
          continue;
        }
        step = rules.bindEqn(step, name);
        namesReversed.unshift(name);
      }
      if (namesReversed.length === 0) {
        return b.justify('instMultiVars', arguments, [b]);
      }
      // Then substitute for the renamed variables.
      namesReversed.forEach(function(name) {
          var step2 = rules.applyBoth(step, map[name]);
          var step3 = rules.apply(step2, '/right');
          step = rules.apply(step3, '/left');
        });
      if (!isEqn) {
        step = rules.fromTIsA(step);
      }
      if (hyps) {
        step = rules.asHypotheses(step);
      }
      return step.justify('instMultiVars', arguments, [b]);
    },
    inputs: {step: 1},
    menu: 'substitute for multiple variables',
    tooltip: ('For each variable in the map substitute its value in the map'),
    description: '=instMultiVars'
  },

  // Given two theorems a and b, proves a & b.
  // Handles hypotheses.
  // 
  // TODO: hyps -- We could replace this rule with combinations of the
  //   fact [A == A & T], and an inverse of rules.trueBy.  That pair
  //   would cover this rule and handle other situations also.
  makeConjunction: {
    action: function(a, b) {
      var stepa = rules.toTIsA(a);
      var stepb = rules.toTIsA(b);
      var step1 = rules.theorem('r5212');
      var step2 = rules.rplace(stepa, step1, '/left');
      var step3 = rules.rplace(stepb, step2, '/main/right');
      return (step3.andThen('arrangeAsms')
              .justify('makeConjunction', arguments, [a, b]));
    },
    inputs: {step: [1, 2]},
    // An approximation, good enough until we can remove this whole rule.
    toOffer: 'return step.hasHyps',
    form: ('Conjoin steps <input name=step1> and <input name=step2>'),
    menu: '[h => p] and [h => q] to [h => p & q]',
    tooltip: ('Given a and b, derive a & b'),
    description: 'p & q;; using steps {step1}, {step2}'
  },

  // (5222) Given two theorems that are substitutions of T and
  // F respectively into a WFF; and a variable or variable name,
  // proves the WFF.  No automatic management of hypotheses.
  // TODO: Consider using the real cases rule (2139) in place of this
  //   everywhere.  This is called with conditionals, but not
  //   with hypotheses.
  // TODO: Consider deriving this from equationCases.  Unlike
  //   5222 in the book, this does not allow the variable to appear
  //   in any assumptions, so equationCases could be used.
  casesTF: {
    action: function(caseT, caseF, v) {
      v = varify(v);
      // Note: caseF has no variables not in caseT, so no need to
      // calculate all of its names.
      var newVar = Toy.genVar('v', caseT.allNames());
      var gen = caseT.generalizeTF(caseF, newVar);
      var step1a = rules.axiom4(call(lambda(newVar, gen), T));
      var step1b = rules.rRight(step1a, caseT, '');
      var step2a = rules.axiom4(call(lambda(newVar, gen), F));
      var step2b = rules.rRight(step2a, caseF, '');
      var step4 = rules.makeConjunction(step1b, step2b);
      var step5 = rules.instVar(rules.axiom1(), lambda(newVar, gen), 'g');
      var step6 = rules.rplace(step5, step4, '');
      var step7a = rules.instForall(step6, '', v);
      var step7b = rules.apply(step7a, '');
      return step7b.justify('casesTF', arguments, [caseT, caseF]);
    },
    inputs: {step: [1, 2], varName: 3},
    form: ('CasesTF: true case step <input name=step1>,'
           + ' false case <input name=step2>,'
           + ' use variable name <input name=varName>'),
    menu: 'proof by true/false cases',
    tooltip: ('Prove a theorem by cases given two theorems that'
              + ' show it with T and F.'),
    description: 'cases: {var} true in step {step1}, false in step {step2}'
  },

  // Given P and P => Q, derive Q. (5224)
  // Handles hypotheses.
  //
  // TODO: hyps -- aim to remove uses of this with hypotheses.
  //   rules.trueBy and/or forwardChain can serve in its place.
  modusPonens: {
    action: function(a, b) {
      var step1 = rules.toTIsA(a);
      // Replace the "a" in "b" with T.
      var step2 = rules.rRight(step1, b, '/main/left');
      // Use the definition of =>.
      var step3 = rules.useDefinition(step2, '/main/fn');
      // From T => x derive x.
      var step4 = rules.apply(step3, '/main');
      return step4.justify('modusPonens', arguments, arguments);
    },
    inputs: {step: 1, implication: 2},
    form: ('Modus ponens: hypothesis step <input name=step>,'
           + ' implication in step <input name=implication>'),
    menu: 'modus ponens',
    tooltip: ('Modus Ponens.  Given A and A => B derives B.'),
    description: '[p] and [p &rArr; q] to q',
    labels: 'primitive'
  },

  // Note: With substitution for p, this can take the place of 5215
  // (universal instantiation).  To apply, match "forall p" with an
  // existing statement. Then "apply" p to user's choice of x.
  r5225: {
    statement: 'forall p => p x',
    proof: function() {
      var step1 = rules.axiom2();
      var map = {h: Toy.parse('{g. g x}'),
                 x: Toy.parse('{x. T}'),
                 y: Toy.parse('p')};
      var step2 = rules.instMultiVars(step1, map);
      var step3 = rules.rRight(rules.definition('forall'), step2, '/left/fn');
      var step4 = rules.apply(step3, '/right/left');
      var step5 = rules.apply(step4, '/right/left');
      var step6 = rules.apply(step5, '/right/right');
      return rules.r(rules.r5218(Toy.parse('p x')), step6, '/right');
    }
  },

  // r5226 is r5225 with "p" and "x" instantiated, then beta conversion.

  // F => x; bookish
  r5227: {
    statement: 'F => x',
    proof: function() {
      var step1 = rules.theorem('r5225');
      var step2 = rules.instVar(step1, Toy.parse('{x. x}'), 'p');
      var step3 = rules.defFFromBook();
      var step4 = rules.rRight(step3, step2, '/left');
      return rules.apply(step4, '/right');
    }
  },

  // [not T] = F
  r5231T: {
    statement: 'not T == F',
    proof: function() {
      var step1 = rules.eqSelf(call('not', T));
      var step2 = rules.r(rules.definition('not'), step1, '/right/fn');
      return rules.r(rules.theorem('r5230FT_alternate'), step2, '/right');
    },
    tooltip: ('[not T] = F')
  },

  // [not F] = T
  r5231F: {
    statement: 'not F == T',
    proof: function() {
      var step1 = rules.eqSelf(call('not', F));
      var step2 = rules.r(rules.definition('not'), step1, '/right/fn');
      var step3 = rules.eqT(F);
      return rules.rRight(step3, step2, '/right');
    }
  },

  // Helper for evalBool, not in book.
  // [[F =] = not].
  falseEquals: {
    statement: '((==) F) == (not)',
    proof: function() {
      return rules.eqnSwap(rules.definition('not'));
    }
  },

  // Another helper for evalBool, not in book.
  // [[T =] = {x. x}].
  trueEquals: {
    statement: '((==) T) == {x. x}',
    proof: function() {
      var x = varify('x');
      var step1 = rules.r5218(x);
      var step2 = rules.eqSelf(Toy.parse('{x. x} x'));
      var step3 = rules.apply(step2, '/left');
      var step4 = rules.r(step3, step1, '/right');
      var step5 = rules.toForall(step4, x);
      var step6 = rules.instVar(rules.axiom3(), equal(T), 'f');
      var step7 = rules.instVar(step6, '{x. x}', 'g');
      return rules.rRight(step7, step5, '');
    }
  },

  // Equates the given expression to a similar one where boolean terms
  // are reduced.  (These are calls to =, &, |, =>, or "not", and
  // lambda expressions, with an argument of T or F.)  Reduces
  // repeatedly until no subexpression can be reduced.
  // TODO: Prove all the truth table facts and use them directly
  // here.  Can we have unnamed theorems?
  evalBool: {
    action: function(expr) {
      var boolOps = {'&': true, '|': true, '=>': true, '=': true, not: true};
      function isReducible(expr) {
        return (expr instanceof Toy.Call
                && ((expr.fn.isConst()
                     && boolOps[expr.fn.name]
                     && expr.arg.isConst()
                     && (expr.arg.name == 'T' || expr.arg.name == 'F'))
                    || expr.fn instanceof Toy.Lambda));
      }
      var result = rules.eqSelf(expr);
      while (true) {
        var right = result.getRight();
        var _path = right.pathTo(isReducible);
        if (_path == null) {
          return result.justify('evalBool', arguments);
        }
        var target = right.get(_path);
        var fn = target.fn;
        if (fn.isConst()) {
          var defn;
          if (fn.name == 'not') {
            defn = rules.theorem(target.arg.name == 'T'
                                 ? 'r5231T'
                                 : 'r5231F');
            result = rules.r(defn, result, '/right' + _path);
          } else if (fn.name == '=') {
            // TODO: To avoid dependencies on trueEquals and
            //   falseEquals, we could break this down into
            //   all 4 cases.
            defn = rules.theorem(target.arg.name == 'T'
                                 ? 'trueEquals'
                                 : 'falseEquals');
            result = rules.r(defn, result, '/right' + _path);
          } else {
            // &, |, =>
            result = rules.useDefinition(result, '/right' + _path);
          }
        } else if (fn instanceof Toy.Lambda) {
          result = rules.apply(result, '/right' + _path);
        } else {
          assert(false, 'Unexpected expression: {1}', target);
        }
      }
    },
    inputs: {bool: 1},
    form: 'Boolean term to simplify: <input name=bool>',
    labels: 'uncommon',
    tooltip: ('simplify a boolean term'),
    description: 'calculate boolean value'
  },

  // Proves an inference that the wff is a tautology and
  // returns it.  Checks that it is indeed proven to be a
  // tautology.  (5233)
  //
  // Accepts a parseable string as the wff.
  tautology: {
    action: function(wff) {
      if (typeof wff == 'string') {
        wff = Toy.parse(wff);
      }
      // TODO: Right here check for patterns such as -
      //   p | T == T, p & F == F, p => T == T, and negations such as
      //   p | not F = T and so on.
      //   Where these occur, this is an instance of a simpler tautology
      //   and need not be analyzed further.  In addition, forms such as
      //   p | F == T is equivalent to p == T along with similar examples,
      //   so this can be broken down into a smaller wff.
      // NOTE that saving proved tautologies as we already do has
      //   potential for accomplishing similar improvements, though it
      //   would work better if saved variable names were standardized.
      var key = wff.dump();
      var taut = _tautologies[key];
      if (taut) {
        // Re-justify to create a new step.
        // Saved steps in _tautologies only keep details, for
        // nice displays.
        return taut.justify('tautology', arguments);
      } else {
        var names = wff.freeVars();
        // Not really a loop, just works with the first free (variable!)
        // name returned.
        for (var name in names) {
          if (wff instanceof Toy.Call && wff.fn instanceof Toy.Call
              && wff.fn.fn.isConst('=')) {
            // WFF is already an equation.
            var step1 = rules.tautology(wff.subFree1(T, name));
            var step2 = rules.tautology(wff.subFree1(F, name));
            var step3 = rules.equationCases(step1, step2, name);
            // Record before the final justification, so all occurrences
            // look the same when displayed.
            _tautologies[key] = step3;
            var result = step3.justify('tautology', arguments);
            return result;
          } else {
            var step1 = rules.tautology(equal(T, wff.subFree1(T, name)));
            var step2 = rules.tautology(equal(T, wff.subFree1(F, name)));
            var step3 = rules.equationCases(step1, step2, name);
            var step4 = rules.fromTIsA(step3);
            _tautologies[key] = step4;
            var result = step4.justify('tautology', arguments);
            return result;
          }
        }
        // There are no free variables, evaluate the expression.
        var step11 = rules.evalBool(wff);
        assert(step11.isCall2('=') && step11.getRight().isConst('T'),
               'Not a tautology: {1}', step11.getLeft(),
               step11);
        var step12 = rules.rRight(step11, rules.theorem('t'), '');
        _tautologies[key] = step12;
        var result = step12.justify('tautology', arguments);
        return result;
      }
    },
    inputs: {bool: 1},
    form: 'Enter tautology: <input name=bool size=40>',
    menu: 'prove a tautology',
    tooltip: ('Tautology decider.'),
    autoSimplify: noSimplify,
    description: 'tautology'
  },

  // Any instance of a tautology is a theorem.  This is part
  // of the book's Rule P.
  //
  // Given an expression that is a tautology, possibly with
  // hypotheses, and a substitution, derives an instantiation of the
  // tautology using the substitution, with the same hypotheses.
  // The tautology can be given as a parseable string.
  tautInst: {
    action: function(h_tautology_arg, map) {
      // The tautology has hyps if the arg does.
      var tautology = termify(h_tautology_arg);
      var step1 = rules.tautology(tautology);
      return rules.instMultiVars(step1, map).justify('tautInst', arguments);;
    },
    tooltip: ('substitute into tautology'),
    description: '=tautInst'
  },

  // TODO: Complete this.
  simplifyBool: {
    action: function(term) {
      if (term.findSubst('not x')) {
        if (term.arg.isBoolConst()) {
          var name = term.arg.name;
          if (name == 'T') {
            return rules.tautology('not T = F');
          } else {
            return rules.tautology('not F = F');
          }
        }
      }
      var simplifiers = {
        '&': {
          T: {
            T: 'T & T == T',
            F: 'T & F == F'
          },
          F: {
            T: 'F & T == F',
            F: 'F & F == F'
          }
        },
        '|': {
            T: 'T | T == T',
            F: 'T | F == T'
          },
          F: {
            T: 'F | T == T',
            F: 'F | F == F'
          },
        '=>': {
            T: 'T => T == T',
            F: 'T => F == F'
          },
          F: {
            T: 'F => T == T',
            F: 'F => F == T'
          },
        '=': {
            T: 'T = T == T',
            F: 'T = F == F'
          },
          F: {
            T: 'F = T == F',
            F: 'F = F == T'
          }
      };
      var boolOps = {'=': true, '&': true, '|': true, '=>': true};
      var op = term.getBinOp().name;
      if (term.isInfixCall() && boolOps.hasOwnProperty(op)) {
        var left = term.getLeft();
        var right = term.getRight();
        if (left.isBoolConst() && right.isBoolConst()) {
          return rules.tautology(simplifiers[op][left.name][right.name]);
        } else if (left.isBoolConst()) {
          return rules.tautology(leftSimplifiers[op][left.name]);
        } else {
          return rules.tautology(rightSimplifiers[op][right.name]);
        }
      }
    }
  },

  // Deduces the conjunction of two proved steps; ignores hypotheses.
  // Introducing a T wherever desired, then substituting a theorem,
  // with or without assumptions, may be a more effective approach.
  and: {
    action: function(step1, step2) {
      return (rules.replaceT(rules.tautology('T & T'), '/right', step2)
              .andThen('replaceT', '/left', step1)
              .justify('and', arguments, arguments));
    },
    inputs: {step: [1, 2]},
    form: ('Prove conjunction of step <input name=step1> ' +
           'and step <input name=step2>'),
    menu: '[p] and [q] to [p & q]',
    tooltip: ('Given [p] and [q], derive p & q'),
    description: 'p & q;; from steps {step1}, {step2}',
    labels: 'basic'
  },

  // Andrews' Rule P with two conjuncts; ignores hypotheses.
  p2: {
    action: function(step1, step2, schema_arg) {
      var schema = rules.fact(schema_arg);
      var conj = rules.and(step1, step2);
      var result = rules.forwardChain(conj, schema);
      return result.justify('p2', arguments, [step1, step2]);
    },
    inputs: {step: [1, 2], bool: 3},
    labels: 'basic',
    menu: '[p] and [q] and [p & q => r] to [r]',
    form: ('Match step <input name=step1> and ' +
           'step <input name=step2> with left side of ' +
           'fact [p & q => r] <input name=bool>'),
    tooltip: ('[p] and [q] and [p & q => r] to [r]'),
    description: 'consequence;; of step {step1} and step {step2} using {bool}'
  },

  // Adds an assumption to the given step and deduplicates it.
  // Oblivious to hypotheses.
  andAssume: {
    action: function(step, expr_arg) {
      var expr = termify(expr_arg);
      if (step.isCall2('=>')) {
        var step0 = rules.asImplication(step);
        var taut = rules.tautology('(p => q) => (p & a => q)');
        var map = {p: step.getLeft(), q: step.getRight(), a: expr};
        var step1 = rules.tautInst(taut, map);
        var step2 = rules.modusPonens(step0, step1);
      } else {
        var taut = rules.tautology('p => (a => p)');
        var map = {p: step, a: expr};
        var step1 = rules.tautInst(taut, map);
        var step2 = rules.modusPonens(step, step1);
      }
      var step3 = rules.arrangeAsms(rules.asHypotheses(step2));
      return step3.justify('andAssume', arguments, [step]);
    },
    inputs: {step: 1, bool: 2},
    form: ('Add assumption <input name=bool> in step <input name=step>'),
    menu: 'add assumption',
    labels: 'basic',
    description: 'add assumption {bool};; {in step step}'
  },

  // Given a variable v that is not free in the given wff A, and a wff B, derive
  // ((forall {v. A | B}) => A | (forall {v. B})).  Could run even if
  // the variable is free, but would not give desired result.
  // This is Axiom Schema 5 of Andrews' first-order logic F.
  //
  // NOTE: This is by the book; use implyForall or perhaps
  // toImplyForall in proofs!
  //
  // TODO: Prove a theorem schema for removing quantification over terms
  // that do not depend on the bound variable.  Something like:
  // {v. f A B} c = f A ({v. B} c) where v is not free in f or a.
  r5235: {
    action: function(v, a, b) {
      v = varify(v);
      var aFree = a.freeVars();
      assert(!aFree.hasOwnProperty(v.name),
             'r5235: variable {1} cannot occur free in {2}', v, a);
      var map1 = {
        p: call('forall', lambda(v, call('|', T, b))),
        q: call('forall', lambda(v, b))
      };
      var step1 = rules.tautInst('p => T | q', map1);
      var step2 = rules.tautInst('p => F | p',
                                 ({p: call('forall', lambda(v, b))}));
      var step3 = rules.tautInst('p == F | p',
                                 ({p: b}));
      var step4 = rules.r(step3, step2, '/left/arg/body');

      var freeNames = $.extend({}, aFree, b.freeVars());
      // Treat v as a free variable also.
      freeNames[v.name] = true;
      var p0 = Toy.genVar('p', freeNames);
      // TODO: Consider using rule P and 2139 instead of "cases" here.
      var step5 = rules.casesTF(step1, step4, p0);
      var step6 = rules.instVar(step5, a, p0);
      return step6.justify('r5235', arguments);
    },
    inputs: {varName: 1, bool: [2, 3]},
    /* Do not show, hard to use and seldom helpful.
    form: ('Variable: <input name=varName> '
           + 'wff without it free: <input name=bool1> '
           + 'other wff: <input name=bool2>'),
    */
    labels: 'uncommon',
    tooltip: ('Move "forall" inside an "or" when variable not free '
              + 'in the left argument of the "or".'),
    description: 'move forall'
  },

  // Given a proof step H |- A => B and a variable v, derives
  // H |- (A => forall {v. B}) provided that v is not free in A or H.
  // (5237)  This version implemented via 5235, so much less efficient.
  //
  // Handles hypotheses.
  // TODO: hyps (can remove /main by moving A into assumptions, then back)
  implyForallBook: {
    action: function(v, h_a_b) {
      var a_b = h_a_b.unHyp();
      v = varify(v);
      assert(a_b.isCall2('=>'), 'Must be an implication: {1}', a_b, h_a_b);
      var a = a_b.getLeft();
      var b = a_b.getRight();
      // Restriction to ensure the desired result.
      assert(!a.hasFreeName(v.name),
             'implyForall: variable {1} cannot occur free in {2}', v, a, h_a_b);
      if (h_a_b.hasHyps) {
        var h = h_a_b.getLeft();
        assert(!h.hasFreeName(v.name),
               'implyForall: variable {1} cannot occur free in {2}', v, h,
               h_a_b);
      }
      var map1 = {a: a, b: b};
      var step1 = rules.tautInst('(a => b) => not a | b', map1);
      var step2 = rules.modusPonens(h_a_b, step1);
      var step3 = rules.toForall(step2, v);
      var step4 = rules.r5235(v, call('not', a), b);
      var step5 = rules.modusPonens(step3, step4);
      var map6 = {a: a, b: step5.get('/main/right')};
      var step6 = rules.tautInst('not a | b => (a => b)', map6);
      var step7 = rules.modusPonens(step5, step6);
      return step7.justify('implyForallBook', arguments, [h_a_b]);
    },
    inputs: {varName: 1, implication: 2},
    /* Do not offer at this time, use toImplyForall instead.
    form: ('Move forall inside "implies" binding '
           + 'variable <input name=varName> '
           + 'implication <input name=implication>'),
    */
    tooltip: ('Move "forall" inside "implies" provided the variable '
              + 'is not free in the first argument.'),
    description: 'move forall'
  },

  // Given a variable v that is not free in the given wff A, and a wff
  // B, derives ((forall {v. A => B}) == (A => forall {v. B})).  Could
  // run even if the variable is free, but would not give desired
  // result.
  //
  // When rewriting with implyForall does the beta reductions that are
  // here, this can probably go away.
  implyForallGen: {
    action: function(v, a_arg, b_arg) {
      var p = termify(a_arg);
      var q = lambda(v, termify(b_arg));
      var step1 = rules.implyForall();
      var step2 = (rules.instMultiVars(step1, {p: p, q: q})
                   .andThen('simpleApply', '/left/arg/body/right')
                   .andThen('simpleApply', '/right/right/arg/body'));
      return step2.justify('implyForallGen', arguments);
    },
    inputs: {varName: 1, bool: [2, 3]},
    form: ('Variable: <input name=varName> '
           + 'wff without it free: <input name=bool1> '
           + 'other wff: <input name=bool2>'),
    menu: 'forall {v. A => B} => (A => forall {v. B}',
    tooltip: ('Move "forall" inside an "or" when variable not free '
              + 'in the left argument of the "or".'),
    description: 'move forall',
    labels: 'uncommon'
  },

  orForall: {
    statement: 'forall {x. p | q x} == (p | forall {x. q x})',
    proof: function() {
      // TODO: This proof could use 2139 instead of "casesTF".
      var taut1 = rules.tautology('T | a');
      // None of these steps are conditionals, so no hypotheses anywhere.
      var all = rules.instVar(taut1, 'q x', 'a').andThen('toForall', 'x');
      var or = rules.instVar(taut1, 'forall {x. q x}', 'a');
      var and = rules.makeConjunction(all, or);
      var trueCase = rules.forwardChain(and, 'a & b => (a == b)');
      var falseCase = (rules.eqSelf('forall {x. q x}')
                       .andThen('rewriteOnly', '/right', 'p == F | p')
                       .andThen('rewriteOnly', '/left/arg/body', 'p == F | p'));
      return rules.casesTF(trueCase, falseCase, 'p');
    }
  },

  // This is probably the most useful form of quantifier remover that
  // requires a variable to be not free.  It does not appear in the
  // book, but the numbered ones are corollaries of it.
  //
  // The proof does not use any rules with hypotheses, and in
  // particular it uses toForall only on an entire step (in orForall),
  // so it could be used to build Rule R'.
  implyForall: {
    statement: 'forall {x. p => q x} == (p => forall {x. q x})',
    proof: function() {
      var taut = 'not a | b == a => b';
      return (rules.orForall()
              .andThen('instVar', 'not p', 'p')
              .andThen('rewriteOnly', '/right', taut)
              .andThen('rewriteOnly', '/left/arg/body', taut));
    }
  },

  // 2127
  equivForall: {
    statement: 'forall {x. p} == p',
    labels: 'higherOrder',
    converse: {labels: 'higherOrder'},
    proof: function() {
      var term = '{x. F} x';
      var falsity = (rules.forallXF()
                     .andThen('rewriteOnly', '', 'not a == (a == F)'));
      var step1 = rules.orForall().andThen('instVar', '{x. F}', 'q');
      var step2 = rules.simpleApply(step1, step1.find(term));
      var step3 = rules.simpleApply(step2, step2.find(term));
      var step4 = rules.rewriteOnly(step3, '/right/right', falsity);
      var step5 = (step4.andThen('simplifySite', '/right')
                   .andThen('simplifySite', '/left/arg/body'));
      return step5;
    }
  },

  // 2128
  equivExists: {
    statement: 'exists {x. p} == p',
    labels: 'higherOrder',
    converse: {labels: 'higherOrder'},
    proof: function() {
      var step1 = (rules.equivForall().andThen('instVar', 'not p', 'p'));
      return (rules.applyToBoth('not', step1).andThen('simplifyStep'));
    }
  },

  // 2132
  forallOr: {
    statement: 'forall {x. p x} | forall {x. q x} => forall {x. p x | q x}',
    proof: function() {
      var step1 = (rules.fact('forall p => p x')
                   .andThen('rewriteOnly', '/left/arg', 'p = {x. p x}'));
      var step2 = step1.andThen('instVar', 'q', 'p');
      var step3 = rules.p2(step1, step2,
                           '(a => b) & (c => d) => (a | c => b | d)');
      var step4 = rules.toForall0(step3, 'x');
      var step5 = rules.rewriteOnly(step4, '', 'implyForall');
      return step5;
    }
  },

  // 2138
  andExists: {
    statement: 'exists {x. p x & q x} => exists {x. p x} & exists {x. q x}',
    proof: function() {
      var notAll = 'not (forall p) == exists {x. not (p x)}'
      var reducers = [{pure: true,
                       apply: function(term, cxt) {
            var result = term.isReducible();
            if (result) {
              result = rules.axiom4(term);
            }
            return result;
            return (term.isReducible() &&
                    rules.axiom4(term));
          }
        },
        'not (not a) = a',
        'not (not a | not b) == a & b'];
      return (rules.forallOr()
              .andThen('instMultiVars', {p: 'negate p', q: 'negate q'})
              .andThen('simplifySite', '', ['negate p x == not (p x)'])
              .andThen('rewriteOnly', '', 'a => b == not b => not a')
              .andThen('rewriteOnly', '/left', notAll)
              .andThen('rewriteOnly', '/right', 'not (a | b) == not a & not b')
              .andThen('rewriteOnly', '/right/right', notAll)
              .andThen('rewriteOnly', '/right/left', notAll)
              .andThen('_simplifySite', '', reducers)
              );
    }
  },

  // General TODOs:
  //
  // TODO: Check theorem statements when proving.
  //
  // TODO: Consider asserting theorems until proof is requested.
  //

  // Counterpart to R2134.  This does almost all the work for the
  // "Exists rule" (2135, 5244).  The LHS quantifier limits the "E
  // rule" to use where x is not free in any hypothesis, and since "q"
  // appears with x bound, substituting for it does not result in any
  // free occurrences of x.
  existImplies: {
    statement: 'forall {x. p x => q} == (exists p => q)',
    proof: function() {
      var fact = rules.fact('not (forall {x. not (p x)}) == exists p');
      return (rules.implyForall()
              .andThen('instMultiVars', {p: 'not q', q: '{x. not (p x)}'})
              .andThen('apply', '/right/right/arg/body')
              .andThen('apply', '/left/arg/body/right')
              .andThen('rewrite', '/right', 'not a => b == not b => a')
              .andThen('rewrite', '/left/arg/body',
                       'not a => not b == b => a')
              .andThen('replace', '/right/left', fact));
    }
  },

  // This removes an irrelevant assumption of the form <vbl> = <term>,
  // where the variable does not occur in the term nor elsewhere in
  // the step.  The arguments are a step and path to the assumption.
  removeLet: {
    precheck: function(step, path_arg) {
      var path = Toy.path(path_arg);
      if (!(step.isCall2('=>') && path.isLeft())) {
        return false;
      }
      var term = step.get(path);
      if (!term.isCall2('=')) {
        return false;
      }
      var vbl = term.getLeft();
      if (!vbl.isVariable()) {
        return false;
      }
      var val = term.getRight();
      if (vName in val.freeVars()) {
        return false;
      }
      var vName = vbl.name;
      var step1 = rules.extractHypAt(step, path);
      var map = step1.matchSchema('a => (b => c)');
      if (map) {
        var aFree = map.a.freeVars();
        var cFree = map.c.freeVars();
        if (!(vName in aFree || vName in cFree)) {
          return {extracted: step1, vName: vName, rewrite: true};
        }
      } else {
        var cFree = step.wff.getRight().freeVars();
        if (!(vName in cFree)) {
          return {extracted: step1, vName: vName, rewrite: false};
        }
      }
      return false;
    },
    action: function(step, path_arg) {
      var info = Toy._actionInfo;
      var path = Toy.path(path_arg);
      var step1 = info.extracted;
      var vName = info.vName;
      var asm = step.get(path);
      var step2 = (info.rewrite
                   ? rules.rewrite(step1, '', 'a => (b => c) == b => (a => c)')
                   : step1);
      var step3 = rules.toForall0(step2, vName);
      var equiv = rules.fact('forall {x. p x => q} == exists p => q');
      var step4 = rules.rewriteOnly(step3, '', equiv);
      var exists = (rules.fact('exists {y. y = x}')
                    .andThen('instVar', asm.getRight(), 'x'));
      var step5 = rules.trueBy(step4, '/left', exists);
      var step6 = rules.rewrite(step5, '', 'T => x == x');
      return step6.justify('removeLet', arguments, [step]);
    },
    inputs: {site: 1},
    labels: 'basic',
    form: (''),
    menu: 'remove irrelevant assumption',
    tooltip: 'Remove irrelevant assumption',
    description: 'remove irrelevant assumption {site};; {in step siteStep}'
  },

  // Removes an irrelevant type assumption of the form (R v) at the
  // target site.  Currently only for predicate R, but should be
  // extended as needed.
  removeTypeAsm: {
    precheck: function(step, path_arg) {
      var path = Toy.path(path_arg);
      if (!(step.isCall2('=>') && path.isLeft())) {
        return false;
      }
      var term = step.get(path);
      var termMap = term.matchSchema('R v');
      if (!termMap || !termMap.v.isVariable()) {
        return false;
      }
      var step1 = rules.extractHypAt(step, path);
      var map = step1.matchSchema('a => (b => c)');
      var vName = termMap.v.name;
      if (map) {
        var aFree = map.a.freeVars();
        var cFree = map.c.freeVars();
        if (!(vName in aFree || vName in cFree)) {
          return {extracted: step1, vName: vName, rewrite: true};
        }
      } else {
        // The step had no other assumptions.
        var cFree = step.wff.getRight().freeVars();
        if (!(vName in cFree)) {
          return {extracted: step1, vName: vName, rewrite: false};
        }
      }
      return false;
    },
    action: function(step, path_arg) {
      var path = Toy.path(path_arg);
      var info = Toy._actionInfo;
      var step1 = info.extracted;
      var vName = info.vName;
      var asm = step.get(path);
      var step2 = (info.rewrite
                   ? rules.rewrite(step1, '', 'a => (b => c) == b => (a => c)')
                   : step1);
      var step3 = rules.toForall0(step2, vName);
      var equiv = rules.fact('forall {x. p x => q} == exists p => q');
      var step4 = rules.rewriteOnly(step3, '', equiv);
      var exists = rules.fact('exists R');
      var step5 = rules.trueBy(step4, '/left', exists);
      var step6 = rules.rewrite(step5, '', 'T => x == x');
      return step6.justify('removeTypeAsm', arguments, [step]);
    },
    inputs: {site: 1},
    labels: 'basic',
    form: (''),
    menu: 'remove irrelevant type assumption',
    tooltip: 'Remove irrelevant type assumption',
    description: 'remove irrelevant type assumption {site};; {in step siteStep}'
  },

  // Given a proof step H |- A => B and a variable v, derives
  // H |- (A => forall {v. B}) provided that v is not free in A or H.
  // (5237)  Implemented via implyForallGen.
  //
  // Handles hypotheses.  Note: with hyps, has two levels of =>.
  //
  // TODO: Change this to move "A" into the LHS (where there is an LHS),
  //   apply toForall, then move it back to the RHS.
  toImplyForall: {
    action: function(v, h_a_b) {
      v = varify(v);
      var a_b = h_a_b.unHyp();
      var step1 = rules.toForall(h_a_b, v);
      var step2 = rules.implyForallGen(v, a_b.getLeft(), a_b.getRight());
      var step3 = rules.rplace(step2, step1, '/main');
      return step3.justify('toImplyForall', arguments, [h_a_b]);
    },
    inputs: {varName: 1, implication: 2},
    form: ('Move forall inside "implies" binding '
           + 'variable <input name=varName> '
           + 'in step <input name=implication>'),
    menu: 'Add "forall" after =>',
    tooltip: ('Add "forall" after "implies" provided the variable '
              + 'is not free to the left of the "implies".'),
    description: 'add forall after =>'
  },
    
  // Rule P/Q for a single antecedent (5234).  The schema step must
  // have the form (A => B), where A matches the given input step, or
  // the form (A == B), which implies (A => B) and (B => A).  This
  // matches the step against A in the schema, and deduces the
  // appropriate instance of B, or vice-versa in the case (A == B).
  //
  // This version extends Andrews' version in that any (free)
  // variables of B not also (free) in A are universally quantified
  // in the result, with the quantified variables in lexicographic
  // order by name.  This way, instantiating these variables later
  // affects exactly the sites in the schema where the variable
  // originally occurred, and the order is predictable.
  //
  // Unlike Andrews' rule, there is no special handling here for
  // hypotheses.  Include them as antecedent of a conditional
  // in the schema.
  // 
  // For tautologies with a conjunction on the LHS as shown in the
  // book, use rule P2.  If there are more than two conjuncts, combine
  // one or both with rules.and.
  //
  // Andrews calls his enhanced version of forward chaining "Rule P".
  // (This system currently only provides for one or two conjuncts in
  // the antecedent, through this forwardChain rule, and rule P2.  If
  // there are more than two conjuncts, use rules.and to collect them
  // together.)
  //
  // TODO: Apply a similar quantification strategy to rewriting, since
  // the same issues apply to rewrites.
  //
  // TODO: Remove support here for equivalences, and replace the
  // relevant occurrences of this rule with uses of rewriting.
  //
  // TODO: Consider merging this functionality with rules.trueBy.
  forwardChain: {
    action: function(step, schema_arg) {
      var schema = rules.fact(schema_arg).andThen('asImplication');
      var mainOp = schema.getBinOp().pname;
      var substitution = step.matchSchema(schema.getLeft());
      if (!substitution && (mainOp === '==' || mainOp === '=')) {
        // Allow RHS match in case schema is an equivalence.
        substitution = step.matchSchema(schema.getRight());
      }
      assert(substitution, 
             '{1} does not match LHS of schema\n{2}',
             step, schema);
      var unmapped = schema.unmappedVars(substitution);
      var schema2 = schema;
      // Variables first in unmapped are quantified first/outermost.
      while (unmapped.length) {
        schema2 = rules.toForall1(unmapped.pop(), schema2);
      }
      // Schema2 may have some newly-quantified variables in its RHS.
      var step2 = rules.instMultiVars(schema2, substitution);
      var step3 = (mainOp === '=>'
                   ? rules.modusPonens(rules.asImplication(step), step2)
                   : mainOp === '=='
                   ? rules.rplaceEither(step, '/main', step2)
                   : assert(false, 'Schema must be like A => B or A == B'));
      // Schema is listed as a dependency here so it can be recognized
      // as a dependency, e.g. when rendering a proof.
      return step3.justify('forwardChain', [step, schema], [step]);
    },
    inputs: {step: 1, bool: 2},
    labels: 'basic',
    menu: 'forward chain',
    form: ('Match step <input name=step> with left side of ' +
           'fact [left => right] <input name=bool>'),
    tooltip: ('[p] and [p => q] to q'),
    description: 'consequence;; of step {step} using {bool}'
  },

  // TODO: Consider generalizing rule p2 and probably others to unify
  //   their arguments, not just compare or match a schema.  If p2 did
  //   unification, it could replace uses of this rule.  See for example
  //   addDefnFacts.

  // This applies transitivity of the conditional, treating the fact
  // LHS as a schema when matching with the step RHS.
  forwardChain2: {
    action: function(step, fact_arg) {
      var fact = rules.fact(fact_arg);
      var map1 = step.matchSchema('p => q0');
      assert(map1, 'Not a conditional: {1}', step);
      var map2 = fact.matchSchema('q1 => r');
      assert(map2, 'Not a conditional: {1}', fact);
      var map3 = map1.q0.matchSchema(map2.q1);
      assert(map3, '{1} does not match {2}', map1.q0, map2.q1);
      var step1 = rules.instMultiVars(fact, map3);
      var step2 = rules.p2(step, step1,
                           '(a => b) & (b => c) => (a => c)');
      // Caution: These are unusual justification args.
      return step2.justify('forwardChain2', [step, fact], [step]);
    },
    inputs: {step: 1, bool: 2},
    labels: 'basic',
    menu: "[p => q'] and fact [q => r] to [p => r']",
    form: ('Match conclusion of step <input name=step> with left side of ' +
           'fact [left => right] <input name=bool>'),
    tooltip: ('[p => q] and [q => r] to [p => r]'),
    description: 'consequence;; of step {step} using {bool}'
  },

  /*
  cases: {

  },
  */

  // Instantiates the schema theorem so that the part at the given
  // path is identical to the given term.
  //
  // TODO: Change "subgoal" to "expandRight"; create similar "expandLeft".
  instantiate: {
    action: function(schema, path, term) {
      var expr = schema.get(path);
      var subst = term.matchSchema(expr);
      assert(subst, 'Schema {1} should match {2}', expr, term);
      var result = rules.instMultiVars(schema, subst);
      return result.justify('instantiate', arguments, [schema]);
    }
  },

  // Finds a "subgoal" statement that implies the goal via the given
  // theorem, which must be a schema of the form a => b.
  // Instantiates the theorem by matching the goal against the theorem
  // RHS, returning the instantiated theorem.  Returns null if the
  // theorem does not match the goal.
  subgoal: {
    action: function(goal, theorem) {
      theorem.assertCall2('=>');
      var subst = goal.matchSchema(theorem.getRight());
      if (subst) {
        var result = rules.instMultiVars(theorem, subst);
        return result.justify('subgoal', arguments);
      } else {
        return null;
      }
    }
  },

  // Relates equal functions to equality at all input data points.
  r5238: {
    action: function(vars, a, b) {
      assert(Array.isArray(vars), 'Variables must be an array: {1}', vars);
      var result;
      if (vars.length == 0) {
        result = rules.eqSelf(equal(a, b));
      } else if (vars.length == 1) {
        result = rules.r5238a(vars[0], a, b);
      } else {
        var v = varify(vars[vars.length - 1]);
        var step1 = rules.r5238(vars.slice(0, -1),
                                lambda(v, a),
                                lambda(v, b));
        var step2 = rules.r5238a(v, a, b);
        var step3 = rules.r(step2, step1, '/right/arg/body');
        result = step3;
      }
      return result.justify('r5238', arguments);
    },
    // TODO: inputs: ... ?
    tooltip: ('Equal functions equate to equal expression values.')
  },

  // "Base case" of 5238, with just a single variable.
  r5238a: {
    action: function(v, a, b) {
      v = varify(v);
      var step2 = rules.axiom3();
      var step3 = rules.instMultiVars(step2,
                               ({f: lambda(v, a),
                                 g: lambda(v, b)}));
      var step4 = rules.apply(step3, '/right/arg/body/left');
      var step5 = rules.apply(step4, '/right/arg/body/right');
      var step6 = rules.changeVar(step5, '/right/arg', v);
      // Do not "derive", leave this inline.
      return step6;
    },
    tooltip: ('')
  },

  // 5239, closely following the description and names in the book.
  // Analog to Rule R, expressed as an implication.  Theorem schema.
  //
  // Given a target wff C, a path relative to C, and an equation A = B,
  // proves a wff of the form "(forall ... A = B) => (C == D), where D
  // is obtained similarly to an application of Rule R to A = B and C.
  // The "forall" binds free variables of A = B that are bound at the
  // replacement location in C.
  //
  // Note that the target and the equation are merely formulas.  They
  // need not be proved or true statements.
  r5239: {
    action: function(target, path, equation) {
      path = Toy.path(path, target);
      assert(equation.isCall2('='),
             'Expecting an equation, got: {1}',
             equation);
      var step1 = rules.axiom2a();
      var a = equation.getLeft();
      var b = equation.getRight();
      var boundNames = target.boundNames(path);
      Toy.removeExcept(boundNames, equation.freeVars());
      // Is this the full set of names?
      var t =
        Toy.genVar('t', $.extend({}, target.allNames(), equation.allNames()));
      var texpr = t;
      for (var name in boundNames) {
        texpr = call(texpr, varify(name));
      }
      var aBound = a;
      var bBound = b;
      var boundNameList = [];
      for (var name in boundNames) {
        var v = varify(name);
        aBound = lambda(v, aBound);
        bBound = lambda(v, bBound);
        boundNameList.push(name);
      }
      var g = target.replaceAt(path, function(expr) { return texpr; });
      var step2 =
        rules.instMultiVars(step1,
                            ({x: aBound, y: bBound, p: lambda(t, g)}));
      var step3 = rules.apply(step2, '/right/left');
      var step4 = step3;
      for (var i = 0; i < boundNameList.length; i++) {
        step4 = rules.apply(step4, Toy.path('/right/left').concat(path));
      }
      var step5 = rules.apply(step4, '/right/right');
      var step6 = step5;
      for (var i = 0; i < boundNameList.length; i++) {
        step6 = rules.apply(step6, Toy.path('/right/right').concat(path));
      }
      if (boundNameList.length == 0) {
        return step6.justify('r5239', arguments);
      }
      var step7 = rules.r5238(boundNameList, a, b);
      var step8 = rules.r(step7, step6, '/left');
      return step8.justify('r5239', arguments);
    },
    // First arg is any equation, need not be proved.
    inputs: {bool: [1, 3], path: 2},
    form: ('Apply equation <input name=bool2> to <input name=bool1> at ' +
           '<input name=path>'),
    menu: 'prove A = B => (C == D) where D is C with an A replaced by B',
    labels: 'advanced',
    tooltip: ('Analog to Rule R, expressed as an implication.')
  },

  // Uses r5239 to prove C & (forall)(a = b) == D & (forall)(a = b)
  // where D is like C, but with an occurrence of "a" replaced, and
  // "(forall)" here indicates potential universal quantification of
  // some variables of (a = b).
  r5239a: {
    action: function r5239a(base, path, equation) {
      var step = rules.r5239(base, path, equation);
      var taut = rules.tautology('a => (b == c) == (b & a == c & a)');
      var subst = step.wff.matchSchema(taut.getLeft());
      var inst = rules.instMultiVars(taut, subst);
      var result = rules.replace(step, '', inst);
      return result.justify('r5239a', arguments);
    },
    // First arg is any equation, need not be proved.
    inputs: {bool: [1, 3], path: 2},
    form: ('Apply equation <input name=bool2> to <input name=bool1> at ' +
           '<input name=path>'),
    menu: 'prove (A = B) & C == (A = B) & D where D is C with an A replaced by B',
    labels: 'advanced',
    tooltip: ('Theorem generator used with simultaneous equations.')
  },

  // Not in Andrews' textbook
  //
  // This is the core rule for replacing terms in simultaneous equations.
  //
  // The target term must be part of a tree of conjuncts in the step
  // and the tree must also contain an equation with one side equal to the target.
  // This replaces the target with the other side of that equation.
  replaceConjunct: {
    // The basic idea of this rule is to apply the equivalence:
    // (t1 = t2 & A == t1 = t2 & A[t1 :1= t2]),
    // where t1 and t2 are terms, and t1 occurs in A with all of its
    // free variables also free there.  The :1= operator is like
    // substitution with :=, but replacing just one occurrence (not
    // specifying which occurrence).
    //
    // This function searches the ancestor nodes of the target
    // expression, seeking a conjunction that also has a suitable
    // equation ("eqn") as a descendant.  If none is found, the rule
    // fails.
    //
    // If the conjunction has the form (expr & eqn), this immediately
    // replaces the conjunction using r5239a and rule R, and we are
    // done.
    //
    // Otherwise it searches along the path from the conjunction to
    // the target for the nearest node that is not itself a conjunction.
    // (We will call this node the base.)
    //
    // Now it proves that the original conjunction is equivalent
    // to a version with the base replaced by (base & eqn).  Next it
    // shows this form of the conjunction is equivalent to a version
    // with (base' & eqn), where base' has the target replaced.  Then
    // it shows that form to be equivalent to a form with (base' & eqn)
    // replaced by just base'.  Finally it replaces the conjunction
    // using the last of these equivalences.
    //
    // TODO: Currently the equation's LHS must match the target.
    // Extend this rule to handle an equation with RHS matching the target.
    action: function replaceConjunct(step, path_arg) {
      var Path = Toy.Path;
      var infixCall = Toy.infixCall;
      var wff = step.wff;
      var path = Toy.path(path_arg, wff);
      var prettyPath = wff.prettifyPath(path);
      // This will become the nearest ancestor of the target that is a
      // conjunction and has a suitable equation among its direct or
      // indirect conjuncts (which form a tree).
      var conjunction;
      // Ancestors of the target node, always non-empty, outermost
      // (i.e. wff) first.
      var ancestors = wff.ancestors(prettyPath);
      // The actual term to be replaced.
      var target = ancestors[ancestors.length - 1];
      // True iff the term is a "suitable equation" whose LHS matches
      // the target.
      function suitableEqn(term) {
        return term.isCall2('=') && term.getLeft().matches(target);
      }
      // This will become a "pretty" path from the conjunction to the
      // suitable equation below it.
      var eqnPath;
      var i;
      // Find the conjunction and eqnPath.
      for (i = ancestors.length - 1; i >= 0; --i) {
        var term = ancestors[i];
        if (term.isCall2('&')) {
          eqnPath = pathToConjunct(term, suitableEqn);
          if (eqnPath) {
            // Suitable conjunct is found.
            conjunction = term;
            break;
          }
        }
      }
      // ancestors[i] is now the conjunction.
      // Do a sanity check.
      assert(conjunction, 'No suitable conjunction found');
      // This is the equation that will be applied.
      var eqn = conjunction.get(eqnPath);
      // Path to the conjunction is a prefix of the target path.
      var toConjunction = path.firstN(i);

      if (eqnPath.toString() === '/right') {
        // This will equate the conjunction (base & eqn) with
        // another conjunction where the target is replaced.
        var equiv = rules.r5239a(conjunction.getLeft(),
                                 path.nth(i + 1), eqn);
        // Replaces the conjunction with a new conjunction.
        var result = rules.replace(step, toConjunction, equiv);
        // Done.
        return result.justify('replaceConjunct', arguments, [step]);
      }

      // Now find the base.
      var j;
      for (j = i + 1; j < ancestors.length; j++) {
        var term = ancestors[j];
        if (!term.isCall2('&')) {
          break;
        }
      }
      // This is the path from the conjunction to the base.
      var toBase = path.nth(i).firstN(j - i);
      var base = conjunction.get(toBase);
      var schema = conjunctionSchema(conjunction);
      var eqnVar = schema.get(eqnPath);
      var baseVar = schema.get(toBase);
      var rhs = schema.replaceAt(toBase, function(x) {
          return infixCall(baseVar, '&', eqnVar);
        });
      var schema1 = rules.tautology(infixCall(schema, '==', rhs));
      // Path from the base to the target.
      var fromBase = path.nth(j);
      var map1 = conjunction.matchSchema(schema);
      // Prove the conjunction is equivalent to its transform.
      var equiv1 = rules.tautInst(schema1, map1);
      // Prepare to replace the base part of the right side.
      var replacer1 = rules.r5239a(base, fromBase, eqn);
      // Conjunction is equivalent to its transform with target replaced.
      var equiv2 = rules.replace(equiv1, Toy.path('/right').concat(toBase),
                                 replacer1);
      // Reverse the transform on the RHS.
      var equiv3 = rules.rewriteOnly(equiv2, '/right',
                                     infixCall(rhs, '==', schema));
      var result = rules.replace(step, toConjunction, equiv3);
      return result.justify('replaceConjunct', arguments, [step]);
    },
    inputs: {site: 1},
    form: '',
    menuGen: function(ruleName, step, term) {
      if (step && term && term.isVariable()) {
        var wff = step.wff;
        var path = wff.prettyPathTo(term);
        var ancestors = wff.ancestors(path);
        var conjunction;
        var i;
        // Find the innermost conjunction containing the term, then
        // the innermost non-conjunction containing that.
        for (i = ancestors.length - 1; i >= 0; --i) {
          var node = ancestors[i];
          if (node.isCall2('&')) {
            conjunction = node;
          } else if (conjunction) {
            break;
          }
        }
        if (!conjunction) {
          return null;
        }
        var vname = term.name;
        var results = [];
        var terms = new Toy.TermSet();
        function add(term) {
          terms.add(term);
        }
        var format = Toy.format;
        var conjuncts = conjunction.scanConjuncts(add);
        if (terms.size() > 1) {
          // There are multiple conjunctions, so check for possible
          // replacements.
          function check(eqn) {
            if (eqn.isCall2('=') && eqn.getLeft().isVariable() &&
                eqn.getLeft().name === vname) {
              results.push(format('replace {1} with {2}',
                                  term.pname, eqn.getRight().toUnicode()));
            }
          }
          terms.each(check);
        }
        return results;
      }
    },
    tooltip: ('Replaces an occurrence of a term with an equal term'),
    description: 'replace {site};; {in step siteStep}',
    labels: 'algebra basic'
  },

  // Version of Andrews Rule R' that uses a conditional rather than
  // hypotheses.  Uses a potentially conditional equation to replace a
  // term in a target step.  If both input steps are conditional,
  // collapses the result [a1 => (a2 => q)] into [a1 & a2 => q].
  //
  // For backward compatibility, if either input has hypotheses,
  // the result has hypotheses.
  //
  // Takes its arguments in the usual order with the target first,
  // unlike rules.r and rules.rplace.
  replace: {
    action: function(target, path, equation) {
      assert(equation.isEquation(), 'Not an equation: {1}', equation);
      if (equation.isCall2('=')) {
        return rules.r(equation, target, path);
      }
      // The result of this has the form [h => (forall ... eq)],
      // same as LHS of step3; see below for h, eq and step3.
      function quantEquation() {
        var boundNames = target.boundNames(path);
        Toy.removeExcept(boundNames, equation.freeVars());
        var hypFreeNames = h.freeVars();
        // Quantify over just the variables free in the equation and
        // bound at the target site.
        var quantEqn = equation;
        for (var name in boundNames) {
          // Check the variable is not free in any hypotheses.
          // TODO: Do appropriate checking in 5235 and impliesForall as well.
          assert(!(name in hypFreeNames),
                 'Conflicting binding of {1} in {2}', name, c, h_c_arg);
          // TODO: quantEqn = rules.toForall1(quantEqn, name);
          quantEqn = rules.toImplyForall(name, quantEqn);
        }
        return quantEqn;
      }

      // Main body of the rule is here.
      // The equation is a conditional, eq is its pure equation part.
      var eq = equation.getRight();
      var h = equation.getLeft();
      var step1 = rules.r5239(target, path, eq);
      var step2a = rules.trueBy(step1, '/right/left', target);
      var step2b = rules.rewriteOnly(step2a, '/right', '(T == p) == p');
      // Use the equation's assumptions as assumptions in place of
      // the equation itself.
      var step3 = rules.p2(equation, step2b,
                           '(a => b) & (b => c) => (a => c)');
      var step4 = step3;
      // quantEqn will be [(forall ... eq) => D], where D is the target
      // after replacement, and the quantifier binds no free vars of eq.
      var quantEqn = quantEquation()
      // If the replacement site has no variable bindings, then quantEqn
      // and equation are the same, so skip the chaining.
      if (!quantEqn.wff.sameAs(equation.wff)) {
        var conj1 = rules.and(quantEqn, step3);
        var taut1 = rules.tautology('(p => q) & (q => r) => (p => r)');
        // This use of forwardChain will not find hypotheses, because
        // rules.and does not produce statements with hypotheses.
        step4 = rules.forwardChain(conj1, taut1);
      }
      var step5 = (target.isCall2('=>')
                   ? (rules.rewriteOnly(step4, '',
                                        'a => (b => c) == a & b => c')
                      .andThen('arrangeAsms'))
                   : step4);
      var step6 = (target.hasHyps || equation.hasHyps
                   ? rules.asHypotheses(step5)
                   : step5);
      return step6.justify('replace', arguments, [target, equation]);
    },
    inputs: {site: 1, equation: 3}, // plus further constraints
    form: ('Replace site with right side of equation <input name=equation>'),
    menu: 'replace using a step like {term} = . . .',
    description: 'replace {site};; {in step siteStep} {using step equation}',
    labels: 'basic'
  },

  // Like Rule R', based on 5240 (the Deduction Theorem).  The
  // proof here is a subset of the proof of 5240.
  //
  // h_equation is an equation implied by hypotheses, i.e. H => A = B.
  // h_c is a term implied by the same hypotheses, i.e. H => C.
  // The path is relative to h_c, and may include a special initial
  // segment 'main', which it interprets as 'right' if h_c has
  // hypotheses, otherwise ignoring it.
  //
  // Accepts a plain equation with no hypotheses, applying rule R.
  //
  // Otherwise the equation must have hypotheses, and the result will
  // have hypotheses.
  //
  // Note: When generating a no-op equation, it is desirable to make
  // the LHS and RHS be the same object (and same as the target),
  // because rule R will recognize the no-op.
  //
  // TODO: Support h_c_arg with assumptions and a leftward path by
  //   ignoring that there are assumptions.
  //
  // TODO: Change this to conjoin any assumptions in the two input
  //   steps and let simplifications clean up the assumptions later.
  rplace: {
    action: function(h_equation_arg, h_c_arg, path) {
      var args = [h_equation_arg, h_c_arg, path];
      path = Toy.path(path, h_c_arg);
      var h_c = h_c_arg;
      var h_equation = h_equation_arg;
      if (h_equation.isCall2('=')) {
        // Allow "replace" to be used for situations where "r" is
        // applicable.  The case with hypotheses in h_c can be
        // considered as rule RR (5202).
        var result = rules.r(h_equation, h_c, path);
        return result.justify('rplace', args,
                              [h_equation_arg, h_c_arg]);
      }
      // h_equation must have the form H => A = B
      assert(h_equation.isEquation(), 
             'Not an equation: {1}', h_equation);
      // Note: If this assertion is removed the rule appears to work
      // if both inputs are plain conditionals with identical
      // antecedents.
      assert(h_equation.hasHyps,
             'Plain conditional equation in rules.rplace:', h_equation);

      if (h_c.hasHyps && path.isLeft()) {
        assert(false, 'Not supporting paths into assumptions in rplace');
      }

      // Give the two WFFs the same hypotheses.  If either
      // input has hyps, both of these will have hyps.
      h_c = rules.appendStepHyps(h_c, h_equation);
      h_equation = rules.prependStepHyps(h_equation, h_c_arg);

      // Normalize the hypotheses, but only if there is really
      // something to merge.  This detects that both inputs have been
      // transformed.
      if (h_c != h_c_arg && h_equation != h_equation_arg) {
        var merger = rules.conjunctionsMerger(h_c.getLeft());
        h_c = rules.r(merger, h_c, '/left');
        h_equation = rules.r(merger, h_equation, '/left');
      }

      // Now both wffs are implications with the same LHS.  Call it "h".
      var h = h_equation.getLeft();
      if (!h_c.hasHyps) {
        // If there are no hypotheses, we did not attempt to make the
        // LHS of the two input steps match.
        assert(h_c.isCall2('=>') && h_c.getLeft().matches(h),
               'LHS mismatch in "replace" rule',
               h_c_arg);
      }

      // equation is A = B
      var equation = h_equation.getRight();
      var c = h_c.getRight();

      // Path relative to c.  This is one segment shorter than the
      // input path, but is the same length if hyps were added to h_c
      // by appendStepHyps, i.e. h_equation_arg had them but not
      // h_c_arg.
      var cpath = (h_equation_arg.hasHyps && !h_c_arg.hasHyps
                   ? path
                   : path.getRight());

      // TODO: In case C is an equivalence, apply 5239 to the equation
      //   and the RHS of C (which is q below), shortening cpath one
      //   more step, giving [h => (q == r)], where r is the result of
      //   replacing the target part of the RHS of C using the
      //   equation.  Apply this tautology to get the desired result:
      //
      //   (h => (p == q)) & (h => (q == r)) => (h => (p == r))

      var boundNames = c.boundNames(cpath);
      Toy.removeExcept(boundNames, equation.freeVars());
      var hypFreeNames = h.freeVars();
      var step1 = rules.asImplication(h_equation);
      for (var name in boundNames) {
        // Check the variable is not free in any hypotheses.
        // TODO: Do appropriate checking in 5235 and impliesForall as well.
        assert(!hypFreeNames.hasOwnProperty(name),
               'Conflicting binding of {1} in {2}', name, c, h_c_arg);
        // Make sure each name bound in the target site is wrapped in a
        // "forall" in the equation.
        // TODO: If use of hasHyps goes away, this can become an appropriate
        //   use of toForall.
        var step1 = rules.toImplyForall(name, step1);
      }
      var step2 = rules.r5239(c, cpath, equation);
      var tautology = rules.tautology('(p => q) & (q => r) => (p => r)');
      var step4 = rules.p2(step1, step2, tautology);
      var taut2 = rules.tautology('(h => p) & (h => (p == q)) => (h => q)');
      var result = rules.p2(h_c, step4, taut2);
      if (h_c_arg.hasHyps || h_equation_arg.hasHyps) {
        result = rules.asHypotheses(result);
      }
      if (result.matches(h_c_arg)) {
        // Help the UI eliminate steps that re no-ops.
        // TODO: Consider if this can be better optimized.
        result = h_c_arg;
      }
      return result.justify('rplace', args, [h_equation_arg, h_c_arg]);
    },
    inputs: {equation: 1, site: 2}, // plus constraints.
    form: ('Replace selection with right side of step <input name=equation>'),
    menu: 'replace using term like {term} = A',
    tooltip: 'replace term with something equal',
    description: 'replace {site};; {in step siteStep} {using step equation}',
    labels: 'uncommon'
  },
    
  /**
   * Same as "rplace", but replaces an occurrence in target of the right
   * side of the equation with its left side.  Accepts hypotheses.
   *
   * TODO: Modify this the target arg comes first, consistent with most
   * other rules.
   */
  rRight: {
    action: function(equation, target, path) {
      path = Toy.path(path);
      var rev = rules.eqnSwap(equation);
      var result = rules.rplace(rev, target, path);
      return result.justify('rRight', arguments, [target, equation]);
    },
    inputs: {equation: 1, site: 2},
    form: ('Replace with left side of step <input name=equation>'),
    menu: 'replace using term like A = {term}',
    tooltip: ('Replaces an occurrence of a term with an equal term,'
              + ' replacing right side with left side.'),
    description: 'replace {site};; {in step siteStep} {using step equation}',
    labels: 'uncommon'
  },

  // Ambidextrous "rplace" that tries matching the equation LHS, but
  // can also replace right-to-left.  Applies rules.replaceIsEquiv if
  // these do not match.
  rplaceEither: {
    action: function(target, _path, equation) {
      var path = Toy.path(_path);
      var lhs = equation.getMain().getLeft();
      var rhs = equation.getMain().getRight();
      var expr = target.get(path);
      if (expr.matches(lhs)) {
        return rules.rplace(equation, target, path)
          .justify('rplaceEither', arguments, [target, equation]);
      } else if (expr.matches(equation.getMain().getRight())) {
        return (rules.rRight(equation, target, path)
                .justify('rplaceEither', arguments, [target, equation]));
      } else if (rhs.isCall2('=') && expr.matches(rhs.getLeft())) {
        // Apply the more complex rule "inline", so it displays and
        // not this rule.
        return rules.replaceIsEquiv(target, path, equation);
      } else {
        Toy.err('Expression ' + expr + ' matches neither side of ' +
                equation);
      }
    },
    inputs: {site: 1, equation: 3},
    form: ('Replace this using equation step <input name=equation>'),
    menu: 'Replace {term} with equal term (old-style)',
    tooltip: ('Replaces an occurrence of a term with an equal term'),
    description: 'replace {site};; {in step siteStep} {using step equation}',
    // TODO: Do offer this rule, like replaceConjunct, when there is a
    //   suitable equation(s) to use with it.
    labels: ''
  },

  // Ambidextrous replace that tries matching the equation LHS, but
  // can also replace right-to-left.
  replaceEither: {
    action: function(target, _path, equation) {
      // TODO: Figure out what to do about Toy.path!
      var path = Toy.path(_path);
      var lhs = equation.getMain().getLeft();
      var rhs = equation.getMain().getRight();
      var expr = target.get(path);
      assert(expr, 'Target {1} has no path {2}', target, path);
      if (expr.matches(lhs)) {
        return rules.replace(target, path, equation)
          .justify('replaceEither', arguments, [target, equation]);
      } else if (expr.matches(equation.getMain().getRight())) {
        var step1 = rules.eqnSwap(equation);
        return (rules.replace(target, path, step1)
                .justify('replaceEither', arguments, [target, equation]));
      } else if (rhs.isCall2('=') && expr.matches(rhs.getLeft())) {
        // Apply the more complex rule "inline", so it displays and
        // not this rule.
        return rules.replaceIsEquiv(target, path, equation);
      } else {
        Toy.err('Expression ' + expr + ' matches neither side of ' +
                equation);
      }
    },
    inputs: {site: 1, equation: 3},
    form: ('Replace this using equation step <input name=equation>'),
    menuGen: function(ruleName, step, term, proofEditor) {
      return Toy.format('replace {1} with equal term (old-style)', term);
      // TODO: Finish this.
      var ed = proofEditor;
      var result;
      for (var i = 0; i < ed.steps.length; i++) {
      }
    },
    tooltip: ('Replaces an occurrence of a term with an equal term'),
    description: 'replace {site};; {in step siteStep} {using step equation}',
    labels: 'basic'
  },

  // Add hypotheses to the target step from hypStep.  This is key to
  // providing two steps with the same hypotheses in preparation for
  // applying various rules of inference.  If hypStep has no
  // hypotheses, the result is simply the target step.  Otherwise if
  // the target has no hypotheses, it "inherits" them from hypstep, no
  // matter if it is a conditional.
  appendStepHyps: {
    action: function(target, hypStep) {
      if (hypStep.hasHyps) {
        if (target.hasHyps) {
          if (target.getLeft().matches(hypStep.getLeft())) {
            // Hyps are the same, so no change to the given step.
            return target;
          }
          var step = rules.asImplication(target);
          var taut = Toy.parse('(h1 => p) => ((h1 & h2) => p)');
          var subst = {
            h1: step.getLeft(),
            h2: hypStep.getLeft(),
            p: step.getRight()
          };
          var step1 = rules.tautInst(taut, subst);
          var step2 = rules.modusPonens(step, step1);
          var hyped = rules.asHypotheses(step2);
          flagHyps(hyped, target);
          flagHyps(hyped, hypStep);
          // Rendering of result needs hypStep rendered, so include it as dep.
          return (hyped
                  .justify('appendStepHyps', arguments, [target, hypStep]));
        } else {
          // The target does not have hyps.
          var subst = {
            p: target,
            h2: hypStep.getLeft()
          };
          var step1 = rules.tautInst('p => (h2 => p)', subst);
          var step2 = rules.modusPonens(target, step1);
          var hyped = rules.asHypotheses(step2);
          flagHyps(hyped, target);
          flagHyps(hyped, hypStep);
          // Rendering of result needs hypStep rendered, so include it as dep.
          return (hyped
                  .justify('appendStepHyps', arguments, [target, hypStep]));
        }
      } else {
        // Don't do anything and don't display any new proof step.
        return target;
      }
    },
    inputs: {step: [1, 2]},
    menu: 'combine hypotheses',
    form: ('Add to step <input name=step1> hypotheses from step '
           + '<input name=step2>'),
    description: 'add step {step2} assumptions {to step step1}',
    labels: 'uncommon'
  },

  // Prefix hypotheses from the hypStep to the target step.  Often
  // used together with appendStepHyps.  If hypStep has no hypotheses,
  // the result is simply the target step.  Otherwise if the target
  // has no hypotheses, it "inherits" them from hypstep, no matter if
  // it is a conditional.
  prependStepHyps: {
    action: function(target, hypStep) {
      if (hypStep.hasHyps) {
        var step = rules.asImplication(target);
        if (target.hasHyps) {
          if (step.getLeft().matches(hypStep.getLeft())) {
            // Hyps are the same, so no change to the given step.
            // Don't show the call to this rule.
            return step;
          }
          var taut = Toy.parse('(h2 => p) => ((h1 & h2) => p)');
          var subst = {
            h1: hypStep.getLeft(),
            h2: step.getLeft(),
            p: step.getRight()
          };
          var step1 = rules.tautInst(taut, subst);
          var step2 = rules.modusPonens(step, step1);
          var hyped = rules.asHypotheses(step2);
          flagHyps(hyped, target);
          flagHyps(hyped, hypStep);
          // Rendering of result needs hypStep rendered, so include it as dep.
          return (hyped
                  .justify('prependStepHyps', arguments, [target, hypStep]));
        } else {
          var subst = {
            p: step,
            h1: hypStep.getLeft()
          };
          var step1 = rules.tautInst('p => (h1 => p)', subst);
          var step2 = rules.modusPonens(step, step1);
          var hyped = rules.asHypotheses(step2);
          flagHyps(hyped, target);
          flagHyps(hyped, hypStep);
          // Rendering of result needs hypStep rendered, so include it as dep.
          return (hyped
                  .justify('prependStepHyps', arguments, [target, hypStep]));
        }
      } else {
        // Don't display this no-op inference step.
        return target;
      }
    },
    inputs: {step: [1, 2]},
    menu: 'combine hypotheses',
    form: ('To step <input name=step1> prefix the hypotheses of step '
           + '<input name=step2>'),
    description: 'add step {step2} assumptions {to step step1}',
    labels: 'uncommon'
  },

  // Given a step A, a path to its selected subexpression b, and an
  // equation step containing an equation of the form (b = c), this
  // proves (b = c => (B = B')), where B is either A, or if A is a
  // call to "==" or "=>", the appropriate top-level subexpression of
  // A, and B' is B with the referenced occurrence of b replaced by c.
  // If step B has the form C => D or C == D and the subexpression is
  // part of C or D, uses C or D as appropriate in place of B.  If the
  // equation step is an equivalence (or conditional), this uses its
  // RHS as the equation.
  //
  // Extracts subexpressions from the input steps, but does not need
  // either one to be proved; they just provide convenient access to
  // terms and parts of terms for application of r5239.
  //
  // This offers one approach to solving simultaneous equations,
  // in which the equations are in separate steps rather than
  // being conjoined.  Generally preferred now for practical
  // reasons is replaceConjunct.
  replaceIsEquiv: {
    action: function(step, path_arg, eqnStep) {
      var path = Toy.path(path_arg);
      var wff = step.wff;

      // A boolean part of the step:
      var targetWff = wff;
      // Path to the target, relative to targetWff:
      var targetPath = path;
      // TODO: "==" would be preferable to "=", but we can't ensure it
      // will be that here.
      if (wff.isCall2('=') || wff.isCall2('=>')) {
        targetWff = path.isLeft() ? wff.getLeft() : wff.getRight();
        targetPath = path.rest;
      }
      var target = targetWff.get(targetPath);

      var eqn;
      var eqnWff = eqnStep.wff;
      function test(term, pth) {
        if (term.isCall2('=') && term.getLeft().matches(target)) {
          return term;
        }
      }
      // searchMost finds the rightmost occurrence, which seems best.
      var eqn = eqnStep.searchMost(test);
      assert(eqn, 'Occurrence of {1} = ... not found', target.toUnicode());
      var result = rules.r5239(targetWff, targetPath, eqn);
      return result.justify('replaceIsEquiv', arguments, []);
    },
    inputs: {site: 1, equation: 3},
    form: ('Replace this using equation step <input name=equation>'),
    menu: 'replace giving equivalent',
    description: ('replace {site};; ' +
                  '{in step siteStep} {using step equation}'),
    labels: 'uncommon'
  },


  ////
  //// Rewriting -- beyond Andrews' textbook
  ////

  // Takes a proof step, a path, and a proved step, typically an
  // equation.  The part of the step at the given path must match the
  // LHS of the equation.  Replaces that part of the step with the
  // appropriate instance of the equation.  The step and equation may
  // have hypotheses.  Suitable for use from the UI when needed.
  //
  // If the equation argument is not an equation according to
  // isEquation, rewrites its main part to <main> = T and operates on
  // that as the equation.
  //
  // TODO: Consider renaming _free_ variables introduced into the step
  //   by the equation so they are distinct from all free variables
  //   that were already in the equation.  Doing so would enable
  //   maximum flexibility in following substitutions, though it raises
  //   issues about access to the potentially new variable(s).
  rewriteOnlyFrom: {
    action: function(step, path, eqn_arg) {
      var expr = step.get(path);
      var isEqn = eqn_arg.isEquation();
      var matchPart = (isEqn
                       ? eqn_arg.eqnLeft()
                       : eqn_arg.isCall2('=>')
                       ? eqn_arg.getRight()
                       : eqn_arg);
      // Convert to an actual equation if necessary.
      var equation = (isEqn
                      ? eqn_arg
                      // Coerce to an equation.
                      : eqn_arg.andThen('rewriteOnly',
                                        '/rt', 'a == (a == T)'));
      var map = expr.findSubst(matchPart);
      if (!map) {
        Toy.fail(Toy.format('Fact not applicable: {1}', equation));
      }
      var simpler = rules.instMultiVars(equation, map);

      // Beta-reduce expansions created during matching.  These must
      // make the equation LHS match so the replace rule can apply.
      // Where possible, this also applies beta reduction to
      // occurrences of "expanded" variables on the RHS as well.
      var expansions = map['%expansions'];
      if (expansions) {
        // The substitution expands one or more variables.
        for (var name in expansions) {
          // Array of paths to _all_ free occurrences of the variable
          // in the equation, not just those needed to make its LHS
          // match.
          var paths = equation.locateFree(name);
          for (var i = 0; i < paths.length; i++) {
            // Reverse path to one occurrence of the variable.
            var revPath = paths[i];
            // Count of expansions done for this variable.
            var count = expansions[name];
            while (count--) {
              var p = revPath.rest.reverse();
              var term = simpler.get(p);
              // Do a beta reduction if possible.
              if (term instanceof Call && term.fn instanceof Lambda) {
                simpler = rules.simpleApply(simpler, p);
                // If successful go up one level in the parse tree.
                revPath = revPath.rest;
              } else {
                break;
              }
            }
          }
        }
      }
      // Do the actual replacement.
      var result = rules.replace(step, path, simpler);
      return result.justify('rewriteOnlyFrom', arguments, [step, eqn_arg]);
    },
    inputs: {site: 1, equation: 3},
    form: ('Primitive rewrite using equation step <input name=equation>'),
    menu: 'primitive rewrite',
    description: 'rewrite {site};; {in step siteStep} {using step equation}',
  },

  // Variant of rules.rewrite for use from the UI, when the equation
  // is a proof step, not a well-known fact; otherwise the same as
  // rules.rewrite.
  rewriteFrom: {
    action: function(step, path, equation) {
      return (rules.rewrite(step, path, equation)
              .justify('rewriteFrom', arguments, [step, equation]));
    },
    inputs: {site: 1, equation: 3},
    form: ('Rewrite the site using step <input name=equation>'),
    menu: 'rewrite',
    description: 'rewrite {site};; {in step siteStep} {using step equation}',
    labels: 'basic'
  },

  // Primitive rewriter with no simplification; accepts a statement.
  // In the UI, could be used with well-known facts, but probably better
  // to just offer users rewriteOnlyFrom.
  rewriteOnly: {
    action: function(step, path, statement) {
      return (rules.rewriteOnlyFrom(step, path, rules.fact(statement))
              .justify('rewriteOnly', arguments, [step]));
    },
    inputs: {site: 1, bool: 3},
    form: ('(Primitive) rewrite {term} using fact <input name=bool>'),
    menu: 'primitive rewrite using a fact',
    isRewriter: true,
    description: 'use;; {shortFact} {&nbsp;in step siteStep}',
    labels: 'primitive'
  },

  // Version of the rewrite rule good for general use in code and for
  // indirect use in the UI with well-known facts.  (In the display
  // this does not give access to the proof of the fact.)  This
  // simplifies assumptions including numeric type assumptions after
  // rewriting.
  rewrite: {
    action: function(step, path, statement) {
      // Can throw; tryRule will report any problem.
      var fact = rules.fact(statement);
      var step2 = rules.rewriteOnly(step, path, fact);
      var reduced = rules.reduceRealAsms(step2);
      var arranged = rules.arrangeAsms(reduced);
      // Does not include the fact as a dependency, so it will not
      // display as a separate step.
      return arranged.justify('rewrite', arguments, [step]);
    },
    autoSimplify: function(step) {
      var inStep = step.ruleArgs[0];
      var path = step.ruleArgs[1];
      var stmt = step.ruleArgs[2];
      if (Toy.isDistribFact(stmt)) {
        var step1 = rules.arrangeTerm(step, path.concat('/right'));
        var step2 = rules.arrangeTerm(step1, path.concat('/left'));
        var step3 = rules.simplifyStep(step2);
        return step3;
      } else if (!(step.wff.isCall2('=>') && path.isLeft())) {
        // The left part may already be transformed,
        // and the target may not even exist.
        var simp1 = rules.autoSimplifySite(step,
                                           // Site of the rewrite.
                                           step.ruleArgs[1],
                                           // Input step of the rewrite.
                                           step.ruleArgs[0]
                                           );
        // Don't do even basic simplifications if simplifying the site
        // did nothing.  This is intended to avoid automatically
        // undoing rewrites that "de-simplify".
        // Perhaps this functionality could go in autoSimplifySite.
        return (simp1 == step) ? step : rules.simplifyStep(simp1);
      }
    },
    inputs: {site: 1, bool: 3},
    form: ('Rewrite {term} using fact <input name=bool>'),
    menu: 'rewrite using a fact',
    isRewriter: true,
    description: 'use;; {shortFact} {&nbsp;in step siteStep}'
  },

  // E-Rule (5244), specified by a step and name.  Checks first for
  // assumptions preceding a boolean term containing the variable,
  // then for a simple conditional with it in the antecedent.
  eRule: {
    precheck: function(step, name) {
      var map = (step.matchPattern('a => (p => q)')
                 || step.matchPattern('p => q'));
      // Returns the map if all preconditions are OK.
      return (map && (!map.a || !map.a.freeVars()[name]) &&
              map.p.freeVars()[name] &&
              !map.q.freeVars()[name] &&
              map);
    },
    action: function(step, name) {
      var map = Toy._actionInfo;
      if (map.a) {
        var qstep = rules.toForall1(step, name);
        return (rules.rewrite(qstep, '/main/left', rules.existImplies())
                .justify('eRule', arguments, [step]));
      } else {
        var qstep = rules.toForall0(step, name);
        return (rules.rewrite(qstep, '/main', rules.existImplies())
                .justify('eRule', arguments, [step]));
      }
    },
    inputs: {step: 1, varName: 2},
    form: ('In step <input name=step>, existentially quantify ' +
           '<input name=varName>'),
    menu: 'existentially quantify',
    tooltip: ('Existentially quantify antecedent'),
    description: '&exist; {var};; {in step step}'
  },

  // E-Rule (5244), specified by a step and a path to an occurrence of
  // a free variable.  The variable must occur free in a suitable part
  // of the step.
  eRule2: {
    precheck: function(step, path) {
      var v = step.get(path);
      var name = v.isVariable() && v.name;
      return rules.eRule.precheck(step, name);
    },
    action: function(step, path) {
      var name = step.get(path).name;
      // Note that this rule is currently inline.
      return rules.eRule(step, name);
    },
    inputs: {site: 1},
    form: '',
    menu: ('[A => B] to [&exist; A => B]'),
    tooltip: 'Existentially quantify antecedent',
    description: '&exist; {site};; {in step step}',
    labels: 'basic'
  },

  ////
  //// Conjunction management
  //// 

  // NOTE: A chain of conjuncts (or other binary operator) is an
  // expression that can be written a & b & ... & z.  An expression
  // that does not have the operator at top-level is a chain of one
  // conjunct.  A chain of two elements is of the form a & b, where a
  // itself is a chain.
  
  // Given a chain of at least two conjunctions, derives an equation
  // with the chain as LHS and RHS similar but with the rightmost
  // chain element bubbled into place in the RHS.  When the "less"
  // function returns true, its first argument should appear before
  // the second.
  //
  // While bubbling left, removes duplicates.
  bubbleLeft: {
    action: function(chain, less) {
      // This does all the work except the justification of the subproof.
      function bubble(eqn) {
        // TODO: Specialize the code slightly to work with hypotheses.
        var expr = eqn.getRight();
        var a = expr.getLeft();
        var b = expr.getRight();
        // expr is a & b
        if (a.isCall2('&')) {
          // expr is a & b & c
          var c = b;
          b = a.getRight();
          a = a.getLeft();
          // Eqn is lhs = (a & b) & c
          if (b.matches(c)) {
            // RHS is a & b & b
            var simpler =
              rules.rewriteOnly(eqn, '/right',
                                rules.tautology('a & b & b == a & b'));
            // Keep bubbling the rightmost to the left.
            return bubble(simpler);
          } else if (less(c, b)) {
            // Replace the equation's RHS according using associativity.
            var assoc = rules.tautology('a & b & c == a & c & b');
            var map = expr.findSubst(assoc.getLeft());
            var assocInstance = rules.instMultiVars(assoc, map);
            var step1 = rules.r(assocInstance, eqn, '/right');
            // Then recursively bubble the C in A & C to its proper place.
            var step2 = rules.bubbleLeft(step1.get('/right/left'), less);
            // Replace the A & C in RHS of step1 with the result.
            var step3 = rules.r(step2, step1, '/right/left');
            // and replace the RHS of the argument with the final result.
            return step3;
          } else {
            // C is in place.
            return eqn;
          }
        } else {
          // Base case: Eqn is lhs = a & b.
          if (a.matches(b)) {
            return rules.rewriteOnly(eqn, '/right',
                                     rules.tautology('a & a == a'));
          } else if (less(b, a)) {
            return rules.rewriteOnly(eqn, '/right',
                                     rules.tautology('a & b == b & a'));
          } else {
            // B is properly placed.
            return eqn;
          }
        }
      }
      var equation = rules.eqSelf(chain, chain);
      var result = bubble(equation);
      return result.justify('bubbleLeft', arguments, [equation]);
    }
  },

  // Given an equation with RHS that is a conjunction of two chains of
  // conjunctions, derives an equation with the same LHS, but with the
  // last expression of the first chain moved to the end of the
  // second.  If the first chain has only one element, the result is
  // just the new second chain.
  mergeRight: {
    action: function(eqn) {
      var expr = eqn.getRight();
      // The merge step moves the last element of the left chain to
      // the end of the right chain.
      expr.assertCall2('&');
      var mover = (expr.getLeft().isCall2('&')
                   ? rules.tautology('(a & b) & c == a & (c & b)')
                   : rules.tautology('a & b == b & a'));
      var result = rules.rewriteOnly(eqn, '/right', mover);
      return result.justify('mergeRight', arguments, [eqn]);
    },
  },

  // Internal rule for conjunctionsMerger, with a comparator parameter.
  mergeConj: {
    action: function(expr, less) {
      expr.assertCall2('&');
      var eqn = rules.eqSelf(expr);
      if (expr.getRight().isCall2('&')) {
        // The right chain is nontrivial, combine the chains.
        while (eqn.getRight().getLeft().isCall2('&')) {
          // The left chain has at least 2 elements.
          var eqn1 = rules.mergeRight(eqn);
          var chain2 = eqn1.get('/right/right');
          var eqn3 = rules.bubbleLeft(chain2, less);
          eqn = rules.r(eqn3, eqn1, '/right/right');
        }
        // Always simplify at least once since the RHS is assumed to be
        // made of two chains.  This time the first chain will disappear
        // as its one element moves to the second chain.
        eqn = rules.mergeRight(eqn);
        var chain2 = eqn.getRight();
      } else {
        var chain2 = expr;
      }
      var eqn3 = rules.bubbleLeft(chain2, less);
      return rules.r(eqn3, eqn, '/right');
    },
  },

  // From a term that is a conjunction of two normalized chains of
  // conjunctions, derive an equation that has the input as its LHS
  // and as its RHS has conjuncts ordered by asmLess, with
  // duplicates eliminated.
  conjunctionsMerger: {
    action: function(expr) {
      // TODO: Consider whether this line needs to use Toy.hypIsless.
      var result = rules.mergeConj(expr, Toy.asmLess);
      return result.justify('conjunctionsMerger', arguments);
    },
    inputs: {bool: 1},
    // Too technical to expose for most users.
    // form: ('Conjunctions to merge: <input name=bool>'),
    menu: 'Derives an equation to merge chains of input conjunctions',
    description: 'merge conjunctions in {bool}'
  },    

  // Extract the given hypothesis from the given step.  The hypothesis
  // need only match one of the step's hypotheses.  Relies on the step
  // to have normalized (flattened) hypotheses.  If the step is of the
  // form h1 ... hn => A, and h is one of the hypotheses, this
  // derives h1 ... hn => (h => A).
  //
  // TODO: Consider removing this. 
  extractHypothesis2: {
    // TODO: Make a version that runs in much less than exponential
    // time.  You can use the same tautology down to some depth and
    // combine it with ones resembling (h & h1) = (h & h1 & h) to
    // piece together larger tautologies.
    action: function(step, hyp) {
      var infix = Toy.infixCall;
      assert(step.hasHyps, 'Step has no hypotheses');
      var lhs = step.getLeft().hypLocater(hyp);
      var a = varify('a');
      var taut = infix(infix(lhs, '=>', a),
                       '=>',
                       infix(lhs,
                             '=>',
                             infix(varify('h'), '=>', a)));
      var step1 = rules.asImplication(step);
      var step2 = rules.forwardChain(step1, rules.tautology(taut));
      var result = rules.asHypotheses(step2);
      return result.justify('extractHypothesis2', arguments, [step]);
    },
    inputs: {step: 1, bool: 2},
    form: ('Make assumption <input name=bool> explicit '
           + 'in step <input name=step>'),
    description: 'make assumption {bool} explicit;; {in step step}',
    labels: 'deprecated',
    tooltip: 'copy an assumption to the consequent'
  },

  // Given a proof step of the form [h => a] and a path that refers to
  // an element "e" of h taken as a conjunction chain, derives a step
  // of the form [h' => (e => a)] where e is the referenced element,
  // and h' is h with all occurrences of "e" removed.  The result
  // has hypotheses iff the input proof step has hypotheses.
  //
  // If e is h, returns [h => a] without hypotheses.
  //
  // TODO: Specify what to do if h does not satisfy the preconditions.
  extractHypAt: {
    action: function(step, path) {
      var result = rules.extractHyp(step, step.get(path));
      return result.justify('extractHypAt', arguments, [step]);
    },
    inputs: {site: 1},
    form: '',
    menu: 'move to conclusions',
    tooltip: 'move assumption to the conclusions',
    labels: 'uncommon'
  },

  // Like extractHypAt, taking its hypotheses as a term to be matched.
  // Useful for pulling out implicit assumptions such as variable
  // types.
  //
  // TODO: Specify what to do if h does not satisfy the preconditions.
  extractHyp: {
    action: function(step, hyp_arg) {
      var hyp = termify(hyp_arg);
      assert(step.isCall2('=>'));
      if (hyp.matches(step.getLeft())) {
        var result = rules.asImplication(step);
      } else {
        var taut = rules.tautology(step.getLeft().hypMover(hyp));
        var step1 = rules.rewriteOnly(step, '/left', taut);
        var taut2 = rules.tautology('a & b => c == a => (b => c)');
        // Result has hyps iff input step has hyps.
        var result = rules.rewriteOnly(step1, '', taut2);
      }
      return result.justify('extractHyp', arguments, [step]);
    },
    inputs: {step: 1, bool: 2},
    menu: 'extract an assumption',
    form: 'extract assumption <input name=bool> from step <input name=step>',
    description: 'extract assumption {bool};; {in step step}',
    labels: 'basic',
    tooltip: 'extract an assumption'
  },

  // Simplifies hyps => (a => b) to hyps & a => b. 
  useAsHyp: {
    action: function(step) {
      var taut = rules.tautology('a => (b => c) == a & b => c');
      var result = rules.rewriteOnly(step, '', taut);
      return result.justify('useAsHyp', arguments, step);
    },
    inputs: {step: 1},
    form: 'step <input name=step>',
    menu: Toy.mathText('[h => (p => q)] to [h & p => q]'),
    labels: 'uncommon',
    description: 'absorb antecedent into the assumptions'
  },

  // Efficiently proves that the given chain of conjuncts imply the
  // specific conjunct "c", which must match one of them.  Proves
  // by cases on the truth of "c", where the T case is simple, and
  // the F case is proved by breaking down the chain into smaller
  // chains until the occurrence of "c" is found.
  //
  // TODO: At least simplify this to prove (and remember?) the
  // underlying tautology, and apply the tautology using tautInst.
  // Or generalize to lists of optionally negated disjuncts.
  conjunctsImplyConjunct: {
    action: function(conjuncts, c) {
      var infix = Toy.infixCall;
      var tautFX = rules.tautology('F & x == F');
      // Prove that "hyps = F", where hyps is a chain of conjuncts.
      // One conjunct must be "F".
      function falsify(hyps) {
        if (hyps.isCall2('&')) {
          if (hyps.getRight().matches(F)) {
            return rules.tautInst('p & F == F', {p: hyps.getLeft()});
          } else {
            var left = hyps.getLeft();
            var falsy = falsify(left);
            var eqn = rules.eqSelf(hyps);
            var step1 = rules.rplace(falsy, eqn, '/right/left');
            return rules.rewriteOnly(step1, '/right', tautFX)
          }
        } else if (hyps.matches(F)) {
          return rules.eqSelf(F);
        }
        assert(false, 'Bad input to falsify!');
      }
      var map = new Toy.TermMap();
      conjuncts.eachHyp(function (h) { map.addTerm(h); });
      assert(map.has(c), 
             'Must be one of the conjuncts: {1}', c);
      var cVar = map.get(c);
      // Make a schema for the desired theorem.
      var goalSchema = infix(buildHypSchema(conjuncts, map), '=>', cVar);
      // Make a version of the theorem with T for "c".
      var trueGoal = goalSchema.subFree1(T, cVar);
      // This is a simple tautology:
      var trueCase = rules.tautInst('p => T', {p: trueGoal.getLeft()});
      // Make a version of the theorem with F for "c".
      var falseGoal = goalSchema.subFree1(F, cVar);
      // Prove that its LHS is equal to F.
      var step1 = falsify(falseGoal.getLeft());
      // This means the LHS implies F, which is the desired F case.
      var taut = rules.tautology('p = F => (p => F)');
      var falseCase = rules.forwardChain(step1, taut);
      // Complete proof of the desired schema:
      // TODO: Consider replacing use of rules.cases here with another
      // similar rule.
      var step2 = rules.casesTF(trueCase, falseCase, cVar);
      // Instantiate back to get the desired instance:
      var result = rules.instMultiVars(step2, map.subst);
      return result.justify('conjunctsImplyConjunct', arguments);
    }
  },

  // Treats conj as a tree of conjunctions.  Equates it with a
  // deduplicated and "linearized" version, omitting occurrences of T.
  // The result will conform to the ordering of terms defined by the
  // Array.sort comparator.
  conjunctionArranger: {
    // Implemented by building an appropriate equivalence tautology,
    // proving it with rules.tautology, and instantiating.
    //
    // TODO: The tautology could be proved in a linear number of proof
    // steps.  For a list A of conjunctions, pre-prove [A => Ai] for
    // each member of A.  Use these to prove each conjunct separately,
    // then build the equal list with rules.and.  Also prove in the
    // opposite direction if desired.
    action: function(conj, comparator) {
      var map = new Toy.TermMap();
      var infix = Toy.infixCall;
      function transform(term) {
        if (term.isCall2('&')) {
          return infix(transform(term.getLeft()), '&',
                       transform(term.getRight()));
        } else if (term.sameAs(T)) {
          // Return it without mapping it to a variable.
          return T;
        } else {
          return map.addTerm(term);
        }
      }
      var schema = transform(conj);

      // Create a list of the variables for terms that will go into the
      // RHS of the result equation, sorted by the desired ordering of
      // the terms themselves.
      
      function compare(a, b) {
        return comparator(a.value, b.value);
      }
      var keepTermsInfo = Toy.sortMap(map.subst, compare);
      // The desired list of variables:
      var keepTerms = keepTermsInfo.map(function(pair) { return pair.key; });
      var rewriter = Toy.infixCall(schema, '==',
                                   Toy.chainCall('&', keepTerms, T));
      var result = rules.instMultiVars(rules.tautology(rewriter), map.subst);
      return result.justify('conjunctionArranger', arguments);
    }
  },

  // Derives a step with hypotheses deduplicated and ordered as by
  // asmComparator, including removal of occurrences of T.
  // Works with hypotheses and with plain implications.
  // TODO: Make this much faster by using sets of tautologies that
  //   show conjuncts imply a single one of its conjuncts, and using
  //   those to build the rearranged conjunction.
  arrangeAsms: {
    action: function(step) {
      if (!step.isCall2('=>')) {
        return step;
      }
      var deduper =
        rules.conjunctionArranger(step.getLeft(), Toy.asmComparator);
      var result = rules.rplace(deduper, step, '/left');
      return result.justify('arrangeAsms', arguments, [step]);
    },
    inputs: {step: 1},
    form: 'Step to simplify: <input name=step>',
    tooltip: 'remove redundant hypotheses',
    labels: 'uncommon'
  },

   // Prove an equation asserting that two chains of conjunctions are
   // equal by showing that their schemas are a tautology.
  equalConjunctions: {
    action: function(equation) {
      var termMap = new Toy.TermMap();
      var lhs = buildHypSchema(equation.getLeft(), termMap);
      var rhs = buildHypSchema(equation.getRight(), termMap);
      var taut = rules.tautology(Toy.infixCall(lhs, '=', rhs));
      return rules.tautInst(taut, termMap.subst);
    },
    inputs: {equation: 1},
    form: 'Equation of conjunctions: <input name=equation>',
    tooltip: 'prove equality of two chains of conjunctions',
    labels: 'uncommon'
  },

  ////
  //// From the section "Equality and descriptions" in the book.
  ////

  equalitySymmetric: {
    statement: '(x = y) == (y = x)',
    proof: function() {
      var x = varify('x');
      var y = varify('y');
      var step1 = rules.assume('x = y');
      var step2 = rules.eqSelf(x);
      var step3 = rules.rplace(step1, step2, '/left');
      var step4 = rules.asImplication(step3);
      var subst = {x: y, y: x};
      var step5 = rules.instMultiVars(step4, subst);
      var step6 = rules.makeConjunction(step4, step5);
      var taut = rules.tautology('(p => q) & (q => p) => (p == q)');
      return rules.forwardChain(step6, taut);
    },
    inputs: {},
    form: '',
    description: 'symmetry of equality',
    labels: 'algebra'
  },

  equalityTransitive: {
    statement: 'x = y & y = z => x = z',
    proof: function() {
      var step1 = rules.axiom2();
      var step2 = rules.instVar(step1, Toy.parse('{t. t = z}'), varify('h'));
      var step3 = rules.apply(step2, '/right/left');
      var step4 = rules.apply(step3, '/right/right');
      var taut = rules.tautology('(a => (b = c)) => (a & c => b)');
      return rules.forwardChain(step4, taut);
    },
    inputs: {},
    form: '',
    description: 'transitivity of equality',
    labels: 'basic'
  },

  rewriteInDepth: {
    action: function(step, path, facts) {
      var equation = rules.deepTermReplacer(step.get(path), facts);
      var result = rules.rplace(equation, step.get(path));
      return result.justify('rewriteInDepth', arguments);
    },
  },    

  // Proves an equation that can replace the given term.  Applies the
  // given List of equational facts recursively, traversing the term
  // bottom-up, applying the first fact that succeeds to each
  // subexpression.  Returns an equation with the term on the LHS and
  // the replacement on the right.  Does not transform results of
  // transformations.
  //
  // TODO: Extend to take a conversion function in place of the facts.
  // TODO: Unused, consider removing.
  deepTermReplacer: {
    action: function(term, facts) {
      var step = rules.eqSelf(term);
      var step1;
      if (term instanceof Call) {
        var stepFn = rules.deepTermReplacer(term.fn, facts);
        var stepArg = rules.deepTermReplacer(term.arg, facts);
        step1 = step.rplace('/right/fn', stepFn)
          .rplace('/right/arg', stepArg);
      } else {
        step1 = step;
      }
      var result = Toy.each(facts, function(fact) {
          try {
            return rules.rewriteOnly(step, '/right', fact);
          } catch(e) {}
        });
      result = result || step1;
      return result.justify('deepTermReplacer', arguments);
    }
  },

  // Proves an equation that can replace the given boolean term.
  // Applies itself recursively to the given List of equational facts,
  // descending into the arguments of conjunctions (a & b), bottom-up,
  // applying the first fact (if any) that succeeds to each subexpression.
  // Returns an equation with the term on the LHS and the replacement
  // on the right.
  //
  // TODO: Extend to take a conversion function in place of the facts.
  conjunctsSimplifier: {
    action: function(term, facts) {
      var step = rules.eqSelf(term);
      var step1;
      if (term.isCall2('&')) {
        var stepLeft = rules.conjunctsSimplifier(term.getLeft(), facts);
        var stepRight = rules.conjunctsSimplifier(term.getRight(), facts);
        step1 = (step.rplace('/right/left', stepLeft)
                 .rplace('/right/right', stepRight));
      } else {
        step1 = step;
      }
      var result = Toy.each(facts, function(fact) {
          try {
            return rules.rewriteOnly(step1, '/right', fact);
          } catch(e) {}
        }) || step1;
      try {
        var taut = rules.tautology('a & (b & c) == a & b & c');
        result = rules.rewriteOnly(result, '/right', taut);
      } catch(e) {}
      return result.justify('conjunctsSimplifier', arguments);
    }
  },

  // If the given statement is a proved step, returns the input.
  // Otherwise coerces it to a fact synopsis and looks that up in the
  // facts database, matching only against the "main" parts of facts.
  //
  // If it is not proved and does not match a recorded fact, attempts
  // to prove it as a tautologies or simple arithmetic fact.  Removes
  // any " = T" from boolean-valued arithmetic facts.  Programmatic
  // usage supports theorems by name, but not the UI.  Accepts a
  // string value.
  //
  // If a fact or synopsis is conditional, its consequent portion
  // is used for the matching during lookup.
  //
  // For some cases - tautologies, proved statements, and theorems
  // in particular, this rule is inline.
  //
  // TODO: Add a separate "realFact" rule for looking up facts about
  //   real numbers, and match the more concise forms only in that rule,
  //   making "fact" more straightforward.
  fact: {
    action: function(synopsis) {
      if (typeof synopsis === 'string') {
        var proved = _factMap[synopsis];
        if (proved) {
          // console.log('FACT: found ', synopsis);
          return proved.justify('fact', arguments);
        }
      }
      if (Toy.isProved(synopsis)) {
        // It is an already proved statement.
        return synopsis;
      }
      // Try named theorems (not available from the UI).
      var result = Toy.getTheorem(synopsis);
      if (result) {
        return result;
      }
      // This is the full statement (goal) of the fact.
      var stmt = findFact(synopsis);
      // Try ordinary proved facts.
      if (stmt) {
        var getSynopsis = Toy.getSynopsis;
        var fact = Toy.getResult(stmt);
        // Maps free variables of the fact into ones given here.
        var map = getSynopsis(fact).alphaMatch(getSynopsis(synopsis));
        var instance = rules.instMultiVars(fact, map);
        ((typeof synopsis === 'string') && (_factMap[synopsis] = instance));
        return instance.justify('fact', arguments);
      }
      // Next try arithmetic facts.
      stmt = termify(synopsis);
      if (stmt.isEquation()) {
        var result = Toy.tryArithmetic(stmt.eqnLeft());
        if (result && result.alphaMatch(stmt)) {
          return result.justify('fact');
        }
      } else {
        // Relational operators can go here.
        var result = Toy.tryArithmetic(stmt);
        // x = T is the expected result.
        if (result && result.matchSchema('x = T')) {
          return (rules.rewriteOnly(result, '', '(x = T) = x')
                  .justify('fact'));
        }
      }
      // Try tautologies.
      try {
        // Inline for tautologies.  Call looksBoolean to avoid ugly
        // and unnecessary errors from rules.tautology.
        return (Toy.looksBoolean(stmt)
                ? rules.tautology(stmt)
                : err(''));
      } catch(err) {}
      Toy.err('No such fact: ' + synopsis);
    },
    inputs: {string: 1},
    form: ('Look up fact <input name=string size=40>'),
    autoSimplify: noSimplify,
    menu: 'look up a fact',
    tooltip: (''),
    description: function(step) {
      var info = lookupFactInfo(step.ruleArgs[0]);
      var d = info && info.description;
      return d || 'fact';
    },
    labels: 'basic'
  },

  // Traditionally in lambda calculus (use of) this is referred to as
  // "eta conversion".
  eta: {
    statement: '{x. p x} = p',
    labels: 'higherOrder',
    converse: {labels: 'higherOrder'},
    proof: function() {
      // fact1 is: forall {x. {x. p x} x = p x}
      var fact1 = rules.axiom4('{x. p x} x').andThen('toForall', 'x');
      // fact2 is: <fact1> == {x. p x} = p
      var fact2 = (rules.axiom3()
                   .andThen('eqnSwap')
                   .andThen('instMultiVars', {f: '{x. p x}', g: 'p'}));
      return rules.r(fact2, fact1, '');
    },
    // When used as a simplifier, this seems to interact badly in some
    // cases with higher-order matching.  An example is proving andExists
    // with assertFacts == false.
    // simplifier: true,
    description: 'eta conversion'
  },

  // Derive exists {x. p x} from a witnessing term.  This only replaces the
  // selected occurrence, not substituting throughout. (5242)
  eQuantify: {
    precheck: function(step, path) {
      var term = step.get(path);
      var type = Toy.findType(term);
      // The current check merely excludes booleans.
      // TODO: Improve this when types are truly available.  Support
      //   predicates and functions of individuals, et cetera.
      return type !== Toy.boolean;
    },
    action: function(step, path_arg) {
      var path = Toy.path(path_arg, step);
      var term = step.get(path);
      var v = step.wff.freshVar('x');
      function replacer(term) { return v; }
      var replaced = step.wff.replaceAt(path, replacer);
      var test = Toy.lambda(v, replaced);
      var eqn = rules.axiom4(call(test, term));
      assert(eqn.getRight().matches(step.wff));
      // This is the step, converted to be application of predicate to term.
      var step2 = rules.r(rules.eqnSwap(eqn), step, '');
      var fact = rules.fact('p x => exists p');
      var result = rules.forwardChain(step2, fact);
      return result.justify('eQuantify', arguments, [step]);
    },
    inputs: {site: 1},
    form: '',
    menu: "A to &exist; x. A'",
    description: 'existentially quantify',
    labels: 'basic'
  },

  // 5304
  exists1a: {
    statement: 'exists1 {y. p y} == exists {y. p = {x. x = y}}',
    proof: function() {
      var step = (rules.eqSelf('exists1 {y. p y}')
                  .andThen('useDefinition', '/right/fn')
                  .andThen('apply', '/right'));
      return rules.r(rules.eta(), step, '/right/arg/body/left');
    }
  },

  // From unique existence for p conclude an equivalence with "the"
  // (iota) for all x.
  //
  // Simplified statement of 5312, using "the" in place of iota.
  // You can use exists1The to replace "the" with "iota".
  exists1Forall: {
    // TODO: In this example the occurrence of "forall" could be
    // removed, leaving all occurrences of "x" free.  Consider how
    // to do practical matching in such cases.
    statement: 'exists1 p => forall {x. p x == x = the p}',
    proof: function() {
      var a1 = rules.assume('p = {x. x = y}');
      var step1 = (rules.axiom5()
                   .andThen('replaceEither', '/left/arg', a1));
      var step2 = rules.replaceEither(a1, '/right/right/body/right', step1);
      var step3 = (rules.axiom3()
                   .andThen('instMultiVars', {f: 'p', g: '{x. x = iota p}'})
                   .andThen('apply', '/right/arg/body/right'));
      var step4 = (rules.replace(step2, '/right', step3)
                   .andThen('toForall0', 'y'));
      var map = {p: '{y. p = {x. x = y}}',
                 q: 'forall {x. p x == x = iota p}'};
      var step5 = (rules.existImplies()
                   .andThen('instMultiVars', map)
                   .andThen('simpleApply', '/left/arg/body/left'));
      var step6 = (rules.trueBy(step5, '/left', step4)
                   .andThen('rewriteOnly', '', '(T == x) == x'));
      var step7 = (rules.consider('exists1 p')
                   .andThen('useDefinition', '/left/fn')
                   .andThen('simpleApply', '/left'));
      var step8 = rules.rewrite(step6, '/left', step7);
      var loc8 = step8.find('iota p');
      var step9 = rules.replace(step8, loc8,
                                (rules.exists1The()
                                 .andThen('eqnSwap')));
      return step9;
    }
  },

  /* TODO: Remove these two as not very useful.
  ifTrue: {
    statement: 'c => if c x y = x',
    proof:function() {
      var assumed = rules.assume('T == c');
      var fact = rules.fact('if T x y = x');
      return (fact.andThen('replace', fact.find('T'), assumed)
              .andThen('rewriteOnly', '/left', 'T == x == x'));
    }
  },

  ifFalse: {
    statement: 'not c => if c x y = y',
    proof:function() {
      var assumed = rules.assume('F == c');
      var fact = rules.fact('if F x y = y');
      return (fact.andThen('replace', fact.find('F'), assumed)
              .andThen('rewriteOnly', '/left', 'F == x == (not x)'));
    }
  },
  */

  exists1The: {
    statement: 'exists1 p => the p = iota p',
    proof: function() {
      var assumed = rules.assume('exists1 p');
      var step1 = rules.fact('the p = if (exists1 p) (iota p) none');
      var loc1 = step1.find('exists1 p');
      return (step1.andThen('trueBy', loc1, assumed)
              .rewrite('/right/right', 'if T x y = x'));
    }
  },


  //
  // OPTIONAL/UNUSED
  // 

  // Experiment with Andrews' definition of "and".
  funWithAnd: {
    statement: ('{x. T} = {x. ((x T T) = (x T F))} == ' +
                '(forall {x. ((x T T) = (x T F))})'),
    proof: function() {
      var f = varify('f');
      var g = varify('g');
      var fa = rules.definition('forall');
      var a2 = rules.axiom2();
      var a3 = rules.axiom3();
      var step1 = rules.applyBoth(rules.defAnd(), T);
      var step2a = rules.apply(step1, '/right');
      var step2b = rules.applyBoth(step2a, F);
      var step2c = rules.apply(step2b, '/right');
      var step3 = rules.instEqn(a3, step2c.get('/right/left'), f);
      var step4 = rules.instEqn(step3, step2c.get('/right/right'), g);
      var step5 = rules.apply(step4, '/right/arg/body/left');
      var step6 = rules.apply(step5, '/right/arg/body/right');
      var step7 = rules.applyBoth(fa, step6.get('/right/arg'));
      var step8 = rules.instEqn(a3, step7.get('/right/left'), f);
      var step9 = rules.instEqn(step8, step7.get('/right/right'), g);
      var step10 = rules.apply(step9, '/right/arg/body/left');
      var step11 = rules.apply(step10, '/right/arg/body/right');
      var step12 = rules.r5218(step11.get('/right/arg/body/right'));
      return rules.r(step12, step11, '/right/arg/body');
    }
  }
};  // End of ruleInfo.


//// FACTS

// The fact information is organized with the synopsis as
// a map key to take advantage of debug printing of the functions
// in the Chrome debugger.

var logicFacts = {
  // Logic
  '(T = a) == a': {
    proof: function() {
      return rules.theorem('tIsXIsX');
    },
    simplifier: true
  },
  '(a = T) == a': {
    proof: function() {
      return rules.theorem('tIsXIsX')
      .andThen('rewriteOnly', '/left', 'equalitySymmetric');
    },
    simplifier: true
  },

  // Somewhat useful fact to stick at the end of the list.
  'not F': {
    proof: function() {
      return rules.tautology('not F');
    }
  },

  '(T => a) == a': {
    proof: function() {
      return rules.tautology('(T => a) == a');
    },
    simplifier: true
  },

  '(a != b) == not (a = b)': {
    proof: function() {
      return (rules.eqSelf('a != b')
              .andThen('useDefinition', '/right')
              .andThen('apply', '/right/fn')
              .andThen('apply', '/right'));
    }
  },

  'x = x == T': {
    proof: function() {
      return (rules.eqSelf('x')
              .andThen('rewriteOnly', '', 'a == (a == T)'));
    },
    simplifier: true
  },

  'ident x = x': {
    proof: function() {
      return (rules.eqSelf('ident x')
              .andThen('useDefinition', '/right/fn')
              .andThen('simpleApply', '/right'));
    },
    simplifier: true
  },

  'negate p = {x. not (p x)}': {
    proof: function() {
      return (rules.consider('negate p').andThen('apply', '/right'));
    }
  },

  '(negate p) x == not (p x)': {
    proof: function() {
      return (rules.consider('(negate p) x')
              .andThen('apply', '/right/fn')
              .andThen('apply', '/right'));
    }
  },

  // This is the classic definition of the existential quantifier,
  // proved from a concise definition.  We could have made a
  // technically correct definition based directly on this.
  'exists p == not (forall {x. not (p x)})': {
    proof: function() {
      var all = (rules.axiom3()
                 .andThen('instMultiVars', {f: 'p', g: '{x. F}'})
                 .andThen('apply', '/right/arg/body/right')
                 .rewrite('/right/arg/body', '(a == F) == (not a)'));
      return (rules.eqSelf('exists p')
              .andThen('useDefinition', '/right/fn')
              .andThen('apply', '/right')
              .rewrite('/right', 'x != y == not (x = y)')
              .andThen('rewriteOnlyFrom', '/right/arg', all));
    },
    desimplifier: true
  },

  'exists {x. not (p x)} == not (forall p)': {
    proof: function() {
      var step1 = (rules.fact('exists p == not (forall {x. not (p x)})')
                   .andThen('instMultiVars', {p: 'negate p'})
                   .andThen('rewriteOnly', '/left/arg', 'negate p = {x. not (p x)}'));
      var loc1 = step1.find('negate p x');
      return (step1.andThen('rewriteOnly', loc1, 'negate p x = not (p x)')
              .andThen('simplifySite', '/right/arg')
              .andThen('rewriteOnly', '/right/arg/arg', '{x. p x} = p'));
    }
  },

  // This has the core reasoning for 5242, existential generalization
  // (EGen / eQuantify).
  //
  // TODO: Consider adding a rule that converts an arbitrary step with
  //   selected term to an application of a lambda to the selected term.
  //   The code for that is in eQuantify.
  //
  // TODO: Consider for each of the above, a rule that replaces
  //   another occurrence of the same term with the new bound
  //   variable.  For existential quantification, the rule may need to
  //   look at the step from which the selected one is derived, to
  //   determine whether it is such an occurrence.
  'p x => exists p': {
    proof: function() {
      return (rules.r5225()
              .andThen('instVar', '{x. not (p x)}', 'p')
              .andThen('apply', '/right')
              .andThen('rewriteOnly', '',
                       'a => not b == b => not a')
              .andThen('rewriteOnly', '/right',
                       'not (forall {x. not (p x)}) == exists p'));
    }
  },

  'if T = {x. {y. x}}': {
    proof: function() {
      return (rules.consider('if T')
              .andThen('apply', '/right')
              .andThen('simplifySite', '/right/body/body/arg/body')
              .andThen('rewriteOnly',
                       '/right/body/body', 'iota {x. x = y} = y'));
    }
  },

  'if T x y = x': {
    proof: function() {
      return (rules.consider('if T x y')
              .andThen('rewriteOnly', '/right/fn/fn', 'if T = {x. {y. x}}')
              .andThen('apply', '/right/fn')
              .andThen('apply', '/right'));
    },
    simplifier: true
  },

  'if F = {x. {y. y}}': {
    proof: function() {
      return (rules.consider('if F')
              .andThen('apply', '/right')
              .andThen('simplifySite', '/main/right/body/body/arg/body')
              .andThen('rewriteOnly',
                       '/right/body/body', 'iota {x. x = y} = y'));
    }
  },

  'if F x y = y': {
    proof: function() {
      return (rules.consider('if F x y')
              .andThen('rewriteOnly', '/right/fn/fn', 'if F = {x. {y. y}}')
              .andThen('apply', '/right/fn')
              .andThen('apply', '/right'));
    },
    simplifier: true
  },

  'exists {y. y = x}': {
    proof: function() {
      return (rules.fact('p x => exists p')
              .andThen('instVar', '{y. y = x}', 'p')
              .andThen('simpleApply', '/left')
              .andThen('simplifySite', ''));
    }
  }
};

//// FACTS

/**
 * Accepts a "prover" function of no arguments and a goal statement
 * (Expr).  The prover may be null, in which case this generates
 * a trivial prover that asserts the goal.
 *
 * Returns a function to construct and return a proved statement from
 * the arguments.  The returned function runs the prover to prove the
 * goal.  When running the prover, the returned function also attempts
 * to use exactly the free variables in the goal, and arranges the
 * assumptions accordingly.  It warns if assumptions do not match up
 * with the goal, and raises an error if the main part if it cannot
 * make the main part match exactly.
 *
 * Internal to addFact and addSwappedFact.
 */
function asFactProver(prover, goal) {
  assert(!prover || typeof prover === 'function',
         'Not a function: {1}', prover);
  // This function wraps around the user-supplied fact prover
  // to do the generic parts of the work.
  function factProverWrapper() {
    var result;
    if (goal.isProved()) {
      result = goal;
    } else if (!prover) {
      // The proof is just a stub not yet filled in.
      console.warn('No proof for fact', goal.toUnicode());
      result = rules.assert(goal);
      return (result.isCall2('=>')
              ? rules.asHypotheses(result)
              : result);
    }
    var result = prover();
    // Seek a substitution into the result that yields the goal.
    var subst = result.alphaMatch(goal);
    // TODO: Check that substitutions exist, but don't actually do
    //   substitutions here.  Now rules.fact substitutes as needed to
    //   use the variables desired at each use.
    if (subst) {
      return rules.instMultiVars(result, subst);
    } else {
      // Try matching the main parts of the result and goal.
      // Reorder any assumptions as needed.
      var subst2 = result.getMain().alphaMatch(goal.getMain());
      if (subst2) {
        // The main parts match up to change of variables.
        var proved = (rules.instMultiVars(result, subst2)
                       .andThen('arrangeAsms'));
        if (proved.matches(goal)) {
          return proved;
        }
        var conjSet = Toy.makeConjunctionSet;
        var empty = new Toy.TermSet();
        var goalAsms = goal.isCall2('=>') ? conjSet(goal.getLeft()) : empty;
        var factAsms = proved.isCall2('=>') ? conjSet(proved.getLeft()) : empty;
        if (!goalAsms.superset(factAsms)) {
          console.group('Warning: Fact requires unintended assumptions.');
          console.error('Proved:', proved.toString());
          console.error('Stated:', goal.toString());
          console.groupEnd();
          assert(false, 'Fact statement is missing some assumptions');
        }
        if (!factAsms.superset(goalAsms)) {
          console.group('Note: Fact statement has unneeded assumptions.');
          console.info('Proved:', proved.toString());
          console.info('Stated:', goal.toString());
          console.groupEnd();
        }
        return proved;
      } else {
        assert(false, 'Instead of {1} proved {2}', goal, result);
      }
    }
  }
  return factProverWrapper;
}


// Private to lookupFactInfo and setFactInfo.  Maps from a canonical
// string "dump" of a fact to fact info, consisting of:
//
// synopsis (optional): synopsis string
// goal: Expr statement of the fact, with all assumptions
// labels: object / set of labels like the ones for rules
// simplifier: true if this is an equation that simplifies
// desimplifier: true if this is an equation that "desimplifies"
// noSwap: if true, inhibits automatic generation of a fact
//   with equation LHS and RHS swapped
// prover: function intended to prove the fact
// proved: proved statement or falsy if not yet proved
var _factsMap = {};

/**
 * Access any fact info stored for the given statement, which can be
 * anything recognized by getStatementKey.  If the statement is
 * conditional, getStatementKey only uses the consequent for lookup.
 */
function lookupFactInfo(stmt) {
  return _factsMap[getStatementKey(stmt)];
}

/**
 * Set fact info for the given statement.  See comments on _factsMap
 * and fact management functions for the expectations on the
 * argument.
 */
function setFactInfo(info) {
  _factsMap[getStatementKey(info.goal)] = info;
}

/**
 * Like getResult, below, but always proves the statement if it has
 * an associate prover function.
 */
function proveResult(stmt) {
  return getResult(stmt, true);
}

/**
 * Accepts an already-proved step or the full statement of some
 * recorded fact.  Returns a proof of the step, or one like it except
 * for changes of names of variables including free variables.  Throws
 * an exception in case of failure.
 *
 * Note that the facts database currently looks up facts by their
 * "main" part, ignoring any assumptions.
 *
 * The optional second argument, for internal use only, if true,
 * overrides any setting of Toy.assertFacts and assures that a proved
 * result will be returned (if there is a prover function).
 *
 * TODO: Consider renaming to something like "stepify" and using as
 *   a conversion for inputs to steps in the vein of "termify".
 */
function getResult(statement, mustProve) {
  if (Toy.isProved(statement)) {
    return statement;
  }
  var info = lookupFactInfo(statement);
  assert(info, 'Not a recorded fact: {1}', statement);
  // TODO: Consider more precise checking of the result of the lookup.
  if (info.proved) {
    return info.proved;
  }
  var prover = info.prover;
  if (Toy.assertFacts && !mustProve) {
    var result = rules.assert(info.goal);
    if (result.isCall2('=>')) {
      // Treat any conditional as having hypotheses.
      //
      // TODO: Skipping this might provide a good test for the system
      //   working with conditionals directly.
      result = rules.asHypotheses(result);
    }
    return result;
  }
  info.inProgress = true;
  // Get the proved result of the fact.
  info.proved = prover();
  assert(info.proved instanceof Expr);
  // Note that the fact remains in progress if its prover throws, which
  // may or may not be good thing.
  info.inProgress = false;
  return info.proved;
}

/**
 * Returns true iff a proof of this statement is underway but not
 * completed.  Can be used to prevent infinite regress, as in the case
 * of simplifiers that might be skipped during their own proof.
 */
function isInProgress(stmt) {
  if (!lookupFactInfo(stmt)) {
    // It could be a tautology, but not a recorded fact.
    return false;
  }
  return lookupFactInfo(stmt).inProgress;
}

// Cache of statement keys for statements that are in the form of
// strings, as is often the case in lists of facts.  The policy
// is to compute the mapping once and remember it forever, but
// in principle this is a cache.
_statementKeys = {};

/**
 * Given a term or string that parses to one, returns a string key
 * usable for looking up information about the fact.  If the statement
 * is conditional, the key represents its consequent; otherwise it
 * represents the entire statement.
 *
 * TODO: Rename this to indicate that it only uses the consequent in
 *   generating the key.  Or perhaps better, move this functionality
 *   into its uses and support storing the same fact under multiple
 *   keys, for example one based on just the consequent and another
 *   based on the entire statement.
 */
function getStatementKey(stmt) {
  // If the statement is a string, look in the cache.
  if (typeof stmt === 'string') {
    var cached = _statementKeys[stmt];
    if (cached) {
      return cached;
    }
  }
  // This currently uses toString, which is sensitive to aliases
  // in particular "==" for "=", compared with "dump", which is not.
  // TODO: Determine what to do about facts such as pure logic facts,
  //   which are generic across types, and implement accordingly.
  // TODO: Use stmt just as a synopsis here.
  var key = Toy.standardVars(getSynopsis(stmt)).toString();
  if (typeof stmt === 'string') {
    _statementKeys[stmt] = key;
  }
  return key;
}

/**
 * Returns the portion of the given statement to use as the synopsis,
 * parsing it from a string if needed.  Fact lookup encodes this as a
 * string "statement key".
 */
function getSynopsis(stmt) {
  return termify(stmt).getMain();
}

/**
 * Tests whether a fact with the given statement is recorded in the
 * facts database.  The fact need only be recorded, not proved.
 * Accepts a term or parseable string.
 */
function isRecordedFact(stmt) {
  return !!lookupFactInfo(stmt);
}

/**
 * Looks for a fact recorded in the facts database by addFact or
 * addRule.  The input must be a term or string parseable into a term,
 * as for getStatementKey.  The database uses only the RHS of
 * conditional facts as a lookup key, and accordingly this function
 * matches an unconditional argument as the key.  Or if the argument
 * is conditional, it only matches the RHS against the stored key.  At
 * present no further checking is done here.
 *
 * Returns a statement of the fact, generally not the proved fact,
 * or null if no such fact was found.
 */
function findFact(stmt) {
  var info = lookupFactInfo(stmt);
  return info ? info.goal : null;
}


//// Finding matching facts

/**
 * Finds a single LHS match within the given term with one of the
 * given facts.  Returns the value of the successful call to
 * findMatchingFact, with a "path" property added indicating the path
 * from the term argument to the matched term, or a falsy value if no
 * call succeeded.
 *
 * All arguments other than the term are passed via "info".  If it is
 * a plain object, it interprets the following properties:
 *
 * facts: List of facts in the format accepted by findMatchingFact.
 * context: Context information for "where" clauses as
 *   accepted by findMatchingFact.
 *   TODO: (BUG!) Accept an "isQuantified" property here, or more 
 *      detailed information, to indicate enclosing bound variables.
 * searchMethod: Name of method to apply to the term to control
 *   which subexpressions of the term to apply findMatchingFact to;
 *   defaults to 'searchCalls', which searches through calls.
 *
 * If the info is an array, it must be the list of facts.
 *
 * TODO: Consider changing this to something like applyMatchingFactIn,
 *   doing essentially the same search, but attempting to apply the
 *   first fact that seems to match, and continuing the search if
 *   application fails.
 */
function searchForMatchingFact(term, info) {
  var allFacts, searchMethod;
  var cxt = {};
  if (info.constructor === Object) {
    allFacts = info.facts;
    info.context && Object.assign(cxt, info.context);
    searchMethod = info.searchMethod;
  } else {
    allFacts = info;
  }
  // If set to non-null, just unconditional facts.  At present only
  // includes facts that are just a statement in string form.
  // Computed here for efficiency.
  //
  // TODO: Handle more complicated facts (as needed).
  var pureFacts = null;
  function isPureFact(fact) {
    if (typeof fact === 'string' || fact instanceof Expr) {
      // This next line supports ordinary facts and also tautologies.
      // It relies on findFact to return a conditional whenever
      // it is given a statement that has implicit assumptions.
      var fullFact = findFact(fact) || termify(fact);
      return fullFact && fullFact.isCall2('=');
    } else if (fact.constructor === Object && fact.pure) {
      return true;
    }
  }
  searchMethod = searchMethod || 'searchMost';
  function factFinder(term, revPath, isQuantified) {
    if (isQuantified) {
      pureFacts = pureFacts || allFacts.filter(isPureFact);
    }
    // If some free variables of a conditional fact do not appear in
    // its condition(s), this may exclude it unnecessarily.
    // TODO: Consider a more precise check here.
    var facts = isQuantified ? pureFacts : allFacts;
    var result = findMatchingFact(facts, cxt, term, isQuantified);
    if (result) {
      result.path = revPath.reverse().concat(result.path);
    }
    return result;
  }
  return term[searchMethod](factFinder);
}

/**
 * Searches the given pattern list for one that matches the given
 * term.  If it finds one, returns info about it in a plain object
 * in the format described below.
 *
 * The context argument is available to "where" arguments as "cxt",
 * and any "factLists" property of the context defines lists of named
 * patterns accessible by using the name in place of an explicit list.
 * The value of the factLists property is a plain object mapping from
 * list name to a list (array) value.  In this way lists can be
 * reused, and also enables them to be effectively recursive.
 *
 * If pureOnly is true, this only accepts a fact that is a pure
 * equation, with no conditions on it.
 * 
 * Each pattern argument can be an argument acceptable to
 * getStatementKey, or:
 *
 * A plain object with properties as follows:
 *
 * stmt: value acceptable to getStatementKey.  Unless "match" is also
 *   given this will need to be an equation.
 * where: optional string to evaluate, with "subst" 
 *   argument to findMatchingFact available as "$" and cxt and term
 *   available as free variables for use in the string.
 *   OR if it is a function, call it with the substition, cxt, and
 *   term as arguments.
 * match: term schema to match against the term.  (By default the
 *   term is matched against the stmt LHS.)
 *   TODO: Consider removing this; there is only one use.
 *
 * For fact statements passed as list elements or the "stmt" property
 * of a list element, if proof of the fact is in progress at the time,
 * the fact is ignored in the search.  This provides a crude mechanism
 * for avoiding infinite regress, for example when simplifying steps
 * of the proof of a simplifier fact.
 *   
 * Or it can be a plain object with a single property, either:
 *
 * descend: a plain object with properties "schema", a schema
 *   (possibly in string form) to match against the term, and "parts",
 *   a plain object mapping from variable names in this schema each to
 *   a pattern list as described above. If the search reaches this
 *   "descend" item and the schema matches the term, the search
 *   descends into the parts of the term, applying each schema
 *   variable's list of facts to the part of the term matching that
 *   schema variable.
 *
 * apply: a function to apply to the input term and context, which
 *   must return an equation whose LHS is the same as the term except
 *   for possible changes of bound variables, or a falsy value if it
 *   fails to produce such an equation.  The call is done by
 *   Toy.normalReturn, and this uses the value returned from that.
 *
 * The value returned is falsy if no match is found, else a plain
 * object with properties:
 * 
 * stmt: Relevant fact statement, proved or not, or the equation
 *   returned by an "apply" pattern.
 * term: the term argument to findMatchingFact.
 * subst: substitution that makes the given term match the fact (empty for
 *   "apply" patterns).
 * path: path to the portion of the given term that matched some pattern.
 *
 * TODO: Consider changing this to something like "applyMatchingFact",
 *   attempting to apply the first fact that appears to match, and
 *   continuing the search if the application fails.
 */
function findMatchingFact(facts_arg, cxt, term, pureOnly) {
  // This finds the fact part to match.  If the fact is not an equation,
  // uses the main part instead of the LHS.
  function schemaPart(fact) {
    var main = fact.getMain();
    return (main.isCall2('=')
            ? main.getLeft()
            : main);
  }
  function apply$(expr, $) {
    if (typeof expr === 'function') {
      return expr($, cxt, term);
    } else {
      // Suppress acccess to the enclosing "facts" variable.
      // OK for str to refer to "cxt" or "term".
      var facts;
      return eval(expr);
    }
  }
  var facts = facts_arg;
  if (typeof facts_arg == 'string' && Toy.isIdentifier(facts_arg)) {
    facts = cxt.factLists && cxt.factLists[facts_arg];
  }
  assert(facts && facts[Symbol.iterator], 'No facts: {1}', facts_arg);
  for (var it = facts[Symbol.iterator](), v = it.next(); !v.done; v = it.next()) {
    var factInfo = v.value;
    if (factInfo.constructor !== Object) {
      var stmt = factInfo;
      if (!isInProgress(stmt)) {
        var fullFact = rules.fact(stmt);
        if (!(pureOnly && fullFact.isCall2('=>'))) {
          // Use stmt to create the schema, because it may have different
          // free variables than the recorded fact.
          var schema = schemaPart(termify(stmt));
          var subst = term.matchSchema(schema);
          if (subst) {
            var result = {stmt: fullFact,
                          term: term,
                          path: Toy.path(),
                          subst: subst};
            return result;
          }
        }
      }
    } else if (factInfo.apply) {
      // "apply"
      var eqn = Toy.normalReturn(factInfo.apply, term);
      if (eqn && !(pureOnly && eqn.isCall2('=>'))) {
        var result = {
          stmt: eqn,
          term: term,
          path: Toy.path(),
          subst: {}
        };
        return result;
      }
    } else if (factInfo.descend) {
      // "descend"
      var partInfo = factInfo.descend;
      // TODO: Handle pureOnly here.
      var result = _locateMatchingFact(term,
                                       partInfo.schema,
                                       partInfo.parts,
                                       cxt);
      if (result) {
        return result;
      }
    } else {
      // All other plain objects are handled here.
      var stmt = factInfo.stmt;
      if (!(stmt && isInProgress(stmt))) {
        var fact = stmt && rules.fact(stmt);
        if (!(pureOnly && fact && fact.isCall2('=>'))) {
          var where = factInfo.where;
          var schema = (factInfo.match
                        ? termify(factInfo.match)
                        : schemaPart(fact));
          var subst = term.matchSchema(schema);
          if (subst && (!where || apply$(where, subst))) {
            var result = {stmt: stmt,
                          term: term,
                          path: Toy.path(),
                          subst: subst};
            return result;
          }
        }
      }
    }
  }
  // If no match found the value will be falsy.
};

/**
 * This handles "descend" patterns in findMatchingFact, and is private
 * to it.
 *
 * Arguments are the term argument to findMatchingFact, the schema
 * property of the "descend" pattern, the "parts" property of the
 * "descend" pattern, and the context argument to findMatchingFact.
 */
function _locateMatchingFact(expr, schema_arg, varsMap, context) {
  var schema = termify(schema_arg);
  var factLists = context.factLists;
  var subst;
  if ((subst = expr.matchSchema(schema))) {
    // Checks if the given term of the schema matches some fact
    // in the appropriate factsList, throwing information about
    // the match if found to Toy.catchResult.
    // Only schema variables are eligible to match.
    function checkTerm(schemaTerm, revPath) {
      if (schemaTerm.isVariable()) {
        var list = varsMap[schemaTerm.name];
        if (typeof list == 'string' && Toy.isIdentifier(list)) {
          list = factLists[list];
        }
        if (list) {
          var result =
            findMatchingFact(list, context, expr.get(revPath.reverse()));
          if (result) {
            result.path = revPath.reverse().concat(result.path);
            throw new Toy.Result(result);
          }
        }
      }
    }
    return Toy.catchResult(schema.traverse.bind(schema, checkTerm));
  }
}

/**
 * Find and apply one of the facts to the part of the step at the
 * given path, returning the result, or the input step if none of the
 * facts apply.  Note: uses rules.rewrite, not rewriteOnly.
 */
function applyFactsOnce(step, path, facts) {
  var info = findMatchingFact(facts, null, step.get(path));
  return info ? rules.rewrite(step, path, info.stmt) : step;
}

/**
 * Apply the list of fact rewrites to the visible part of the step
 * until none of them any longer is applicable, returning the result.
 *
 * TODO: Replace uses of this.  Provide interactive commands that are
 *   specific to the visible part.  If not interactive, use commands
 *   not dependent on visibility status.
 */
function applyToVisible(step, facts) {
  return applyFactsWithinSite(step, step.pathToVisiblePart(), facts);
}

/**
 * Apply the list of facts as rewrites to the given part of the step
 * until none of them any longer is applicable, returning the result.
 * Returns its input step if no matches are found.
 */
function applyFactsWithinSite(step, path_arg, facts) {
  var path = Toy.path(path_arg);
  var eqn1 = rules.considerPart(step, path);
  var eqn2 = applyFactsWithinRhs(eqn1, facts);
  return (eqn2 == eqn1 ? step : rules.rplace(eqn2, step, path));
}

/**
 * Apply the list of facts as rewrites to the RHS of the given step,
 * which must be an equation.  Repeats until none of them is
 * applicable, returning the result.  Returns its input step if no
 * matches are found.  Uses rules.rewrite, not rewriteOnly.
 *
 * TODO: hyps -- step is an equation.
 */
function applyFactsWithinRhs(step, facts) {
  var rhs;
  var info;
  var eqn = step;
  while (rhs = Toy.path('/main/right', eqn),
         info = searchForMatchingFact(eqn.get(rhs), facts)) {
    var fullPath = rhs.concat(info.path);
    eqn = rules.rewrite(eqn, fullPath, info.stmt);
  }
  return eqn;
}

/**
 * Apply the function to the subexpression of step at path.  The
 * function should return an equation that equates the original
 * subexpression to something else.  This replaces the subexpression
 * using the returned equation.
 *
 * Allows the function to return a falsy value, returning the same
 * value itself.
 */ 
function convert(step, path, fn) {
  var expr = step.get(path);
  assert(expr, 'Bad path {1}', path, step);
  var eqn = fn(expr);
  return eqn && rules.replace(step, path, eqn);
}

/**
 * Proves that the given term is equal to something by taking it as
 * equal to itself, applying the given equation throughout its RHS,
 * rewriting the result with the given fact, then applying the reverse
 * of the equation throughout the resulting RHS.  The term can be
 * a string, while the equation can be proved steps or statements
 * of any recorded equational fact.
 *
 * Intended to capture a design pattern for proving facts about
 * "inverse" functions such as division and subtraction.
 */
function transformApplyInvert(term_arg, eqn_arg, fact) {
  var term = termify(term_arg);
  var eqn = getResult(eqn_arg);
  var revEqn = rules.eqnSwap(eqn);
  var step1 = rules.consider(term);
  var step2 = applyFactsWithinRhs(step1, [eqn]);
  var step3 = rules.rewrite(step2, '/main/right', fact);
  var step4 = applyFactsWithinRhs(step3, [revEqn]);
  return step4;
}

/**
 * Apply the given simplification function to the equation repeatedly
 * until the result of the call is identical to its input.  Return
 * the result of the last call.
 */
function whileChanges(eqn, fn) {
  var simpler = eqn;
  var next;
  while (true) {
    next = fn(simpler);
    if (next.matches(simpler)) {
      return next;
    }
    simpler = next;
  }
}

/**
 * Applies the given facts repeatedly to the RHS of the given equation
 * until none matches, each time replacing the RHS with the result of
 * applying the matching fact.  Returns the last version created.
 */ 
function arrangeRhs(eqn_arg, context, facts) {
  var rhsPath;
  var info;
  var eqn = eqn_arg;
  while (rhsPath = Toy.path('/main/right', eqn),
         info = findMatchingFact(facts, context, eqn.get(rhsPath))) {
    var fullPath = rhsPath.concat(info.path);
    eqn = rules.rewrite(eqn, fullPath, info.stmt);
  }
  return eqn; 
}

/**
 * Arranges the given part of the given step by repeatedly applying
 * the given facts until none matches, returning a step with the part
 * replaced by the result of the rearrangement.
 *
 * As a good practice, this considers the part in isolation, only
 * replacing it in the step when done applying facts.
 */
function arrange(step, path, context, facts) {
  var eqn = rules.consider(step.get(path));
  var arranged = arrangeRhs(eqn, context, facts);
  return rules.rplace(arranged, step, path);
}

/**
 * Call the given function for each of the registered facts, passing
 * it the fact statement (goal) and the synopsis with which it was
 * created, if any.
 */
function eachFact(fn) {
  for (var key in _factsMap) {
    var f = _factsMap[key];
    fn(f);
  }
}

/**
 * Checks that the named rule is a theorem (i.e. takes no arguments),
 * and gets its result.
 *
 * TODO: Use rules.theorem instead, and remove this function.
 */
function getTheorem(name) {
  var action = rules[name];
  if (!action) {
    return null;
  }
  assert(action.length === 0, 'Rule {1} needs parameters', name);
  return action();
}

/**
 * Returns true iff the named theorem has already been proved.
 */
function alreadyProved(name) {
  if (isAxiom(name)) {
    return true;
  } else {
    return !!rules[name].result;
  }
}

/**
 * True iff the name is the name of an axiom.
 */
function isAxiom(name) {
  return name.substring(0, 5) === 'axiom';
}


//// UTILITY FUNCTIONS

/**
 * Searches the list of equational facts in order for one that matches
 * a subexpression of the given step.  In particular, the part of the
 * step at path must match with the variable in the LHS of the fact
 * having the given name, which should occur exactly once in the
 * fact's LHS.
 *
 * If this finds such a fact it returns a function of no arguments
 * that applies the fact to the step using rules.rewrite and returning
 * the result of the rewrite.
 */
function matchFactPart(step, path, factList, name) {
  return Toy.each(factList, function(fact_arg) {
    var schema = termify(fact_arg).getLeft();
    var info = step.matchSchemaPart(path, schema, name);
    if (info) {
      return function() {
        return rules.rewrite(step, info.path, fact_arg);
      };
    }
  });
}

/**
 * For each hypothesis in the given step that matches a hypothesis in
 * the "dep" step that has a sourceStep property, copy the sourceStep
 * property to the hypothesis in the step.
 *
 * This has side effects on the display of Exprs that already exist,
 * so in some contexts it might affect the display of steps you did
 * not intend to affect.
 *
 * TODO: Consider actually importing hypotheses from dep using rule R
 * to avoid the possibility of undesired side effects.
 *
 * TODO: hyps
 */
function flagHyps(step, dep) {
  if (step.hasHyps && dep.hasHyps) {
    function flag(hyp) {
      if (hyp.sourceStep) {
        // Already flagged, don't change.
        return true;
      }
      function tryFlag(source) {
        var step = source.sourceStep;
        if (step && hyp.matches(source)) {
          hyp.sourceStep = step;
          // Flag the hyp, and stop searching.
          return true;
        }
      }
      // Try to flag the hyp with the source step of one of
      // the hyps from dep.
      dep.getLeft().eachHyp(tryFlag);
    }
    step.getLeft().eachHyp(flag);
  }
}

/**
 * Build a schema for a conjunction of hypotheses, ensuring all are in
 * the TermMap, with optional exclusions, a TermSet.  The schema is of
 * the form a1 && ... && an, where the "a"s are variables for the
 * terms for each hyp in hyps.
 */
function buildHypSchema(hyps, map, exclusions) {
  var schema = null;
  hyps.eachHyp(function(hyp) {
      var v = map.addTerm(hyp);
      if (!exclusions || !exclusions.has(hyp)) {
        schema = schema ? Toy.infixCall(schema, '&', v) : v;
      }
    });
  return schema;
}

/**
 * Returns the given conjunction of hypotheses except any appearing in
 * the exclusions TermSet.  If there are no such hypotheses, returns
 * T.
 */
function hypsExcept(hyps, exclusions) {
  var result = null;
  hyps.eachHyp(function(hyp) {
      if (!exclusions.has(hyp)) {
        result = result ? Toy.infixCall(result, '&', hyp) : hyp;
      }
    });
  return result;
}

/**
 * Makes a facts map into a list of the fact keys.
 */
function listFacts(map) {
  var list = [];
  for (var key in map) {
    list.push(key);
  }
  return list;
}

/**
 * Developer utility function that modifies the named rule to emit
 * information about calls to it.
 */
function traceRule(name) {
  var rule = rules[name];
  function timed() {
    console.log('Enter', name);
    for (var i = 0; i < arguments.length; i++) {
      console.log(i, arguments[i] + '');
    }
    var t = new Toy.NestedTimer(name);
    t.start();
    var result = rule.apply(rules, arguments);
    var elapsed = t.end();
    console.log('=', result + '');
    console.log('Exit', name, elapsed, 'ms');
    return result;
  }
  timed.info = rule.info;
  rules[name] = timed;
}

/**
 * Returns the plain object with various information about the rule
 * applied to create the given step.
 */
function getRuleInfo(step) {
  return rules[step.ruleName].info;
}

/**
 * If the given step has a "site" input, this returns the path
 * of the site argument, a string or Path object.  This uses the
 * "inputs" information of the rule that generated the step to
 * determine which argument to access.
 */
function getStepSite(step) {
  var inputs = getRuleInfo(step).inputs;
  for (var type in inputs) {
    if (type in Toy.siteTypes) {
      var args = step.ruleArgs;
      // Assumes there can be only one "site" argument.
      var index = inputs[type];
      return args[index];
    }
  }
}

/**
 * Returns an array of the steps leading up to and including the given
 * step, sorted by ordinal, not including the details of any step.
 */
function proofOf(step) {
  // See also the nearly identical Toy.unrenderedDeps.
  var result = [];
  // Traverses the dependency graph, recording a copy of every step
  // and building an array of all of the original steps.  In Java
  // one might use HashSets to identify already-visited steps,
  // avoiding temporary modifications to the originals.
  function visitWithDeps(step) {
    if (!step.__visited) {
      result.push(step);
      step.__visited = true;
      step.ruleDeps.forEach(function(dep) { visitWithDeps(dep); });
    }
  }
  visitWithDeps(step);
  result.forEach(function(step) { step.__visited = false; });
  result.sort(function(s1, s2) {
      return s1.ordinal - s2.ordinal;
    });
  return result;
}

/**
 * Returns an array of steps preceding this one that establish
 * assumptions that later steps might not display, currently "assume"
 * and "replaceIsEquiv" steps; in the future perhaps other similar
 * kinds.  The result is selected steps from the result of
 * proofOf(step), based on the ruleName for the step.
 */
function assumptionsBefore(step_arg) {
  var steps = [];
  var proofSteps = proofOf(step_arg);
  proofSteps.forEach(function (step) {
      var ruleName = step.ruleName;
      if (ruleName === 'assume' ||
          ruleName === 'replaceIsEquiv') {
        steps.push(step);
      }
    });
  return steps;
}

/**
 * Returns an array of "assume" steps in the proof of the given step
 * (see Toy.proofOf) that create an assumption of the step.  Assumes
 * that the assumptions are a chain of conjuncts, which is true of
 * normalized assumptions.  Used in rendering to highlight the sources
 * of assumptions.
 */
function assumptionsUsed(step) {
  var asms = step.getAsms();
  if (!asms) {
    return [];
  }
  var asmList = [];
  asms.eachHyp(function (expr) { asmList.push(expr); });

  var steps = proofOf(step);
  var result = [];
  for (var i = 0; i < steps.length; i++) {
    var step = steps[i];
    if (step.ruleName === 'assume') {
      for (var j = 0; j < asmList.length; j++) {
        var asm = asmList[j];
        // Note that every "assume" step is a conditional.
        if (step.getRight().sameAs(asm)) {
          result.push(steps[i]);
        }
      }
    }
  }
  return result;
}

/**
 * The given Expr is treated as the root of a tree of conjuncts.
 * This searches for a direct or indirect conjunct of it that
 * passes the test.  Returns a (pretty) path to the node found,
 * or null if none is found.
 */
function pathToConjunct(root, test) {
  var Path = Toy.Path;
  function pathFrom(node) {
    if (test(node)) {
      return Path.empty;
    }
    if (node.isCall2('&')) {
      var rpath = pathFrom(node.getRight());
      if (rpath) {
        return new Path('right', rpath);
      }
      var lpath = pathFrom(node.getLeft());
      if (lpath) {
        return new Path('left', lpath);
      }
    }
    return null;
  }
  return pathFrom(root);
}

/**
 * Builds and returns a propositional schema from the given term,
 * with the structure of the tree of conjunctions rooted at the term.
 * Matching parts get the same variable letter.
 */
function conjunctionSchema(term) {
  var map = new Toy.TermMap();
  var infixCall = Toy.infixCall;
  function makeSchema(term) {
    if (term.isCall2('&')) {
      return infixCall(makeSchema(term.getLeft()), '&',
                       makeSchema(term.getRight()));
    } else {
      map.addTerm(term);
      return map.get(term);
    }
  }
  return makeSchema(term);
}

/**
 * Simplification facts for algebra, used in _simplifyMath1
 * and related places.  During initialization all facts
 * flagged as simplifier: true are added to this list.
 *
 * TODO: Consider whether x - 7 is simpler than x + -7.
 * TODO: Declare number facts as simplifiers rather than adding here.
 */
var basicSimpFacts = [
                      'T & a == a',
                      'a & T == a',
                      'F & a == F',
                      'a & F == F',
                      'T | a == T',
                      'a | T == T',
                      'F | a == a',
                      'a | F == a',
                      'not T == F',
                      'not F == T',
                      '(a == T) == a',
                      'not (not a) == a',
                      'x = x == T',
                      'T => a == a',
                      'not (a = b) == a != b',
                      '(negate p) x == not (p x)',
                      'if T x y = x',
                      'if F x y = y',
                      {stmt: 'a + neg b = a - b',
                       // This condition makes extra-sure there will be
                       // no circularity during simplification.
                       // Negation of a numeral will be simplified by
                       // other rules.
                       where: '!$.b.isNumeral()'},
                      {stmt: 'a - b = a + neg b',
                       // This one is an exception to the general rule
                       // that simplifiers make the expression tree
                       // smaller; but arithmetic will follow this, and
                       // with high priority.
                       where: '$.b.isNumeral() && $.b.getNumValue() < 0'},
                      {apply: function(term, cxt) {
                          return (Toy.isArithmetic(term) &&
                                  rules.axiomArithmetic(term));
                        }
                      }
                      // {apply: arithRight} Done in numbers.js.
                      ];


//// Initialization

var define = Toy.define;
var defineCases = Toy.defineCases;

var identity = Toy.parse('{x. x}');
var allT = Toy.parse('{x. T}');

// Put definitions into their database:
define('not', equal(F));
define('!=', '{x. {y. not (x = y)}}');
define('forall', '(=) {x. T}');
define('exists', '{p. p != {x. F}}');
define('exists1', '{p. exists {y. p = {x. x = y}}}');
defineCases('&', identity, '{x. F}');
defineCases('|', allT, identity);
defineCases('=>', identity, allT);

// This is an equivalent formulation of unique existence.
// The proof is not trivial, see for example eu1 in Metamath.
//
// TODO: Consider perhaps proving this by showing that either
//   a collection is the singleton, or empty, or has more than
//   one member.
const
  _e1a = 'exists1 p == exists p & forall {x. forall {y. p x & p y => x = y}}';
addRule({statement: _e1a});

// It would be desirable for the constants in this next group to
// all have generic types.
define('if', '{p. {x. {y. iota {z. p & z = x | not p & z = y}}}}');
// This is the empty collection.
define('empty', '{x. F}');
define('none', 'iota empty');
define('?', '{p. {x. if p x none}}');
// The identity function
define('ident', '{x. x}');
// Collection has multiple elements:
define('multi', '{p. exists {x. exists {y. p x & p y & x != y}}}');
// Always either "none" or the member of the singleton set:
define('the', '{p. if (exists1 p) (iota p) none}');
// This "negates" a predicate, returning a predicate whose value
// is the negation of the value of the given predicate.  (Just one
// argument!)
define('negate', '{p. {x. not (p x)}}');


addRulesMap(ruleInfo);
addFactsMap(logicFacts);


//// Export public names.

Toy.rules = rules;
Toy.logicFacts = logicFacts;
Toy._factsMap = _factsMap;

// Settable variables, export right here:
Toy.autoAssert = false;
Toy.assertFacts = true;

Toy.getStepCounter = getStepCounter;
Toy.noSimplify = noSimplify;

Toy.addRule = addRule;
Toy.addRulesMap = addRulesMap;
Toy.addRules = addRules;
Toy.definition = definition;
Toy.addDefnFacts = addDefnFacts;
Toy.lookupFactInfo = lookupFactInfo;
Toy.addFact = addFact;
Toy.addFactsMap = addFactsMap;
Toy.isRecordedFact = isRecordedFact;
Toy.proveResult = proveResult;
Toy.getResult = getResult;
Toy.eachFact = eachFact;
Toy.getTheorem = getTheorem;
Toy.getStatementKey = getStatementKey;
Toy.getSynopsis = getSynopsis;
Toy.convert = convert;
Toy.findFact = findFact;
Toy.findMatchingFact = findMatchingFact;
Toy.applyFactsWithinSite = applyFactsWithinSite;
Toy.applyFactsWithinRhs = applyFactsWithinRhs;
Toy.applyFactsOnce = applyFactsOnce;
Toy.applyToVisible = applyToVisible;
Toy.whileChanges = whileChanges;
Toy.arrange = arrange;
Toy.arrangeRhs = arrangeRhs;
Toy.listFacts = listFacts;
Toy.transformApplyInvert = transformApplyInvert;
Toy.matchFactPart = matchFactPart;
Toy.searchForMatchingFact = searchForMatchingFact;
Toy.getRuleInfo = getRuleInfo;
Toy.getStepSite = getStepSite;
Toy.proofOf = proofOf;
Toy.assumptionsBefore = assumptionsBefore;
Toy.assumptionsUsed = assumptionsUsed;

Toy.definition = definition;

Toy.ruleInfo = ruleInfo;
Toy.basicSimpFacts = basicSimpFacts;

Toy.traceRule = traceRule;

// For communication between an action precheck and the rule's main
// action function.
Toy._actionInfo;

// For debugging.
Toy._statementKeys = _statementKeys;

// For testing.
Toy._tautologies = _tautologies;
Toy._buildHypSchema = buildHypSchema;
Toy._alreadyProved = alreadyProved;
Toy._locateMatchingFact = _locateMatchingFact;
Toy._flagHyps = flagHyps;
Toy._pathToConjunct = pathToConjunct;
Toy._conjunctionSchema = conjunctionSchema;

})();
