// Copyright 2011 - 2018 Crispin Perdue.
// All rights reserved.
//
// This file implements the logic, its axioms, basic theorems,
// inference rules and other machinery that is relatively
// independent of the problem domain.

// This could be organized as something like:
//
// Subcore: rules and theorems needed to prove the various facts
// about truth tables.
//
// Booleans: truth table facts and probably the tautology checker.
//
// Core: full replacement, cases, and other basics.
//
// Assumptions: management and simplification of assumptions.
//
// Facts: support for facts and rewriting.

// Set all of this up immediately upon load, but avoiding changes
// to the global environment (except through the "Toy" namespace).
(function() {

// Set Toy.bookish to true before loading this file to use definitions
// from Andrews' book and no others.  Will be usable only after
// completion of r5230FTBook_almost and full implementation of the
// useDefnsByCases flag.
const bookish = Toy.bookish || false;

if (Toy.useDefnsByCases == null) {
  // TODO: Complete the support for this flag, as discussed where
  //   it is currently used.
  Toy.useDefnsByCases = !bookish;
}

//// THEOREMS AND RULES

var assert = Toy.assertTrue;

//  Make some useful names available here.
var assertEqn = Toy.assertEqn;
var varify = Toy.varify;
var constify = Toy.constify;
var termify = Toy.termify;
var mathParse = Toy.mathParse;
var call = Toy.call;
var equal = Toy.equal;
var implies = Toy.implies;
var lambda = Toy.lambda;

var Expr = Toy.Expr;
var Atom = Toy.Atom;
var Call = Toy.Call;
var Lambda = Toy.Lambda;

var memo = Toy.memo;

var define = Toy.define;
var defineCases = Toy.defineCases;

var identity = Toy.parse('{x. x}');
var allT = Toy.parse('{x. T}');

// Predefine some common constants.
var T = constify('T');
var F = constify('F');

// Map from tautology string representation to tautology,
// for proved tautologies.  Private to the tautology rule.
var _tautologies = {};

// Interactive testing support.
window.Thtest = function(x) {
  setTimeout(function() { console.log(window.Tval = eval(x)); });
};


//
// Expr methods for inference
//

/**
 * Returns a shallow copy of this, annotating the copy with the rule
 * name, rule arguments, hasHyps flag, and dependencies (ruleName,
 * ruleArgs, ruleDeps).  "This" becomes the "details" property if it
 * already has a justification.  (Axioms, definitions and assertions
 * are not generated by rules, though theorems are.)  The ruleArgs and
 * ruleDeps arrays are both optional, empty if not given.
 *
 * If this is identical to one of its ruleDeps, returns this unchanged
 * unless "retain" is true, making the step a no-op.  (The purpose is
 * to reduce clutter for readers of the proof.)
 *
 * TODO: Make a Step class for proof steps, and have this method
 * return a new one.
 *
 * TODO: Consider always recording the step, but skipping the display
 * in proof.jsc.  Some steps, especially simplifications, do this
 * same thing internally by skipping the call to "justify".
 *
 * TODO: Add a "justify0" method that never modifies assumptions,
 * or alternatively, never "arrange" them here, leaving that task
 * to rules such as "replace".
 */
Expr.prototype.justify = function(ruleName, ruleArgs, ruleDeps, retain) {
  // Note: when splitting Step and Expr, make a version of this just
  // for rules.assert, and use that in any primitive inference rules.
  var ruleDeps = jQuery.makeArray(ruleDeps || []);
  if (!retain) {
    for (var i = 0; i < ruleDeps.length; i++) {
      if (ruleDeps[i] == this) {
        // If the step returns an input step, return it as-is.
        // TODO: Consider eliminating this "optimization" and rely instead
        //   on eliding no-op steps from display.  (There is already an
        //   implementation.)
        return this;
      }
    }
  }
  var step = this;
  // At this spot we could conditionally run arrangeAsms in case the
  // step being justified is conditional.  Omitting that automagic
  // behavior for now.
  //
  // TODO: Consider modifying arrangeAsms to flag its result as
  //   "arrangedAsms", and to check on entry if a step's asms are
  //   flagged.  If so it would immediately return its input
  //   unmodified.  Presumably arrangeAsms is a pure
  //   rewriter/simplifier and thus does not introduce conditional
  //   steps, so calling it here would not result in recursive calls
  //   to it.

  // Allocate a new object to be the new Step.
  var result = (step instanceof Call
              ? new Call(step.fn, step.arg)
              : step instanceof Atom
              ? new Atom(step.pname)
              // Impossible for a step!
              : null);

  // The beginnings of a Step class.  Only steps will have the
  // following properties, with .wff accessing the top expression
  // (wff).
  //
  // Note: Likely additional Step methods: freeVars. 
  result.wff = result;
  // TODO: The "rendering" (and also "original") property is quite
  //   sparse.  Consider eliminating "original" for non-rendered steps
  //   and storing "rendering" in a WeakMap.
  result.rendering = null;
  // Record the step as details.
  // Note that above, primitive rules have no deps.
  if (Toy.isProved(this)) {
    // Except for primitive rules listed just below.
    result.details = step;
  } else {
    switch(ruleName) {
    case 'assert':
    // TODO: "define" should not have to be a special case here.
    case 'define':
    case 'definition':
    case 'r':
      break;
    default:
      assert(false, 'Input to "justify" should be a step ({1})', step);
    }
  }
  // Give the new step the specified ruleName.
  result.ruleName = ruleName;
  // Make the step be its own original, for uniform access to an original.
  // TODO: Stop doing this, to distinguish StepDisplay objects from Steps.
  result.original = result;
  // Give this step its own new ordinal.
  result.ordinal = stepCounter++;
  // Carry other information forward.
  result.hasHyps = step.hasHyps;
  result.ruleArgs = jQuery.makeArray(ruleArgs || []);
  result.ruleDeps = ruleDeps;

  return result;
};

//
// Utility functions
//

/**
 * Process a value as a set of labels.  If it is a string, convert it
 * to an object/set by treating it as a space-separated list of words.
 */
function processLabels(labels) {
  switch(typeof labels) {
  case 'string':
    var result = {};
    labels.split(/\s+/)
      .forEach(function(label) { result[label] = true; });
    return result;
  case 'object':
    return labels;
  default:
    if (labels) {
      console.error('Bad labels', labels);
    }
    return {};
  }
}

// Used to order execution of proof steps so they can display
// in order of execution in an automatically-generated proof.
// This increments on every call to "justify".
// Conceptually it could be incremented just by rule R.
var stepCounter = 1;

function getStepCounter() {
  return stepCounter;
}

/**
 * A simplification function that does nothing, useful as the
 * auto-simplifier for rules that want to suppress simplification.
 */
function noSimplify(step) {
  return step;
}

/**
 * Adjusts a path to account for application of a typical rewrite rule
 * that could prefix the path with /right, given a step that is the
 * input to the rewrite and a step that is the result of the rewrite.
 * Apply the adjustment to get the corresponding part of the output
 * given a path into the input step.
 *
 * This could give incorrect results currently in case the first step
 * is conditional but without hyps, but this will be correct when hyps
 * are gone.
 *
 * TODO: Caution, currently unused.
 */
Toy.Path.prototype.adjustForRewrite = function(input, output) {
  return (!input.isCall2('=>') && output.isCall2('=>')
          ? Toy.path('/right').concat(this)
          : this);
};

/**
 * These become methods on steps, set up by Step.justify.
 */
var ruleMethods = {

  /**
   * Applies the named rule to this Expr and any other given arguments
   * as if by a call to Toy.rules[name](args).
   */
  andThen: function(name, arg1) {
    var nm = name;
    arguments[0] = this;
    var rule = rules[nm];
    assert(rule, 'No rule with name "{1}"', nm);
    var result = rule.apply(Toy.rules, arguments);
    return result;
  },
      
  /**
   * Applies rules.rewrite to this Expr passing in a path and
   * fact to use.
   */
  rewrite: function rewrite_method(path, fact) {
    return rules.rewrite(this, path, fact);
  },

  /**
   * Applies rules.replace to this Expr passing in a path and
   * equation to use.
   */
  rplace: function(path, eqn) {
    return rules.rplace(eqn, this, path);
  }
};
Expr.addMethods(ruleMethods);


//
// Inference rules, axioms, theorems
//

// Map from rule name to function used in all proofs.
// This is a central global variable.
// Generated from ruleInfo by addRulesMap, below.
var rules = {};

//// RULE PROPERTIES

// This is structured as a map from the name of an inference rule or
// theorem to properties of the rule or theorem.
//
// The following rule properties are available directly when calling
// addRule.  In that case, pass "name" as a property along with the
// others.  When calling addRule, unnamed facts and definitions are
// also supported through the properties.
//
// Properties:
//
// action: function implementing the inference rule.
//
// proof: for a theorem (no args), use this instead of "action".
//   Do not call "justify", that is done automatically and
//   the proof is memoized.
//
// name: name of the rule, axiom or theorem; required if it is a rule
//   of inference with one or more arguments (see below).  Used to
//   look up the rule in "rules".
//
// statement: for a theorem, this string optionally states the theorem
//   proved.  In this case the theorem is also added as a fact.  If
//   the value is an equation, with or without assumptions, if its
//   converse is not already added when the theorem is added, its
//   converse will be added as a fact.  Also used by tests.  TODO:
//   Consider checking during actual proof of the theorem.
//
// definition: for a definition, this is a statement, often of the
//   form <name> = <term>, that defines the new constant name.  Once
//   the definition is made, this statement is taken as true, as if it
//   were a new axiom, but without danger of creating a contradiction.
//   Other forms can also be used as definitions if justifying facts
//   are proved.  See the function "definition" for more details.
//   
// precheck: if present, a function that must accept the same
//   arguments as the main action.  When the rule action is called, it
//   will call this automatically, followed immediately by the
//   declared action function.  The RuleMenu uses it as well, to rule
//   out inapplicable rules.
//
//   This is expected to return a falsy value if the rule is not
//   applicable to the arguments, in which case the rule will fail
//   with Toy.fail.  Otherwise it should return any data useful to the
//   main action function, which will have access to that result
//   through the global temporary Toy._actionInfo.
//
//   To call the precheck directly, refer to rules.<rulename>.precheck.
//   A call to rules.<rulename>.main will automatically receive the
//   precheck's result information if called before any other rule or
//   precheck.
//
// onFail: if a rule's action function is called in the ordinary manner,
//   and it has precheck, and the precheck fails, then its onFail
//   action will run with access to the same arguments and access
//   to the rule object as "this".
//
// inputs: map from type to argument number(s), either a single
//   number or an array if more than one such argument.
//   The supported types are:
//     step: Matches any proof step.
//     equation: Matches a proof step that is an equation.
//     implication: Matches a proof step that is an implication.
//     term: Matches any term.
//     reducible: Matches a call to anonymous function (lambda)
//     varName: Name suitable for a variable.
//     string: Arbitrary nonempty string.
//     optString: Optional arbitrary string.
//     site: Term in a step; the rule expects the term's step and path
//       to the term as inputs.
//     bindingSite: Matches a variable binding in a step (as in "changeVar").
//
// TODO: Consider defining a new form of input descriptor.  Every rule
//   with the new property would be a "fancy" rule whose action
//   function has the appropriate name, that automatically converts
//   its inputs based on its input descriptor.  For each of these
//   define a rule 'fast_' + name to be the simplest form.
//
// data: If a rule has a "data" property, set rules[ruleName] to a new
// function that binds "this" to the rule's action function, and set
// up the "data" object as the "data" property of the action function.
//
// minArgs: Number of required args for the action.  Supply a
//   value here to make trailing arguments optional in the step editor.
//
// maxArgs: Optional maximum number of args to pass to the rule.
//   Unless already present, added automatically by addRule when
//   making a rule with a "varargs" wrapper.
//
// toOffer: function of displayable step and optional term within the
//   step, or a string containing expression to return from such a
//   function, with arguments "step", and "term".  The step and term
//   in this case belong to the rendering of the step, and have type
//   annotations.  If this returns a falsy value, the step editor will
//   not offer it.
//
// form: HTML template for the rule's input form to be presented by
//   the step editor, as a template allowing {term} for the selected
//   term.  StepEditor will never offer a rule without a form
//   property, at least an empty one.
//   TODO: Separate out this kind of non-offerability.
//
// menu: plain text for the rule's menu item (may become HTML in the future),
//   as a template allowing {term} for the selected term or {right}
//   for a possible term to its right ("group with").
//
// menuGen: function to return zero or more menu entries for
//   application(s) of the rule.  It will be passed the ruleName,
//   step, selected term or null if none, and the ProofEditor for which
//   it is generating the menu.  A falsy value indicates no
//   menu entries; a non-empty string is for one entry.
//
// tooltip: plain text to become the title attribute of mentions of the
//   rule name in proof displays and the description in subproof displays.
//
// result: For theorems with no parameters only; this is the statement
//   of the theorem.  If given as text in ruleInfo, converted into an
//   expression in "rules".
//
// description: HTML word or phrase for use in one-line description,
//   or function to compute it, as in rules.fact.  If beginning with
//   "=", name of a "step formatter" in stepFormatters follows.
//   Either sort of function receives the step as argument.
//
// labels: space-separated list of words to categorize the rule,
//   influencing the rules modes in which it will be offered.
//   Defaults to "basic" if not given.  See processLabels and
//   RuleMenu.offerApproved for more details.
//
// isRewriter: true to highlight on hover like a rewrite rule.
//   TODO: Consider removing this as unnecessary.
//
// using: if present, normally the equation or implication used for
//   the rule, as for rewriters.  The equation may have conditions.
//   When working forward the left side of the main equation must
//   match the site to be operated on.
//
// inputSide: may be 'right' to indicate that the rule uses
//   the converse equality (rewrites matching the right side of the
//   equation rather than the left side).
//
// offerExample: applies to rules only, not facts.  If true and the
//   rule needs only some sort of selection as input, the step
//   suggester will run it to generate a sample next step and the
//   ruleMenu will not include it in the menu.
//

// Rule definitions that have statements (and are thus theorems)
// support the same properties as facts, specifically: simplifier,
// desimplifier, noSwap, labels, and converse (for properties of facts
// that have a swapped version).

/**
 * Given a ruleInfo object, add its information to the "rules" object.
 * The "rules" object maps from rule name to function.  Each function
 * has an "info" property containing all the properties present in the
 * ruleInfo object entry for the name.  If not supplied in the rule
 * definition, the info.inputs is defaulted to an empty object here.
 */
function addRulesMap(ruleInfo) {
  for (var key in ruleInfo) {
    var value = ruleInfo[key];
    if (value.constructor != Object) {
      console.warn('Old-style rule action', key);
    }
    var info = value.constructor == Object ? value : {action: value};
    if (info.ruleName) {
      console.warn('Property "ruleName" found for rule with key', key);
    }
    info.name = key;
    addRule(info);
  }
}

/**
 * Adds an array of rules (axioms and theorems/facts, named or not),
 * each in the form of a plain object with properties.  If a fact has
 * a name, the name appears as a "name" property.
 *
 * TODO: Convert addFactsMap to use this internally instead of addFact.
 */
function addRules(ruleList) {
  ruleList.forEach(addRule);
}

/**
 * Process the given info into form for inclusion into Toy.rules and
 * add the resulting rule or rules.  This does not do inference, so it
 * can be called before any theorems are proved.
 *
 * For details of the structure of the argument see the comments for
 * ruleInfo.
 */
function addRule(info) {
  var name = info.name;
  if (name && rules[name]) {
    console.warn('Inference rule with name', name,
                 'already declared; ignoring.');
    return;
  }

  if (info.definition) {
    definition(info.definition);
    return;
  }

  var proof = info.proof;
  var statement = info.statement;
  // This will become the "rule object":
  var rule;
  // This will become the "main function" -- the action or proof property
  // with user-written code.
  var main;
  // True iff the main function has access to the rule object as "this".
  var mainHasThis = false;
  // If the rule (theorem) has an explicit statement (which should be
  // provably true), coerce the statement to an Expr if given as a
  // string.
  if (typeof statement === 'string') {
    statement = info.statement = Toy.mathParse(statement);
  }
  if (proof) {
    // The proof should have no arguments, and should not do its
    // own call to "justify".
    //
    // TODO: In the future, allow type parameters and memoize
    //   as appropriate.
    // TODO: Consider checking that "actions" _do_ have parameters.
    assert(typeof proof === 'function',
           'Proof of {1} should be a function', name);
    assert(proof.length == 0, 'Proof of {1} requires parameters', name);
    assert(!info.action, 'Both proof and action for {1}', name);
    // User-supplied proof function is the main.
    main = proof;
  }
  const isAsserted = statement && !proof;
  if (isAsserted) {
    // If there is a statement but no proof, just assert the statement.
    proof = function() {
      var result = rules.assert(statement);
      return (result.isCall2('=>')
              ? rules.asHypotheses(result)
              : result);
    }
    main = proof;
    if (!info.axiom) {
      if (typeof name !== 'string') {
        console.warn('No proof for', statement.$$);
      } else if (!name.startsWith('axiom')) {
        console.warn('No proof for', name);
      }
    }
  }
  if (statement) {
    // Add it as a fact also, and potentially "swapped".
    // A fact needs a statement, so we rely here on having a statement given.
    var factProps = {
      description: true,
      simplifier: true,
      desimplifier: true,
      noSwap: true,
      labels: true,
      converse: true
    };
    // Accept selected fact properties in the rule metadata.
    var properties = {goal: statement, proof: proof};
    for (var k in factProps) {
      if (k in info) {
        // Uncomment this for detailed tracing.
        // console.warn('Adding', k, 'to', name);
        properties[k] = info[k];
      }
    }
    addFact(properties);
    if (!properties.noSwap) {
      addSwappedFact(properties);
    }
  }
  if (proof) {
    // A statement or proof was given.
    // 
    // Don't rerun the proof every time, but do re-justify on each
    // call so each use will return a step with its own ordinal.
    rule = function() { 
      if (rule.result === undefined) {
        rule.result = proof();
        if (statement) {
          assert(rule.result.matches(statement),
                 'Failed to prove {1},\n  instead proved {2}',
                 statement, rule.result);
        }
      }
      return rule.result.justify(name, []);
    };
    // Describe theorems as "theorem" by default.
    // The theorem name will be added as ruleName into the tooltip.
    if (!('description' in info)) {
      info.description = 'theorem'
    }
  } else {
    // It is a rule of inference, not an axiom or theorem.
    assert(name, 'Inference rule must have a name', info);
    // The action property is the user code to run it.
    main = info.action;
    assert(typeof main === 'function',
           'Rule action must be a function: {1}', name);

    if (info.precheck) {
      // There is a precheck.
      var checker = function(_args) {
        return Toy._actionInfo = info.precheck.apply(main, arguments);
      }
      rule = function(_args) {
        checker.apply(null, arguments);
        return (Toy._actionInfo
                ? main.apply(rule, arguments)
                : info.onFail
                ? info.onFail.call(rule)
                : Toy.fail(Toy.format('Rule {1} not applicable', name)));
      }
      if (info.maxArgs == null) {
        info.maxArgs = main.length;
      }
      // Set properties on the outer action to give access to the
      // main from the the precheck.
      rule.precheck = checker;
      rule.main = main;
      // Assert that the main code has access to data and metadata
      // through "this".
      mainHasThis = true;
    }
  }

  // The following code applies to all rules, axioms, theorems and
  // inference rules.

  if (info.data) {
    // Set the "data" property of the outer action so the main
    // and precheck can access it.  If it is a function, call it
    // and use the result.
    if (typeof info.data === 'function') {
      info.data = info.data.call();
    }
    if (!mainHasThis) {
      // Make the outer action function available to the main
      // function as "this".
      rule = function(_args) {
        return main.apply(rule, arguments);
      };
      mainHasThis = true;
    }
    // Also make the data a property of "this".
    rule.data = info.data;
  }
  // Even if there is no wrapping, set up "rule".
  rule || (rule = main);

  // Set up remaining metatadata.

  // Give every info "inputs".
  if (!info.inputs) {
    info.inputs = {};
  }

  // Default the description to the marked up formula or the ruleName.
  if (!('description' in info)) {
    // The name could be undefined.
    info.description = name;
  }
  // Remember the basic tooltip
  info.basicTooltip = info.tooltip;

  // If there is a toOffer property with string value, coerce it
  // to a function of step and path.
  if (typeof info.toOffer === 'string') {
    info.toOffer = new Function('step, term', info.toOffer);
  }
  // Make the action function available here also as "this".
  if (typeof info.toOffer === 'function') {
    info.toOffer = info.toOffer.bind(rule);
  }

  info.labels = processLabels(info.labels);
  if (info.form !== undefined && Toy.isEmpty(info.labels)) {
    // Anything conceivably offerable (with a form), default to
    // "basic" if no other labels.
    info.labels.basic = true;
  }

  // Add all metadata as the function's "info" property.
  rule.info = info;
  
  if (name) {
    // Include the rule name in the tooltip.
    info.tooltip = Toy.format('{1} ({2})', (info.tooltip || ''), name);

    if (rule && rule.length === 0 && name.slice(0, 5) === 'axiom') {
      info.labels.axiom = true;
    }

    // Assign a name to the wrapper and main.
    if (rule !== main) {
      Object.defineProperty(rule, 'name',
                            {value: name + '_wrapper'});
      Object.defineProperty(main, 'name', {value: name});
    } else {
      Object.defineProperty(rule, 'name', {value: name});
    }

    // Finally install the rule into the rules.
    rules[name] = rule;
  }
}

/**
 * Adds the given definition as a new fact provided it meets the
 * requirements for definitions.  It must define a named constant that
 * is not already defined or known as a constant.  The argument is a
 * wff that will become true as the definition of the new constant.
 * The new constant name must be the one and only free new name.  If
 * the wff is in string form, this parses with termify.
 *
 * If it is of the form:
 *
 * <name> = <term>
 *
 * and <name> does not occur free in <term>, this accepts the
 * equational definition.  It also adds related facts using
 * addDefnFacts if the definition is a function or predicate defined
 * equal to a lambda.
 *
 * If the definition has some other form, then there must be a
 * recorded fact of the form: exists {<var>. <condition2>}, where
 * <var> is a variable name that does not occur free in the condition,
 * and condition2 is the result of substituting <var> for <name> in
 * the condition.  Of course the recorded fact could use exists1 in
 * place of exists.
 *
 * TODO: If there is an "exists1" fact, this should automatically
 * generate a fact, with proof, that anything having the property is equal
 * to the new constant.
 *
 * TODO: Perhaps appropriate top-level forms might be: "fact", "rule",
 * and "definition".  Each would just add its item to a global list,
 * perhaps even the same global list.  Additionally, the top-level
 * form might do some bookkeeping and report errors, at least for
 * definitions.  These can run at top-level in modules where the logic
 * is available.
 *
 * TODO: Considering allowing a "properties" argument for properties
 * for generated facts, or provide a way to declare fact properties
 * separately from proof of the fact.
 *
 * Returns the newly-defined name.
 */
function definition(defn_arg) {
  const definitions = Toy.definitions;
  const defn = termify(defn_arg);
  // Free occurrences of names of constants that do not have
  // definitions.
  const news = defn.newConstants();
  // This has the values in the set, in insertion order.
  const newList = Array.from(news);
  assert(newList.length > 0,
         'Definition of {1} needs a fresh constant name.', defn);
  assert(newList.length === 1,
         'Definition {1} has multiple new constants {2}',
         defn, newList.join(', '));
  const name = newList[0];
  const defined = new Atom(name);
  if (defn.isCall2('=') &&
      defn.getLeft().matches(defined) &&
      Toy.isEmpty(defn.getRight().newConstants())) {
    // It is a classic equational definition.
    // Add it to the facts andthe definitions database.
    addFact({goal: defn});
    definitions[name] = defn;
    addDefnFacts(defn);
  } else {
    // It is not a classic equational definition.
    var x = Toy.genVar('x', defn.allNames());
    // Substitute the fresh variable for the constant name.
    var body = defn.subFree1(x, name);
    var exists1 = Toy.call('exists1', Toy.lambda(x, body));
    if (isRecordedFact(exists1)) {
      // TODO: Add the fact that only one value has the property.
      console.warn('Not using exists1 fact for {1}.', defn);
    } else {
      var exists = Toy.call('exists', Toy.lambda(x, body));
      assert(isRecordedFact(exists),
             'Definition {1} needs an existence fact.', defn);
    }
    // Assert that the definition is true, and add to the definitions.
    addFact({goal: defn});
    definitions[name] = defn;
  }
  return name;
}

// Set to false when defn facts can be proved immediately.
let deferringDefnFacts = true;

// Functions to compute defnFacts when the needed support is ready.
const deferredDefnFacts = [];

/**
 * Call this to prove deferred facts and cease deferrals.
 */
function enableDefnFacts() {
  deferringDefnFacts = false;
  deferredDefnFacts.forEach(function(f) { f(); });
  deferredDefnFacts.length = 0;
}

/**
 * This function only has effect for equational definitions
 * of the form <atom> = <term>, in Expr form.
 *
 * If it is a function definition (the term is a lambda), it generates
 * a basic equational fact for application of the function or
 * predicate to arguments.  In other words if f = {x. <term>},
 * generates the fact f x = <term>, and similarly if there are
 * multiple arguments.
 *
 * After unwrapping any lambdas, if the definition has one of the
 * specific forms:
 *
 * <name> = the <condition>; or
 * <name> = iota <condition>
 *
 * and if there is a recorded fact of the form exists1 <condition>, it
 * proves the additional fact that <condition>(<name>).  If there is a
 * recorded fact <precond> => exists1 <condition>, it proves a fact
 * that <precond> => <condition>(<name>).  If the definition uses
 * "the" rather than "iota", it proves [if <precond> then
 * <condition>(<name>) else null].
 *
 * Definitions of this kind using "the", or perhaps iota, will only go
 * through properly once basic logic with facts about quantifiers and
 * unique existence are in place.  This seems a reasonable
 * requirement.  Omitting the accompanying unique existence fact will
 * prevent the system from attempting to perform the automatic proof.
 *
 * TODO: Consider supporting "the" better by using available facts
 *   that show when the needed exists1 property does and does not
 *   apply.
 *
 * TODO: Implement the <precond> support.  Consider extending this for
 *   additional cases TBD.
 */
function addDefnFacts(definition) {
  function addFacts() {
    var defined = definition.getLeft();
    var name = defined.name;
    var eqn = rules.definition(name);
    var lambda = definition.getRight();
    while (lambda instanceof Lambda) {
      var bound = lambda.bound;
      eqn = (rules.applyBoth(eqn, bound)
             .andThen('simpleApply', '/right'));
      lambda = eqn.getRight();
    }
    // TODO: Consider adding a fact unconditionally, and treating
    //   it automatically as a desimplifier.
    if (eqn != definition) {
      // Flag the fact as being essentially the same as the definition
      // of the function or predicate.
      addFact({goal: eqn, definitional: true});
      addSwappedFact({goal: eqn, definitional: true});
    }
  }
  // This relies on having applyBoth and simpleApply available whenever
  // a function is defined.
  if (definition.isCall2('=') && definition.getLeft() instanceof Atom) {
    if (deferringDefnFacts) {
      deferredDefnFacts.push(addFacts);
    } else {
      addFacts();
    }
  }
}


//// FACTS

/**
 * Accepts a "prover" function of no arguments and a goal statement
 * (Expr).  The prover may be null, in which case this generates
 * a trivial prover that asserts the goal.
 *
 * Returns a function to construct and return a proved statement from
 * the arguments.  The returned function runs the prover to prove the
 * goal.  When running the prover, the returned function also attempts
 * to use exactly the free variables in the goal, and arranges the
 * assumptions accordingly.  It warns if assumptions do not match up
 * with the goal, and raises an error if the main part if it cannot
 * make the main part match exactly.
 *
 * Internal to addFact and addSwappedFact.
 *
 * TODO: Share common code here and in addFact and addRule and
 *   addDefinition.
 */
function asFactProver(prover, goal) {
  assert(!prover || typeof prover === 'function',
         'Not a function: {1}', prover);
  // This function wraps around the user-supplied fact prover
  // to do the generic parts of the work.
  function factProverWrapper() {
    var result;
    if (goal.isProved()) {
      result = goal;
    } else if (!prover) {
      // The proof is just a stub not yet filled in.
      console.warn('No proof for fact', goal.toUnicode());
      result = rules.assert(goal);
      return (result.isCall2('=>')
              ? rules.asHypotheses(result)
              : result);
    }
    var result = prover();
    // Seek a substitution into the result that yields the goal.
    var subst = result.alphaMatch(goal);
    // TODO: Check that substitutions exist, but don't actually do
    //   substitutions here.  Now rules.fact substitutes as needed to
    //   use the variables desired at each use.
    if (subst) {
      return rules.instMultiVars(result, subst);
    } else {
      // Try matching the main parts of the result and goal.
      // Reorder any assumptions as needed.
      var subst2 = result.getMain().alphaMatch(goal.getMain());
      if (subst2) {
        // The main parts match up to change of variables.
        var proved = (rules.instMultiVars(result, subst2)
                       .andThen('arrangeAsms'));
        if (proved.matches(goal)) {
          return proved;
        }
        var conjSet = Toy.makeConjunctionSet;
        var empty = new Toy.TermSet();
        var goalAsms = goal.isCall2('=>') ? conjSet(goal.getLeft()) : empty;
        var factAsms = proved.isCall2('=>') ? conjSet(proved.getLeft()) : empty;
        if (!goalAsms.superset(factAsms)) {
          console.group('Warning: Fact requires unintended assumptions.');
          console.error('Some results may rely on the incorrect fact.');
          console.error('Proved:', proved.toString());
          console.error('Stated:', goal.toString());
          console.groupEnd();
          // This is a serious issue, so if the debugger is open,
          // pause here.  This also allows work to continue, so the
          // proof can be reviewed in the user interface.
          debugger;
        }
        if (!factAsms.superset(goalAsms)) {
          console.group('Note: Fact statement has unneeded assumptions.');
          console.info('Proved:', proved.toString());
          console.info('Stated:', goal.toString());
          console.groupEnd();
        }
        return proved;
      } else {
        assert(false, 'Instead of {1} proved {2}', goal, result);
      }
    }
  }
  return factProverWrapper;
}


//// About fact info objects.  These are plain objects with properties:
//
// synopsis (optional): synopsis string
// goal: Expr statement of the fact, with all assumptions.  All
//   variables are exactly as declared, though functions such as
//   mathParse may add assumptions before returning the Expr.
// labels: object / set of labels like the ones for rules
// simplifier: true if this is an equation that simplifies
// desimplifier: true if this is an equation that "desimplifies"
// noSwap: if true, inhibits automatic generation of a fact
//   with equation LHS and RHS swapped
// prover: function intended to prove the fact
// proved: proved statement or falsy if not yet proved
// keyInfo: key and asmSet information as for factRecords.

//// About standard forms of statements, including fact declarations
//
// 

// Every fact declared by addFact or addRule is recorded under a
// string key that represents the consequent of the fact if it is
// conditional, and otherwise the full fact.  In either case the
// fact's (unique) fact properties object is the stored value.  This
// maps from fact key to an array of fact property objects as
// described above.  Private to factsExtending, setFactInfo, and
// eachFact (but see also factSquish).
//
// This structure be eliminated, using _resolutionsByKey in its place.
var _factsByKey = new Map();

// Fact declarations and fact references:

// A fact declaration, as in addFact, is an unabbreviated statement of
// the fact.  (If the statement is to be parsed, the parsing code
// may fill in parts, such as type assumptions, that are implicit
// in the string form.)

// Fact references appear where a fact is used, as in rules.fact or in
// rules.rewrite and its variants.  A fact reference is a wff, in the
// form of an Expr or string, and resolves to a recorded fact by the
// following matching process:
// 
// If a fact reference is not conditional, treat it as a conditional
// with an empty set of assumptions.
//
// A reference resolves to a recorded fact if and only if there is
// exactly one such fact for which: 1) the consequent of the reference
// exactly matches the consequent of the fact, and 2) the assumptions
// of the reference, taken as a set, are a subset or equal to the set
// of assumptions of the fact that is referred to.  The matching
// allows for changes of variable names between the recorded fact and
// the reference.

/**
 * Map from string representing the body / "main" part of a statement
 * to array of records each describing the association from a
 * statement to the fact it references.  This contains a record for
 * each statement that has been resolved to a fact, where the
 * statements with different order of assumptions and/or changes of
 * variable names are considered to be the same statement.  Each
 * record is an Object with properties "resInfo" and "factInfo", where
 * "resInfo" is a "statement resolution information" object and
 * "factInfo" is the object with all the properties of the fact.
 *
 * This could also be used to look up factInfo from a fact goal or
 * equivalent that may have different variable names or order of
 * assumptions, but that is more directly supported through
 * _factsByKey.
 * 
 * This supports fairly efficient resolution of actual or proposed
 * fact references to facts, and is used to ensure that no fact
 * reference ever becomes ambiguous.
 *
 * TODO: With _factsByKey giving access to factInfo and
 * _resolutionsByKey giving access to resInfo, possibly this could
 * store just pairs of statement and fact goal.
 */
const _resolutionsByKey = new Map();

/**
 * This returns an array of fact information objects of recorded facts
 * that match the given resInfo.  The facts extend the resInfo in that
 * they have the same key ("main part") and possibly additional
 * assumptions.
 *
 * TODO: See TODO for resolveToFactInfo.
 */
function factsExtending(resInfo) {
  const factPropsList = _factsByKey.get(resInfo.key) || [];
  const results = factPropsList.filter(function(factProps) {
      const stmtInfo = getResInfo(factProps.goal);
      return (stmtInfo.key == resInfo.key &&
              stmtInfo.asmSet.superset(resInfo.asmSet));
    });
  return results;
}

/**
 * Returns the "expansion" of a statement.  The result is a version of
 * the full declared fact of the statement, with free variables as in
 * the given statement rather than the declaration.  Returns null if
 * there is no such declared fact.
 */
function factExpansion(stmt) {
  const factInfo = resolveToFactInfo(stmt);
  const resInfo = getResInfo(stmt);
  const expanded = resInfo._expansion;
  if (expanded) {
    return expanded;
  }
  if (factInfo) {
    const asStated = factInfo.goal.getMain();
    const asRequested = resInfo.stmt.getMain();
    const map = asRequested.matchSchema(asStated);
    const expansion = factInfo.goal.subFree(map);
    resInfo._expansion = expansion;
    return expansion;
  } else {
    return null;
  }
}

/**
 * This returns information about the recorded fact the given
 * statement is considered to refer to.
 *
 * A statement is considered to properly refer to a fact iff there is
 * exactly one fact such that the fact's main part exactly matches the
 * statement's main part and the assumptions of the fact are a
 * superset of the assumptions of the statement, both of these
 * allowing for renaming of variables.
 *
 * Returns the desired fact info, or null if there is no such fact or
 * the reference is ambiguous.
 *
 * If the fact has in its assumptions any free variables that are not
 * also free in the consequent, and if a fact reference also has the
 * assumption, they currently must have the same name.
 *
 * TODO: Consider strengthened support for references to facts that
 *   have free variables that occur in the assumptions but not the
 *   consequent.  That requires more detailed matching of assumptions
 *   in factsExtending.
 */
function resolveToFactInfo(stmt) {
  // The resInfo is "fact resolution information" for the statemement.
  const resInfo = getResInfo(stmt);
  const resolutions = _resolutionsByKey.get(resInfo.key) || [];
  // This gets a non-null value iff stmt has already been resolved.
  const resolvent = resolutions.find(function(rec) {
      //  Use of object identity here is OK because _statementResInfos
      //  ensures that repeated lookups of the same statement object
      //  result in the same resInfo object.  Also, factExpansion
      //  currently expects distinct statement objects to have
      //  distinct resInfo objects, and sharing of resInfos among
      //  different statements would be incompatible with that.
      return rec.resInfo == resInfo;
    });
  if (resolvent) {
    return resolvent.factInfo;
  }
  const candidates = factsExtending(resInfo);
  if (candidates.length == 1) {
    resolutions.length > 0 || _resolutionsByKey.set(resInfo.key, resolutions);
    resolutions.push({resInfo: resInfo, factInfo: candidates[0]});
    return candidates[0];
  }
  return null;
}

/**
 * Resolves the given statement wff to a full fact statement if
 * possible, otherwise returns null.  Like resolveToFactInfo, but
 * returns just the goal.
 */
function resolveToFact(stmt) {
  const info = resolveToFactInfo(stmt);
  return info ? info.goal : null;
}

/**
 * Returns true iff the given wff exactly matches a recorded fact in
 * the sense that, when its variables are renamed to be the standard
 * variables, its main part exactly matches a recorded fact and its
 * set of assumptions is equal to the set of assumptions of the result
 * of standardizing the variables of the recorded fact.
 *
 * NOTE: In the unlikely event that the recorded fact has multiple
 * variables that are free only in its assumptions, the result could
 * be false even though the statements have the same assumptions.
 * This would be due to different ordering of assumptions between the
 * given statement and the recorded fact, and thus different
 * assignments of variable names.
 *
 * Also note that any assumption with free variable(s) in the LHS can
 * be converted to an existential term where the variable is bound,
 * making this scenario particularly unlikely.
 */
function isRecordedFact(stmt) {
  // First check that the statement resolves to a specific fact.
  const factInfo = resolveToFactInfo(stmt);
  if (factInfo) {
    // Then verify that the statement and the fact are indeed
    // equivalent.
    const asms = getResInfo(stmt).asmSet;
    const factAsms = getResInfo(factInfo.goal).asmSet;
    return asms.equals(factAsms);
  }
  return false;
}

/**
 * Record the given fact information; private to addFact.  See
 * comments on _factsByKey and fact management functions for the
 * expectations on the argument.
 *
 * Returns truthy for success, falsy if the new fact statement is not
 * allowable: either already recorded or alters the meaning of a
 * statement already referring to a different fact.
 */
function setFactInfo(info) {
  if (isRecordedFact(info.goal)) {
    console.log('Already recorded fact:', info.goal.toString());
    return false;
  }
  const key = getResInfo(info.goal).key;
  const facts = _factsByKey.get(key) || [];
  // Ensure that the key has an array of facts.
  facts.length > 0 || _factsByKey.set(key, facts);
  // Tentatively add the fact to the list.
  facts.push(info);
  const resolutions = _resolutionsByKey.get(key);
  // If foundRef becomes non-null, this will become an array of the
  // facts that it could refer to.
  var extFacts;
  if (resolutions) {
    // If found, this is a ref whose statement would refer to a
    // different fact in the presence of the tentative new fact.
    const foundRef = resolutions.find(function(rec) {
        extFacts = factsExtending(rec.resInfo);
        return (extFacts.length != 1 ||
                extFacts[0].factInfo != rec.factInfo);
      });
    if (foundRef) {
      // There was an issue.  Immediately remove the fact from the list.
      facts.pop();
      // Then complain and return false.
      console.error('New fact', info.goal.toString());
      // TODO: Make available info to improve the following message.
      //   Reference to the stated fact reference would be helpful.
      console.log('  would affect the meaning of', foundRef.resInfo);
      return false;
    }
  }
  return true;
}


/**
 * Like getResult, below, but always proves the statement if it has
 * an associate prover function.
 */
function proveResult(stmt) {
  return getResult(stmt, true);
}

/**
 * Accepts an already-proved step or the full statement of some
 * recorded fact.  Returns a proof of the step, or one like it except
 * for changes of names of variables including free variables.  Throws
 * an exception in case of failure.
 *
 * Note that the facts database currently looks up facts by their
 * "main" part, ignoring any assumptions.
 *
 * The optional second argument, for internal use only, if true,
 * overrides any setting of Toy.assertFacts and assures that a proved
 * result will be returned (if there is a prover function).
 *
 * TODO: Consider renaming to something like "stepify" and using as
 *   a conversion for inputs to steps in the vein of "termify".
 */
function getResult(statement, mustProve) {
  if (Toy.isProved(statement)) {
    return statement;
  }
  var info = resolveToFactInfo(statement);
  assert(info, 'Not a recorded fact: {1}', statement);
  // TODO: Consider more precise checking of the result of the lookup.
  if (info.proved) {
    return info.proved;
  }
  var prover = info.prover;
  if (Toy.assertFacts && !mustProve) {
    var result = rules.assert(info.goal);
    if (result.isCall2('=>')) {
      // Treat any conditional as having hypotheses.
      //
      // TODO: Skipping this might provide a good test for the system
      //   working with conditionals directly.
      result = rules.asHypotheses(result);
    }
    return result;
  }
  info.inProgress = true;
  try {
    // Get the proved result of the fact.
    info.proved = prover();
    assert(info.proved instanceof Expr);
    // Note that the fact remains in progress if its prover throws, which
    // may or may not be good thing.
    info.inProgress = false;
  } finally {
    if (info.inProgress) {
      console.error('Proof of fact failed', '' + statement);
    }
  }
  return info.proved;
}

/**
 * Returns true iff a proof of this statement is underway but not
 * completed.  Can be used to prevent infinite regress, as in the case
 * of simplifiers that might be skipped during their own proof.
 */
function isInProgress(stmt) {
  if (!resolveToFactInfo(stmt)) {
    // It could be a tautology, but not a recorded fact.
    return false;
  }
  const info = resolveToFactInfo(stmt);
  return info && info.inProgress;
}

/**
 * JS Map from statement in wff (or currently string) form to
 * information about the statement.  The information is a resInfo
 * object, for getResInfo.  This serves as a cache to accelerate these
 * calculations, especially given that the same statements tend to be
 * used over and over.  Private to getResInfo.
 *
 * The resInfo is a plain object with properties "key", "asmSet", and
 * "key", all related to a particular fact statement.  Also one
 * property internal to factExpansion.  The asmSet is a TermSet of the
 * statement's assumptions, the key is its "fact key", the stmt is the
 * wff statement it comes from.
 *
 * This can support string keys, but mathParse already accelerates
 * conversion of strings to wffs.
 */
const _statementResInfos = new Map();

const noTerms = new Toy.TermSet();

/**
 * Given a wff (or currently a string that parses to one using
 * mathParse), returns a "resInfo" or "fact resolution information"
 * object, which has information useful for resolving exactly which
 * fact the statement is intended to refer to.  The result is a
 * resInfo object as described just above.
 * 
 * The key is a string that represents the main/body of the wff, with
 * all variables of that part replaced with standard variables so the
 * key does not depend on the names of variables supplied as the
 * statement.  The asmSet is a TermSet of the assumptions, also using
 * standard variable names.
 *
 * This remembers the association between the given statement object
 * and the resInfo to speed repeated lookups, which is the usual case
 * for fact references in rewriting rules or fact lists.
 */
function getResInfo(stmt) {
  // Computes the resolution info for the statement and caches the
  // association in _statementResInfos.
  function computeStatementInfo(stmt) {
    if (typeof stmt == 'string') {
      console.error('Deprecated: resInfo of string:', stmt);
    }
    // TODO: Fix higher-level code to do the parsing, so different
    //   type assumptions and such can be inserted at that level.
    const wff = mathParse(stmt);
    const main = wff.getMain();
    const hasAsms = wff.isCall2('=>');
    // This makes a wff with main first, and also has
    // any assumptions, ordered after the main part.  We
    // do not expect this to be a theorem.
    const wff2 = (hasAsms
                  ? Toy.infixCall(main, '&', wff.getLeft())
                  : wff);
    const standard = Toy.standardVars(wff2);
    const asmSet = (hasAsms
                    ? Toy.makeConjunctionSet(standard.getRight())
                    : noTerms);
    // Key generation currently uses toString, which is sensitive to
    // aliases in particular "==" for "=", compared with "dump", which
    // is not.
    const key = (hasAsms ? standard.getLeft() : standard).toString();
    const info = {key: key, asmSet: asmSet,
                  standardVars: standard,
                  // _expansion will be initialized later.
                  stmt: wff, _expansion: null};
    _statementResInfos.set(stmt, info);
    return info;
  }
  return (_statementResInfos.get(stmt) ||
          computeStatementInfo(stmt));
}


//// Finding matching facts

/**
 * Finds a single LHS match within the given term with one of the
 * given facts.  Returns the value of the successful call to
 * findMatchingFact, with a "path" property added indicating the path
 * from the term argument to the matched term, or a falsy value if no
 * call succeeded.
 *
 * All arguments other than the term are passed via "info".  If it is
 * a plain object, it interprets the following properties:
 *
 * facts: List of facts in the format accepted by findMatchingFact.
 * context: Context information for "where" clauses as
 *   accepted by findMatchingFact.
 *   TODO: (BUG!) Accept an "isQuantified" property here, or more 
 *      detailed information, to indicate enclosing bound variables.
 * searchMethod: Name of method to apply to the term to control
 *   which subexpressions of the term to apply findMatchingFact to;
 *   defaults to 'searchCalls', which searches through calls.
 *
 * If the info is an array, it must be the list of facts.
 *
 * TODO: Consider changing this to something like applyMatchingFactIn,
 *   doing essentially the same search, but attempting to apply the
 *   first fact that seems to match, and continuing the search if
 *   application fails.
 */
function searchForMatchingFact(term, info) {
  var allFacts, searchMethod;
  var cxt = {};
  if (info.constructor === Object) {
    allFacts = info.facts;
    info.context && Object.assign(cxt, info.context);
    searchMethod = info.searchMethod;
  } else {
    allFacts = info;
  }
  // If set to non-null, just unconditional facts.  At present only
  // includes facts that are just a statement in string form.
  // Computed here for efficiency.
  //
  // TODO: Handle more complicated facts (as needed).
  var pureFacts = null;
  function isPureFact(fact) {
    if (typeof fact === 'string' || fact instanceof Expr) {
      // This next line supports ordinary facts and also tautologies.
      // It relies on resolveToFact to return a conditional whenever
      // it is given a statement that has implicit assumptions.
      var fullFact = resolveToFact(fact) || termify(fact);
      return fullFact && fullFact.isCall2('=');
    } else if (fact.constructor === Object && fact.pure) {
      return true;
    }
  }
  searchMethod = searchMethod || 'searchMost';
  function factFinder(term, revPath, isQuantified) {
    if (isQuantified) {
      pureFacts = pureFacts || allFacts.filter(isPureFact);
    }
    // If some free variables of a conditional fact do not appear in
    // its condition(s), this may exclude it unnecessarily.
    // TODO: Consider a more precise check here.
    var facts = isQuantified ? pureFacts : allFacts;
    var result = findMatchingFact(facts, cxt, term, isQuantified);
    if (result) {
      result.path = revPath.reverse().concat(result.path);
    }
    return result;
  }
  return term[searchMethod](factFinder);
}

/**
 * Searches the given pattern list for one that matches the given
 * term.  If it finds one, returns info about it in a plain object
 * in the format described below.
 *
 * The context argument is available to "where" arguments as "cxt",
 * and any "factLists" property of the context defines lists of named
 * patterns accessible by using the name in place of an explicit list.
 * The value of the factLists property is a plain object mapping from
 * list name to a list (array) value.  In this way lists can be
 * reused, and also enables them to be effectively recursive.
 *
 * If pureOnly is true, this only accepts a fact that is a pure
 * equation, with no conditions on it.
 * 
 * Each pattern argument can be an argument acceptable to
 * resolveToFact, or:
 *
 * A plain object with properties as follows:
 *
 * stmt: value acceptable to resolveToFact.  Unless "match" is also
 *   given this will need to be an equation.
 * where: optional string to evaluate, with "subst" 
 *   argument to findMatchingFact available as "$" and cxt and term
 *   available as free variables for use in the string.
 *   OR if it is a function, call it with the substition, cxt, and
 *   term as arguments.
 *
 * For fact statements passed as list elements or the "stmt" property
 * of a list element, if proof of the fact is in progress at the time,
 * the fact is ignored in the search.  This provides a crude mechanism
 * for avoiding infinite regress, for example when simplifying steps
 * of the proof of a simplifier fact.
 *   
 * Or it can be a plain object with a single property, either:
 *
 * descend: a plain object with properties "schema", a schema
 *   (possibly in string form) to match against the term, and "parts",
 *   a plain object mapping from variable names in this schema each to
 *   a pattern list as described above. If the search reaches this
 *   "descend" item and the schema matches the term, the search
 *   descends into the parts of the term, applying each schema
 *   variable's list of facts to the part of the term matching that
 *   schema variable.
 *
 * apply: a function to apply to the input term and context, which
 *   must return an equation whose LHS is the same as the term except
 *   for possible changes of bound variables, or a falsy value if it
 *   fails to produce such an equation.  The call is done by
 *   Toy.normalReturn, and this uses the value returned from that.
 *
 * The value returned is falsy if no match is found, else a plain
 * object with properties:
 * 
 * stmt: Relevant fact statement, proved or not, or the equation
 *   returned by an "apply" pattern.
 * term: the term argument to findMatchingFact.
 * subst: substitution that makes the given term match the fact (empty for
 *   "apply" patterns).
 * path: path to the portion of the given term that matched some pattern.
 *
 * TODO: Consider changing this to something like "applyMatchingFact",
 *   attempting to apply the first fact that appears to match, and
 *   continuing the search if the application fails.
 */
function findMatchingFact(facts_arg, cxt, term, pureOnly) {
  // This function interprets a fact statement as a wff.
  // Currently it uses mathParse.
  // TODO: Use the context (cxt) and perhaps other information to determine
  //   this aspect of the interpretation of a fact statement, enabling
  //   fact statements here that are not interpreted as relating to real
  //   numbers.
  function interpret(stmt) {
    return mathParse(stmt);
  }
  // This finds the fact part to match.  If the fact is not an equation,
  // uses the main part instead of the LHS.
  function schemaPart(fact) {
    var main = fact.getMain();
    return (main.isCall2('=')
            ? main.getLeft()
            : main);
  }
  function apply$(expr, $) {
    if (typeof expr === 'function') {
      return expr($, cxt, term);
    } else {
      // Suppress acccess to the enclosing "facts" variable.
      // OK for str to refer to "cxt" or "term".
      var facts;
      return eval(expr);
    }
  }
  var facts = facts_arg;
  if (typeof facts_arg == 'string' && Toy.isIdentifier(facts_arg)) {
    facts = cxt.factLists && cxt.factLists[facts_arg];
  }
  assert(facts && facts[Symbol.iterator], 'No facts: {1}', facts_arg);
  for (var it = facts[Symbol.iterator](), v = it.next(); !v.done; v = it.next()) {
    var factMatcher = v.value;
    if (factMatcher.constructor !== Object) {
      // The factMatcher is a string or wff.
      // The stmt is a wff, so there will be no need for lower-level code
      // to decide how to "interpret" / parse it.
      var stmt = interpret(factMatcher);
      if (!isInProgress(stmt)) {
        // TODO: Change this to match before checking for inProgress,
        //   and warn when a match is rejected due to fact proof in
        //   progress.
        //
        // Note: resolveToFact for some reason is MUCH faster here
        // than rules.fact.  The whole test suite runs twice as fast.
        // Unfortunately resolveToFact returns the goal as stated, not
        // as requested.
        var fullFact = (factExpansion(stmt) ||
                        // The "fact" might be a tautology.
                        // Could it even be something else?  Not clear.
                        rules.fact(stmt));
        if (!(pureOnly && fullFact.isCall2('=>'))) {
          var schema = schemaPart(fullFact);
          var subst = term.matchSchema(schema);
          if (subst) {
            var result = {stmt: fullFact,
                          term: term,
                          path: Toy.path(),
                          subst: subst};
            return result;
          }
        }
      }
    } else if (factMatcher.apply) {
      // "apply"
      var eqn = Toy.normalReturn(factMatcher.apply, term);
      if (eqn && !(pureOnly && eqn.isCall2('=>'))) {
        var result = {
          stmt: eqn,
          term: term,
          path: Toy.path(),
          subst: {}
        };
        return result;
      }
    } else if (factMatcher.descend) {
      // "descend"
      var partInfo = factMatcher.descend;
      // TODO: Handle pureOnly here.
      var result = _locateMatchingFact(term,
                                       partInfo.schema,
                                       partInfo.parts,
                                       cxt);
      if (result) {
        return result;
      }
    } else {
      const stmt = interpret(factMatcher.stmt);
      if (!stmt) {
        console.warn('Nothing to do in fact matcher:',
                     factMatcher);
        return null;
      }
      const factInfo = resolveToFactInfo(stmt);
      if (!factInfo) {
        console.error('No such fact:', ''+stmt);
        return null;
      }
      if (factInfo.inProgress) {
        return null;
      }
      if (pureOnly && factInfo.goal.isCall2('=>')) {
        return null;
      }
      const expansion = factExpansion(stmt);
      const schema = schemaPart(expansion);
      const subst = term.matchSchema(schema);
      const where = factMatcher.where;
      if (subst && (!where || apply$(where, subst))) {
        var result = {stmt: expansion,
                      term: term,
                      path: Toy.path(),
                      subst: subst};
        return result;
      }
    }
  }
  // If no match found the value will be falsy.
};

/**
 * This handles "descend" patterns in findMatchingFact, and is private
 * to it.
 *
 * Arguments are the term argument to findMatchingFact, the schema
 * property of the "descend" pattern, the "parts" property of the
 * "descend" pattern, and the context argument to findMatchingFact.
 */
function _locateMatchingFact(expr, schema_arg, varsMap, context) {
  var schema = termify(schema_arg);
  var factLists = context.factLists;
  var subst;
  if ((subst = expr.matchSchema(schema))) {
    // Checks if the given term of the schema matches some fact
    // in the appropriate factsList, throwing information about
    // the match if found to Toy.catchResult.
    // Only schema variables are eligible to match.
    function checkTerm(schemaTerm, revPath) {
      if (schemaTerm.isVariable()) {
        var list = varsMap[schemaTerm.name];
        if (typeof list == 'string' && Toy.isIdentifier(list)) {
          list = factLists[list];
        }
        if (list) {
          var result =
            findMatchingFact(list, context, expr.get(revPath.reverse()));
          if (result) {
            result.path = revPath.reverse().concat(result.path);
            throw new Toy.Result(result);
          }
        }
      }
    }
    // TODO: Consider replacing this use of Expr.traverse with
    //   Expr.searchMost.
    return Toy.catchResult(schema.traverse.bind(schema, checkTerm));
  }
}

/**
 * Beta-reduces the given term if it is a call to a lambda,
 * otherwise returns a falsy value.
 */
function tryReduce(term) {
  return term.isLambdaCall() && rules.axiom4(term);
}

/**
 * Find and apply one of the facts to the part of the step at the
 * given path, returning the result, or the input step if none of the
 * facts apply.  Note: uses rules.rewrite, not rewriteOnly.
 */
function applyFactsOnce(step, path, facts) {
  var info = findMatchingFact(facts, null, step.get(path));
  return info ? rules.rewrite(step, path, info.stmt) : step;
}

/**
 * Apply the list of fact rewrites to the "focal" part of the step
 * until none of them any longer is applicable, returning the result.
 */
function applyToFocalPart(step, facts) {
  return applyFactsWithinSite(step, step.pathToFocalPart(), facts);
}

/**
 * Apply the list of facts as rewrites to the given part of the step
 * until none of them any longer is applicable, returning the result.
 * Returns its input step if no matches are found.
 */
function applyFactsWithinSite(step, path_arg, facts) {
  var path = Toy.path(path_arg);
  var eqn1 = rules.considerPart(step, path);
  var eqn2 = applyFactsWithinRhs(eqn1, facts);
  return (eqn2 == eqn1 ? step : rules.rplace(eqn2, step, path));
}

/**
 * Apply the list of facts as rewrites to the RHS of the given step,
 * which must be an equation.  Repeats until none of them is
 * applicable, returning the result.  Returns its input step if no
 * matches are found.  Uses rules.rewrite, not rewriteOnly.
 *
 * TODO: hyps -- step is an equation.
 */
function applyFactsWithinRhs(step, facts) {
  var rhs;
  var info;
  var eqn = step;
  while (rhs = Toy.path('/main/right', eqn),
         info = searchForMatchingFact(eqn.get(rhs), facts)) {
    var fullPath = rhs.concat(info.path);
    eqn = rules.rewrite(eqn, fullPath, info.stmt);
  }
  return eqn;
}

/**
 * Apply the function to the subexpression of step at path.  The
 * function should return an equation that equates the original
 * subexpression to something else.  This replaces the subexpression
 * using the returned equation.
 *
 * Allows the function to return a falsy value, returning the same
 * value itself.
 */ 
function convert(step, path, fn) {
  var expr = step.get(path);
  assert(expr, 'Bad path {1}', path, step);
  var eqn = fn(expr);
  return eqn && rules.replace(step, path, eqn);
}

/**
 * Proves that the given term is equal to something by taking it as
 * equal to itself, applying the given equation throughout its RHS,
 * rewriting the result with the given fact, then applying the reverse
 * of the equation throughout the resulting RHS.  The term can be
 * a string, while the equation can be proved steps or statements
 * of any recorded equational fact.
 *
 * Intended to capture a design pattern for proving facts about
 * "inverse" functions such as division and subtraction.
 */
function transformApplyInvert(term_arg, eqn_arg, fact) {
  var term = termify(term_arg);
  var eqn = getResult(eqn_arg);
  var revEqn = rules.eqnSwap(eqn);
  var step1 = rules.consider(term);
  var step2 = applyFactsWithinRhs(step1, [eqn]);
  var step3 = rules.rewrite(step2, '/main/right', fact);
  var step4 = applyFactsWithinRhs(step3, [revEqn]);
  return step4;
}

/**
 * Apply the given simplification function to the equation repeatedly
 * until the result of the call is identical to its input.  Return
 * the result of the last call.
 */
function whileChanges(eqn, fn) {
  var simpler = eqn;
  var next;
  while (true) {
    next = fn(simpler);
    if (next.matches(simpler)) {
      return next;
    }
    simpler = next;
  }
}

/**
 * Applies the given facts repeatedly to the RHS of the given equation
 * until none matches, each time replacing the RHS with the result of
 * applying the matching fact.  Returns the last version created.
 */ 
function arrangeRhs(eqn_arg, context, facts) {
  var rhsPath;
  var info;
  var eqn = eqn_arg;
  while (rhsPath = Toy.path('/main/right', eqn),
         info = findMatchingFact(facts, context, eqn.get(rhsPath))) {
    var fullPath = rhsPath.concat(info.path);
    const next = rules.rewrite(eqn, fullPath, info.stmt);
    eqn = next;
  }
  return eqn; 
}

/**
 * Arranges the given part of the given step by repeatedly applying
 * the given facts until none matches, returning a step with the part
 * replaced by the result of the rearrangement.
 *
 * As a good practice, this considers the part in isolation, only
 * replacing it in the step when done applying facts.
 */
function arrange(step, path, context, facts) {
  var eqn = rules.consider(step.get(path));
  var arranged = arrangeRhs(eqn, context, facts);
  return rules.replace(step, path, arranged);
}

/**
 * Call the given function for each recorded fact, passing
 * it the info object stored for the fact.
 */
function eachFact(fn) {
  _factsByKey.forEach(function(list) {
      list.forEach(function(info) {
          fn(info);
        });
    });
}

/**
 * Checks that the named rule is a theorem (i.e. takes no arguments),
 * and gets its result.  Returns null if there is not a theorem
 * of that name.
 */
function getTheorem(name) {
  var action = rules[name];
  if (!action || action.length !== 0) {
    return null;
  }
  return action();
}

/**
 * Returns true iff the named theorem has already been proved.
 */
function alreadyProved(name) {
  if (isAxiom(name)) {
    return true;
  } else {
    return !!rules[name].result;
  }
}

/**
 * True iff the name is the name of an axiom.
 */
function isAxiom(name) {
  return name.substring(0, 5) === 'axiom';
}


//// UTILITY FUNCTIONS

/**
 * Searches the list of equational facts in order for one that matches
 * a subexpression of the given step.  In particular, the part of the
 * step at path must match with the variable in the LHS of the fact
 * having the given name, which should occur exactly once in the
 * fact's LHS.
 *
 * If this finds such a fact it returns a function of no arguments
 * that applies the fact to the step using rules.rewrite and returning
 * the result of the rewrite.
 *
 * TODO: Consider how to make sure the facts in factList are
 *   interpreted appropriately.
 */
function matchFactPart(step, path, factList, name) {
  return Toy.each(factList, function(fact_arg) {
    var schema = factExpansion(fact_arg).getMain().getLeft();
    var info = step.matchSchemaPart(path, schema, name);
    if (info) {
      return function() {
        return rules.rewrite(step, info.path, fact_arg);
      };
    }
  });
}

/**
 * For each hypothesis in the given step that matches a hypothesis in
 * the "dep" step that has a sourceStep property, copy the sourceStep
 * property to the hypothesis in the step.
 *
 * This has side effects on the display of Exprs that already exist,
 * so in some contexts it might affect the display of steps you did
 * not intend to affect.
 *
 * TODO: Consider actually importing hypotheses from dep using rule R
 * to avoid the possibility of undesired side effects.
 *
 * TODO: hyps
 */
function flagHyps(step, dep) {
  if (step.hasHyps && dep.hasHyps) {
    function flag(hyp) {
      if (hyp.sourceStep) {
        // Already flagged, don't change.
        return true;
      }
      function tryFlag(source) {
        var step = source.sourceStep;
        if (step && hyp.matches(source)) {
          hyp.sourceStep = step;
          // Flag the hyp, and stop searching.
          return true;
        }
      }
      // Try to flag the hyp with the source step of one of
      // the hyps from dep.
      dep.getLeft().eachHyp(tryFlag);
    }
    step.getLeft().eachHyp(flag);
  }
}

/**
 * Build a schema for a conjunction of hypotheses, ensuring all are in
 * the TermMap, with optional exclusions, a TermSet.  The schema is of
 * the form a1 && ... && an, where the "a"s are variables for the
 * terms for each hyp in hyps.
 */
function buildHypSchema(hyps, map, exclusions) {
  var schema = null;
  hyps.eachHyp(function(hyp) {
      var v = map.addTerm(hyp);
      if (!exclusions || !exclusions.has(hyp)) {
        schema = schema ? Toy.infixCall(schema, '&', v) : v;
      }
    });
  return schema;
}

/**
 * Returns the given conjunction of hypotheses except any appearing in
 * the exclusions TermSet.  If there are no such hypotheses, returns
 * T.
 */
function hypsExcept(hyps, exclusions) {
  var result = null;
  hyps.eachHyp(function(hyp) {
      if (!exclusions.has(hyp)) {
        result = result ? Toy.infixCall(result, '&', hyp) : hyp;
      }
    });
  return result;
}

/**
 * Makes a facts map into a list of the fact keys.
 */
function listFacts(map) {
  var list = [];
  for (var key in map) {
    list.push(key);
  }
  return list;
}

/**
 * Developer utility function that modifies the named rule to emit
 * information about calls to it.
 */
function traceRule(name) {
  var rule = rules[name];
  function timed() {
    console.log('Enter', name);
    for (var i = 0; i < arguments.length; i++) {
      console.log(i, arguments[i] + '');
    }
    var t = new Toy.NestedTimer(name);
    t.start();
    var result = rule.apply(rules, arguments);
    var elapsed = t.end();
    console.log('=', result + '');
    console.log('Exit', name, elapsed, 'ms');
    return result;
  }
  timed.info = rule.info;
  rules[name] = timed;
}

/**
 * Returns the plain object with various information about the rule
 * applied to create the given step.
 */
function getRuleInfo(step) {
  return rules[step.ruleName].info;
}

/**
 * If the given step has a "site" input, this returns the path
 * of the site argument, a string or Path object.  This uses the
 * "inputs" information of the rule that generated the step to
 * determine which argument to access.
 */
function getStepSite(step) {
  var inputs = getRuleInfo(step).inputs;
  for (var type in inputs) {
    if (type in Toy.siteTypes) {
      var args = step.ruleArgs;
      // Assumes there can be only one "site" argument.
      var index = inputs[type];
      return args[index];
    }
  }
}

/**
 * Returns an array of the steps leading up to and including the given
 * step, sorted by ordinal, not including the details of any step.
 */
function proofOf(step) {
  // See also the nearly identical Toy.unrenderedDeps.
  var result = [];
  // Traverses the dependency graph, recording a copy of every step
  // and building an array of all of the original steps.  In Java
  // one might use HashSets to identify already-visited steps,
  // avoiding temporary modifications to the originals.
  function visitWithDeps(step) {
    if (!step.__visited) {
      result.push(step);
      step.__visited = true;
      step.ruleDeps.forEach(function(dep) { visitWithDeps(dep); });
    }
  }
  visitWithDeps(step);
  result.forEach(function(step) { step.__visited = false; });
  result.sort(function(s1, s2) {
      return s1.ordinal - s2.ordinal;
    });
  return result;
}

/**
 * Returns an array of steps preceding this one that establish
 * assumptions that later steps might not display, currently "assume"
 * and "replaceIsEquiv" steps; in the future perhaps other similar
 * kinds.  The result is selected steps from the result of
 * proofOf(step), based on the ruleName for the step.
 */
function assumptionsBefore(step_arg) {
  var steps = [];
  var proofSteps = proofOf(step_arg);
  proofSteps.forEach(function (step) {
      var ruleName = step.ruleName;
      if (ruleName === 'assume' ||
          ruleName === 'replaceIsEquiv') {
        steps.push(step);
      }
    });
  return steps;
}

/**
 * Returns an array of "assume" steps in the proof of the given step
 * (see Toy.proofOf) that create an assumption of the step.  Assumes
 * that the assumptions are a chain of conjuncts, which is true of
 * normalized assumptions.  Used in rendering to highlight the sources
 * of assumptions.
 */
function assumptionsUsed(step) {
  var asms = step.getAsms();
  if (!asms) {
    return [];
  }
  var asmList = [];
  asms.eachHyp(function (expr) { asmList.push(expr); });

  var steps = proofOf(step);
  var result = [];
  for (var i = 0; i < steps.length; i++) {
    var step = steps[i];
    if (step.ruleName === 'assume') {
      for (var j = 0; j < asmList.length; j++) {
        var asm = asmList[j];
        // Note that every "assume" step is a conditional.
        if (step.getRight().sameAs(asm)) {
          result.push(steps[i]);
        }
      }
    }
  }
  return result;
}

/**
 * The given Expr is treated as the root of a tree of conjuncts.
 * This searches for a direct or indirect conjunct of it that
 * passes the test.  Returns a (pretty) path to the node found,
 * or null if none is found.
 */
function pathToConjunct(root, test) {
  var Path = Toy.Path;
  function pathFrom(node) {
    if (test(node)) {
      return Path.empty;
    }
    if (node.isCall2('&')) {
      var rpath = pathFrom(node.getRight());
      if (rpath) {
        return new Path('right', rpath);
      }
      var lpath = pathFrom(node.getLeft());
      if (lpath) {
        return new Path('left', lpath);
      }
    }
    return null;
  }
  return pathFrom(root);
}

/**
 * Builds and returns a propositional schema from the given term,
 * with the structure of the tree of conjunctions rooted at the term.
 * Matching parts get the same variable letter.
 */
function conjunctionSchema(term) {
  var map = new Toy.TermMap();
  var infixCall = Toy.infixCall;
  function makeSchema(term) {
    if (term.isCall2('&')) {
      return infixCall(makeSchema(term.getLeft()), '&',
                       makeSchema(term.getRight()));
    } else {
      map.addTerm(term);
      return map.get(term);
    }
  }
  return makeSchema(term);
}

/**
 * Returns a Map with information about the bindings of variables that
 * are bound in the scope of the given path.  Keys of the map are
 * variable names, and each value is a path to the site where the
 * variable of that name is bound.
 *
 * The path must only have segments fn, arg, and/or body.
 */
Expr.prototype.pathBindings = function(path_arg) {
  const Path = Toy.Path;
  const bindings = new Map();
  let path = Toy.asPath(path_arg);
  let revPath = Path.empty;
  let term = this;
  while (!path.isEnd()) {
    const segment = path.segment;
    path = path.rest;
    switch(segment) {
    case 'fn':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('fn', revPath);
      term = term.fn;
      break;
    case 'arg':
      assert(term instanceof Call, 'Not a Call: {1}', term);
      revPath = new Path('arg', revPath);
      term = term.arg;
      break;
    case 'body':
      assert(term instanceof Lambda, 'Not a Lambda: {1}', term);
      bindings.set(term.bound.name, revPath.reverse());
      revPath = new Path('body', revPath);
      term = term.body;
      break;
    default:
      assert(false, 'Bad segment {1} in path {2}', segment, path_arg);
    }
  }
  return bindings;
}

/**
 * Simplification facts for algebra, used in _simplifyMath1
 * and related places.  During initialization all facts
 * flagged as simplifier: true are added to this list.
 *
 * TODO: Consider whether x - 7 is simpler than x + -7.
 * TODO: Declare number facts as simplifiers rather than adding here.
 */
var basicSimpFacts = [
                      'T & a == a',
                      'a & T == a',
                      'F & a == F',
                      'a & F == F',
                      'T | a == T',
                      'a | T == T',
                      'F | a == a',
                      'a | F == a',
                      'not T == F',
                      'not F == T',
                      '(a == T) == a',
                      'not (not a) == a',
                      'x = x == T',
                      'T => a == a',
                      'not (a = b) == a != b',
                      'if T x y = x',
                      'if F x y = y',
                      {stmt: '@a + neg b = a - b',
                       // This condition makes extra-sure there will be
                       // no circularity during simplification.
                       // Negation of a numeral will be simplified by
                       // other rules.
                       where: '!$.b.isNumeral()'},
                      {stmt: '@a - b = a + neg b',
                       // This one is an exception to the general rule
                       // that simplifiers make the expression tree
                       // smaller; but arithmetic will follow this, and
                       // with high priority.
                       where: '$.b.isNumeral() && $.b.getNumValue() < 0'},
                      {apply: function(term, cxt) {
                          return (Toy.isArithmetic(term) &&
                                  rules.axiomArithmetic(term));
                        }
                      }
                      // {apply: arithRight} Done in numbers.js.
                      ];


//// Support for adding facts

/**
 * Treats each key in the map as a synopsis of a mathematical
 * statement, and treats its value as a function to prove the
 * statement.  Uses addFact to add each statement and its proof
 * function to the internal database of provable facts.  Applies
 * mathParse to the statement.
 *
 * TODO: Eventually support processing of the synopsis by other than
 *   mathParse, e.g. based on an additional property in the info.
 */
function addFactsMap(map) {
  for (var synopsis in map) {
    var info = map[synopsis];
    info.statement = Toy.mathParse(synopsis);
    addFact(info);
    if (!info.noSwap) {
      addSwappedFact(info);
    }
  }
}

// Object / set of property names supported in fact info data, used
// for validation of fact properties.  See addFact.
var factProperties = {
  goal: true,
  statement: true,
  proof: true,
  simplifier: true,
  desimplifier: true,
  noSwap: true,
  labels: true,
  description: true,
  definitional: true,
  autoSimplify: true,
  afterMatch: true,
  converse: true
};

/**
 * Adds an entry to the facts database given information in the format
 * of fact entries in facts maps, assuming here that the synopsis is
 * already added to the info as a synopsis property.  Can use the
 * synopsis property to generate a goal and the proof property as the
 * prover.
 *
 * This does no inference, so it can be called before proving any
 * theorems.
 *
 * Currently recognizes input properties as follows:
 *
 * goal: if present, can generate the synopsis; if proved, becomes
 *   the proved result, and any proof function will be ignored,
 *   otherwise a WFF.
 * synopsis:  string for input to mathParse.  Must parse to a
 *   complete statement of the fact, to be used as the goal.
 * proof: function to return the proved fact, matching the goal.
 *   If not present, one will be generated to assert the goal.
 * description: string or function as for a rule description.
 * simplifier: true iff this fact is a simplifier.
 * desimplifier: true iff this fact is the "converse" of a simplifier.
 * definitional: the fact is "basically" a definition of a
 *   function or predicate.  Used for presentation of the fact
 *   in a menu.
 * autoSimplify: if given, a simplifier function that takes the
 *   result of a rewrite with this fact as its input and applies it
 *   as the interactive auto-simplifier.
 * afterMatch: if given, a function that a rewrite runs after
 *   substitution, interactively or not, taking the resulting
 *   equation step as its argument.  This is currently disabled.
 * labels: Object/set of label names.  If given as a string, parses
 *   space-separated parts into a set.  Currently just "generalMode"
 *   for desimplifiers to be offered in "general" mode.
 * converse.labels: Like labels, but applies to a "swapped" version
 *   of the fact, if any.
 *
 * The info object is stored in the database with an additional
 * "selfRef" property, in the form of a fact reference as used for
 * fact lookups, treating the fact as a reference to itself.
 */
function addFact(info) {
  // The goal is a rendered Expr just because that makes a complete
  // copy that can be properly annotated with types.
  info.goal = ((info.goal || mathParse(info.statement))
               .copyForRendering(null));
  for (var key in info) {
    if (!(key in factProperties)) {
      var id = info.goal ? info.goal.$$ : info.synopsis;
      console.warn('In fact', id, 'extra info key:', key);
    }
  }
  info.proved = info.goal.isProved() && info.goal;
  // Adding new constants.  Doing it here adds them before asserting
  // the fact.  Also rules.assert can add constants in case it is used
  // without registering a fact. (And Toy.define also adds the defined
  // constant as it bypasses this code.)
  // TODO: If there is no proof, assert the fact immediately and skip
  //   this code.  That will require declaring axioms before uses.
  const names = info.goal.newConstants();
  if (names.size > 0) {
    console.log('In fact', info.goal.toString(), 'introducing constants:',
                Array.from(names).join(', '));
    Toy.addConstants(names);
  }
  // Annotate the new goal with type info for type comparison
  // with portions of steps in the UI.
  //
  // Careful: It is very doubtful whether annotated structures can be
  // shared as part of any other steps or Exprs.
  info.goal.annotateWithTypes();
  if (!info.proved) {
    info.prover = asFactProver(info.proof, info.goal);
  }
  // Set to true when starting to attempt a proof, then
  // to false when the proof succeeds.
  info.inProgress = false;
  info.labels = processLabels(info.labels);
  if (isRecordedFact(info.goal)) {
    console.info('Fact', info.goal.$$, 'already recorded, skipping.');
  } else {
    const wff = info.goal;
    // TODO: Factor out this code here and in getResInfo.
    const wff2 = (wff.isCall2('=>')
                  // This makes a wff with main first, and also has
                  // any assumptions, ordered after the main part.  We
                  // do not expect this to be a theorem.
                  ? Toy.infixCall(wff.getRight(), '&', wff.getLeft())
                  : wff);
    if (info.simplifier) {
      // This puts a string onto basicSimpFacts for fast cached
      // lookups, but watch out for cases where toString and parse are
      // not inverses.
      basicSimpFacts.push('@' + info.goal.toString());
    }
    setFactInfo(info);
  }
  return info;
}

/**
 * Add the "converse" of an equational fact if it is not already
 * recorded.  Determines the statement from the info's goal.  If it is
 * an equation, switches its LHS and RHS, otherwise does nothing.
 *
 * If the fact to be swapped is a simplifier or desimplifier, the
 * newly-created fact will be appropriately labeled as the opposite.
 */  
function addSwappedFact(info) {
  var stmt = info.goal;
  if (stmt.isEquation()) {
    var swapped = Toy.commuteEqn(stmt);
    if (!isRecordedFact(swapped)) {
      function proveSwapped() {
        return rules.fact(stmt).andThen('eqnSwap');
      }
      var labels2 = processLabels(info.converse && info.converse.labels);
      var after2 = info.converse && info.converse.afterMatch;
      var info2 = {proof: proveSwapped,
                   goal: swapped,
                   simplifier: !!info.desimplifier,
                   desimplifier: !!info.simplifier,
                   description: info.description,
                   afterMatch: after2,
                   labels: labels2
      };
      addFact(info2);
    }
  }
}


//// SOME DEFINITIONS


/**
 * Dumps out fact resolutions as a debugging aid.
 */
function dumpFactResolutions() {
  const map = _resolutionsByKey;
  map.forEach(function(list, k) {
      console.log('Key', k);
      let goal = null;
      list.forEach(function(resItem) {
          if (!goal) {
            goal = resItem.factInfo.goal;
            console.log('  fact ' + resItem.factInfo.goal);
          }
          const resInfo = resItem.resInfo;
          console.log('  from ' + resInfo.stmt);
          if (resInfo._expansion) {
            console.log('  as ' + resInfo._expansion);
          }
        });
    });
}

//// Export public names.

Toy.rules = rules;
Toy._factsByKey = _factsByKey;

Toy.factsExtending = factsExtending;
Toy.factExpansion = factExpansion;

// Settable variables, export right here:
Toy.autoAssert = false;
Toy.assertFacts = true;

Toy.getStepCounter = getStepCounter;
Toy.noSimplify = noSimplify;

Toy.addRule = addRule;
Toy.addRulesMap = addRulesMap;
Toy.addRules = addRules;
Toy.definition = definition;
Toy.enableDefnFacts = enableDefnFacts;
Toy.addDefnFacts = addDefnFacts;
Toy.resolveToFactInfo = resolveToFactInfo;
Toy.resolveToFact = resolveToFact;
Toy.addFact = addFact;
Toy.addFactsMap = addFactsMap;
Toy.isRecordedFact = isRecordedFact;
Toy.proveResult = proveResult;
Toy.getResult = getResult;
Toy.eachFact = eachFact;
Toy.getTheorem = getTheorem;
Toy.getResInfo = getResInfo;
Toy.convert = convert;
Toy.findMatchingFact = findMatchingFact;
Toy.tryReduce = tryReduce;
Toy.applyFactsWithinSite = applyFactsWithinSite;
Toy.applyFactsWithinRhs = applyFactsWithinRhs;
Toy.applyFactsOnce = applyFactsOnce;
Toy.applyToFocalPart = applyToFocalPart;
Toy.whileChanges = whileChanges;
Toy.arrange = arrange;
Toy.arrangeRhs = arrangeRhs;
Toy.listFacts = listFacts;
Toy.transformApplyInvert = transformApplyInvert;
Toy.matchFactPart = matchFactPart;
Toy.searchForMatchingFact = searchForMatchingFact;
Toy.getRuleInfo = getRuleInfo;
Toy.getStepSite = getStepSite;
Toy.proofOf = proofOf;
Toy.assumptionsBefore = assumptionsBefore;
Toy.assumptionsUsed = assumptionsUsed;

Toy.definition = definition;

Toy.basicSimpFacts = basicSimpFacts;

Toy.traceRule = traceRule;

Toy.flagHyps = flagHyps;
Toy.buildHypSchema = buildHypSchema;
Toy.pathToConjunct = pathToConjunct;

// For communication between an action precheck and the rule's main
// action function.
Toy._actionInfo;

// For debugging.
Toy._statementResInfos = _statementResInfos;
Toy._resolutionsByKey = _resolutionsByKey;
Toy.dumpFactResolutions = dumpFactResolutions;

// For testing.
Toy._tautologies = _tautologies;
Toy._alreadyProved = alreadyProved;
Toy._locateMatchingFact = _locateMatchingFact;
Toy._conjunctionSchema = conjunctionSchema;

})();
