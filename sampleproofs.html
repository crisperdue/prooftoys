<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Display</title>
   <!-- TODO: deploy with yui-min.js rather than yui.js -->
  <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui.js"></script>

  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

h1 { color: black }

h2 {
  color: black;
  text-align: left;
}

body {
  /* Allow space for the bottom panel. */
  margin-bottom: 4em;
}

</style>
  
</head>
<body class=yui3-skin-sam
 style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Prooftoys</h2>

<center><i>Dedicated to promoting mathematical thinking and skills through
computer-based tools.</i></center>

<h2>Proof Display</h2>

<p><b>Introduction.</b>  
Peter Andrews' Q<sub>0</sub> is an exceptionally simple and elegant
logic that has the power to develop most of mathematics, comparable to
first order logic plus set theory.  This page is implemented by the
proof display component of a proof assistant for a version of this
logic. The displays help to show how proof steps are connected
and can show the details behind composite steps.

<p>In this system the higher concepts such as theorems and derived rules of
inference are built of the basic building blocks, not wired in with
code.  With this page you can view many of the already-proved theorems
that are part of the core library for the logic.

<p>Some of the theorems and derived rules of inference you can see
here are intermediate results, but they help to demonstrate the core
concepts and how proofs are built from them.  Examples of some
practical rules of inference are also here, such as universal
generalization (uGen), universal instantiation (forallInst), and
reasoning by cases (cases).

<p><i>This page is supported in recent versions of Firefox and Chrome.</i>

<p id=selectDiv style="margin: 1.5em">
<b>Select a rule or theorem to prove:</b>
</p>
<div id=proofs></div>

<p><b>About the logic.</b>  This page can derive many of the theorems
and examples of rules of inference of Chapter 5 of Peter Andrews'
book,
<a href="http://gtps.math.cmu.edu/tttp.html" target="_blank">
An Introduction to Mathematical Logic and Type Theory: To Truth
Through Proof</a>.  The order of theorems is essentially the same as
in the book.  Some of the numbered theorems have been given names here
in the hope of helping me remember which is which.  His logic is
summarized in
<a href="http://plato.stanford.edu/entries/type-theory-church/#ForBasEqu"
target=_blank>this article</a>
in the online Stanford Encyclopedia of Philosophy.

<p><b>About the proofs.</b> Most of the proofs here closely follow
proofs in the book.  I am also experimenting with definitions of
boolean operators more directly related to truth tables, and a number
of proofs use those definitions.  In some cases more than one version
of the same proof is available, one following the book.  The sample
proofs are all created by hand and executed by machine.

<p><b>About the displays.</b> Formulas are presented here in a somewhat
different notation.  Instead of the usual use of lambda,
we have a notation somewhat resembling the Ruby
programming language brace notation for 
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous functions or Smalltalk blocks.
For example in place of <b>&lambda;x.p x</b> you will see <code><b>{x |
p x}</b></code>.  This notation also resembles common notation for sets,
and can be read that way for functions with boolean values &mdash;
"<i>the set of x such that p of x</i>".
The displays also use symbols more like programming
language symbols for "and" and "or", and infix syntax where
applicable.  Note that even these very basic proofs use derived rules
of inference that you can also view.

<p>When the mouse is over a line, that line and lines it uses
are highlighted.  For Rule R and a lambda reductions ("reduce"), key
parts of the lines are also highlighted for quicker identification.

<p>New! (2011/06/01) Click on the name of the rule of inference or theorem
mentioned on a line and see the proof worked out in detail below
the current proof.

<p><b>About the project.</b> The project is in an early stage,
and is currently hosted as
<a href="http://code.google.com/p/jlogic" target=_blank><b>jLogic</b></a>
at Google Code.  Requests and suggestions are welcome.  Please use
<a href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion"
target="_blank">
this template</a> for your input.

<p>Thanks
<br>Cris Perdue


<script>
// Remove "filter" to load minified JavaScript.
YUI({filter: 'raw', insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  var proofs = {

    // DEFINITIONS

    axioms: {
      level: 1
    },

    definitions: {
      level: 1
    },

    // PROOFS

    eqSelf: {
      args: [call(p, x)],
      level: 1
    },

    applyBoth: {
      args: [call('=', f, g), x],
      level: 1
    },

    replaceWhole: {
      args: [call(p, x), call('=', call(p, x), call(q, x))],
    },

    eqnSwap: {
      args: [call('=', p, q)],
      level: 1
    },

    eqnChain: {
      args: [call('=', p, q), call('=', q, r)],
    },

    applyBySides: {
      args: [call('=', p, q), call('=', 'a', 'b')]
    },
    
    applyBoth: {
      args: [call('=', p, q), r],
      level: 1
    },
    
    applyToBoth: {
      args: [p, call('=', q, r)]
    },

    useDefinition: {
      args: ['not', call('not', equal(p, call('not', p))), '/fn'],
      level: 1
    },
    
    reduce: {
      args: [equal(p, call(lambda(x, T), y)), '/right'],
      level: 1
    },

    changeVar: {
      args: [equal(lambda(z, z), lambda(z, z)), '/right', y],
      level: 1
    },

    bindEqn: {
      args: [call('=', f, g), x],
    },
    
    instEqn: {
      args: [call('=', call(g, y), z),
             call(f, x),
             y],
    },
    
    eqT: {
      args: [p]
    },
    
    r5211: {},

    r5211Book: {},
    
    t: {},
    
    r5212: {},
    
    toTIsEquation: {
      args: [call('=', p, q)]
    },
    
    r5213: {
      args: [call('=', p, q),
             call('=', q, r)]
    },
    
    forallInst: {
      args: [call('forall', lambda(y, call(p, y))),
             call(f, y)],
      level: 1
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    equationCases: {
      args: [equal(T, T), equal(F, F), 'z'],
      level: 1
    },

    r5218a: {},

    r5218: {
      args: [call(p, y)]
    },
    
    toTIsA: {
      args: [p],
      level: 1
    },
    
    fromTIsA: {
      args: [call('=', T, p)],
      level: 1
    },
    
    forallT: {
      args: [_var('v')]
    },

    uGen: {
      args: [call(p, y), y],
      level: 1
    },
    
    sub: {
      args: [call(p, y), call(f, x), y],
      level: 1
    },
    
    subAll: {
      args: [implies(p, call('||', T, q)),
             ({p: Y.parse('forall {x : T || b}'),
               q: Y.parse('forall {x : b}')
             })
            ],
    },

    cases: {
      args: [equal(call(p, T), T), equal(call(p, F), F), x],
      level: 1
    },
    
    r5223: {},
    
    modusPonens: {
      args: [p, implies(p, q)],
      level: 1
    },
    
    r5230TF: {},
    
    r5230FT: {},
    
    r5230FT_alternate: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))],
      level: 1
    },
    
    applyFunc: {
      args: [equal(call('-->', T), lambda(x, x)), F]
    },
    
    tautology: {
      /* This tautology is already an equation, let's test one that is not.
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))],
      */
      args: [Y.parse('(p --> q) && (not p --> q) --> q')],
      level: 1
    },
    
    r5235: {
      args: [x, p, call(q, x)]
    },

    implyForall: {
      args: [x, implies(p, call(q, x))],
      level: 1
    },

    p: {
      args: [Y.parse('p x'),
             Y.parse('p x --> q x'),
             Y.parse('q x'),
             Y.parse('P && (P --> Q) --> Q')]
    },

    r5238a: {
      args: [y, call(p, y), call(q, y)]
    },

    r5238: {
      args: [['x1', 'x2'], call(p, _var('x1')), call(p, _var('x2'))]
    },

    r5239: {
      args: [equal(p, q), lambda(p, equal(q, p)), '/body/right'],
      level: 1
    },

    replace: {
      args: [Y.parse('x > 0 --> (x = (abs x))'),
             Y.parse('x > 0 --> ((x + x) > x)'), '/right'
             ],
      level: 1
    }

  };

  function selectorChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    displayProof(ruleName);
  }

  /**
   * Runs and displays a proof of the named rule (or theorem).
   * If there is no such rule, notifies the user that there is none.
   */
  function displayProof(ruleName) {
    var ruleInfo = proofs[ruleName];
    if (ruleInfo == undefined) {
      alert('No rule "' + ruleName + '"');
    } else {
      var result = Y.rules[ruleName].apply(null, ruleInfo.args || []);
      // For debugging.
      window.proved = result;

      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      Y.renderInference(result, proofNode, editable);
      document.title = 'Proof display -- ' + ruleName;
    }
  }

  // Do we want sample proofs to be editable?
  // Controllable through the query string.
  var editable;

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      // You can control which rule is displayed by including
      // "rule=<ruleName>" in the query string.
      var ruleName = queryData.rule;
      editable = queryData.edit != undefined;
      var inference = null;
      if (!location.search) {
        // Default to displaying forallInst.
        ruleName = 'forallInst';
      }
      displayProof(ruleName);
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        if (proofs[name].level == 1) {
          if (name == ruleName) {
            selector += '<option selected>' + name + '\n';
          } else {
            selector += '<option>' + name + '\n';
          }
        }
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.addBottomPanel();
      Y.one('#selector').on('change', selectorChanged);
    });

  // For debugging.
  window.Y = Y;
  window.db = Y.debugString;
});

// Debugging helpers.

/**
 * Returns a string of N spaces.
 */
function spaces(n) {
  var result = '';
  for (var i = 0; i < n; i++) {
    result += ' ';
  }
  return result;
}

/**
 * Assumption dumper.  Finds steps of an inference that depend on
 * a wff representable as the target string.  The index and depth
 * default to 0, and get nonzero values in recursive calls, indicating
 * the zero-based step number in proof, and depth from top-level.
 * Logs occurrences of the given assumption at all proof levels,
 * with indentation per level.
 */
function sumpDump(inf, target, index, depth) {
  index = index || 0;
  depth = depth || 0;
  if (inf._assumes[target]) {
    Y.log(spaces(depth) + index + ': ' + inf.name + ' = ' + inf.result);
    var proof = inf.proof;
    var steps = proof.steps;
    for (var i = 0; i < steps.length; i++) {
      sumpDump(steps[i], target, i, depth + 1);
    }
  }
};

/**
 * Finds steps in a proof that produce a result representable as
 * the target string and logs them with the index of the step(s).
 */
function cancellations(proof, target) {
  var steps = proof.steps;
  for (var i = 0; i < steps.length; i++) {
    var inf = steps[i];
    if (inf.result.asString() == target) {
      Y.log(i + ': ' + inf.name + ' = ' + inf.result);
    }
  }
}

</script>
</body>
</html>
