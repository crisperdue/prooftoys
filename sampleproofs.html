<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Display</title>

  <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui-min.js"></script>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="proof.js"></script>
  <script src="q0.js"></script>

<style type="text/css">

  h1 { color: black }

  body { background-color: #6d6 }

/* Proof styling */

.proofStep {
    background-color: beige;
    font-size: 90%;
    padding: 2px;
    margin: 4px 0px;
}

.hover, .dep {
  background-color: white;
 }

/* Generic dependency */
.dep-old {
  background-color: #DDF;
}

/* Old value ("removed") */
.reduced, .old {
  background-color: #FCC;
 }

/* New value ("replacement") -- greenish */
.hover2, .reduced2, .new {
  background-color: #6F6;
}

</style>
  
</head>
<body style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Proof Display</h1>
<p>
This page can derive and display many of the theorems and examples of
rules of inference of Chapter 5 of Peter Andrews' book,
<a href="http://gtps.math.cmu.edu/tttp.html" target="_blank">
An Introduction to Mathematical Logic and Type Theory: To Truth
Through Proof</a>.  The order of theorems is essentially the same as
in the book.  Some of the numbered theorems have been given names here
in the hope of helping me remember which is which.

<p><b>About the proofs.</b> Most of the proofs here closely follow
proofs in the book.  I am also experimenting with definitions of
boolean operators more directly related to truth tables, and a number
of proofs use those definitions.  In some cases more than one version
of the same proof is available, one following the book.  The sample
proofs are all created by hand and executed by machine.

<p><b>About the displays.</b> Formulas are presented here in a slightly
different notation.  Instead of the usual use of lambda,
we have a notation somewhat resembling the Ruby
programming language brace notation for 
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous
functions or Smalltalk blocks.  For example in place
of <b>&lambda;x.T</b> you will see <code><b>{x : T}</b></code>.
The displays also use symbols more like programming language
symbols for "and" and "or", and infix where applicable.

<p>When the mouse is over a line, that line and lines it uses
are highlighted.  For Rule R and a lambda reductions ("reduce"),
key parts of the lines also highlight themselves for quicker
identification.

<p><b>About the project.</b> The project is in an early stage,
and is currently hosted as
<a href="http://code.google.com/p/jlogic" target=_blank><b>jLogic</b></a>
at Google Code.  Requests and suggestions are welcome.  Please use
<a href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion"
target="_blank">
this template</a> for your input.

<p>Thanks
<br>Cris Perdue

<p id=selectDiv style="margin: 1.5em">
<b>Select a rule or theorem to prove:</b>
</p>
<div id=proofs style="margin: 1em"></div>
<div id=query style="margin: 1em; color: white"></div>

<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'q0', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  var proofs = {

    // PROOFS

/*
    r: function() {
      var path = Y.path('/right/left');
      return Y.makeInference('r', [xxxtimes2, bigger, path]);
    },

    defTrueAnd: {},

    defFalseAnd: {},

    defTrueOr: {},

    defFalseOr: {},

    defTrueImplies: {},

    defFalseImplies: {},
*/
    applyBoth: {
      args: [call('=', f, g), x]
    },

    eqSelf: {
      args: [call(f, y)]
    },

    replaceWhole: {
      args: [call(p, x), call('=', call(p, x), call(q, x))]
    },

    eqnSwap: {
      args: [call('=', p, q)]
    },

    eqnChain: {
      args: [call('=', p, q), call('=', q, r)]
    },

    applyBySides: {
      args: [call('=', p, q), call('=', 'a', 'b')]
    },
    
    applyBoth: {
      args: [call('=', p, q), r]
    },
    
    applyToBoth: {
      args: [p, call('=', q, r)]
    },
    
    instEqn: {
      args: [call('=', call(g, y), z),
             call(f, x),
             y]
    },
    
    eqT: {
      args: [call(f, x)]
    },
    
    r5211: {},
    
    ruleT: {},
    
    r5212: {},
    
    eqnIsTrue: {
      args: [call('=', p, q)]
    },
    
    r5213: {
      args: [call('=', p, q),
             call('=', q, r)]
    },
    
    bindEqn: {
      args: [call('=', f, g), x]
    },
    
    forallInst: {
      args: [call('forall', lambda(y, call(p, y))),
             call(f, y)]
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    r5218: {
      args: [p]
    },
    
    toTIsA: {
      args: [p]
    },
    
    fromTIsA: {
      args: [call('=', T, p)]
    },
    
    uGen: {
      args: [call(p, y), y]
    },
    
    sub: {
      args: [call(p, y), call(f, x), y]
    },
    
    cases: {
      args: [z, call('=', call(p, z), z)]
    },
    
    r5223: {},
    
    modusPonens: {
      args: [p, q]
    },
    
    r5230TF: {},
    
    r5230FT: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))]
    },
    
    applyFunc: {
      args: [equal(call('-->', T), lambda(x, x)), F]
    },
    
    tautology: {
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))]
    },
    
  };

  function proofChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    if (ruleName) {
      var ruleInfo = proofs[ruleName];
      if (ruleInfo == undefined) {
        alert('No rule "' + ruleName + '"');
      }
      var inference = Y.makeInference(ruleName, ruleInfo.args || []);
      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      Y.renderSteps(inference, proofNode);
    }
  }

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      var ruleName = queryData.rule;
      var inference = null;
      if (!location.search) {
        // Default to displaying instEqn.
        ruleName = 'instEqn';
      }
      if (ruleName) {
        var ruleInfo = proofs[ruleName];
        if (ruleInfo == undefined) {
          alert('No rule "' + ruleName + '"');
        } else {
          inference = Y.makeInference(ruleName, ruleInfo.args || []);
        }
      }
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        selector += '<option>' + name + '\n';
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.one('#selector').on('change', proofChanged);
      if (inference) {
        var proofNode = Y.one('#proofs');
        Y.renderSteps(inference, proofNode);
      }
    });
});

</script>
</body>
</html>
