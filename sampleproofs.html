<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">

  <title>ProofToys Proof Builder</title>

   <!-- TODO: deploy with yui-min.js rather than yui.js -->
  <script src="http://yui.yahooapis.com/3.4.0/build/yui/yui.js"></script>
  <!-- For debugging add explicit reference to source file(s) here -->

  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="step-editor.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

h1 { color: black }

h2 {
  color: black;
  text-align: left;
}

body {
  /* Allow space for the bottom panel. */
  margin-bottom: 4em;
}

</style>
  
</head>
<body class=yui3-skin-sam
 style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Prooftoys</h2>

<p><center><i>Software tools for mathematical problem-solving.</i></center>

<h2>Proof Display</h2>

<p><b>Introduction.</b>  
Peter Andrews' Q<instVar>0</instVar> is a simple and elegant
logic that has the power to develop most of mathematics, comparable to
first order logic plus set theory.  This page is implemented by the
proof display component of a proof assistant for a version of this
logic. The displays help to show how proof steps are connected
and can show the details behind composite steps.

<p>In this system the higher concepts such as theorems and derived rules of
inference are built of the basic building blocks, not wired in with
code.  With this page you can view many of the already-proved theorems
that are part of the core library for the logic.

<p>Some of the theorems and derived rules of inference you can see
here are intermediate results, but they help to demonstrate the core
concepts and how proofs are built from them.  Examples of some
practical rules of inference are also here, such as universal
generalization (addForall), universal instantiation (instForall), and
reasoning by cases (cases).

<p><i>This page is supported in recent versions of Firefox and Chrome.</i>

<p id=selectDiv style="margin: 1.5em">
<b>Select a rule or theorem to prove:</b>
</p>
<div id=proofs></div>

<div style="margin: 1.5em 0em .5em 1.5em">
<b>Or interactively create your own proof below:</b>
</div>
<div id=proofEditor></div>

<div id=proofErrors></div>

<p><b>About the logic.</b>  This page can derive many of the theorems
and examples of rules of inference of Chapter 5 of Peter Andrews'
book,
<a href="http://gtps.math.cmu.edu/tttp.html" target="_blank">
An Introduction to Mathematical Logic and Type Theory: To Truth
Through Proof</a>.  The order of theorems is essentially the same as
in the book.  Some of the numbered theorems have been given names here
in the hope of helping me remember which is which.  His logic is
summarized in
<a href="http://plato.stanford.edu/entries/type-theory-church/#ForBasEqu"
target=_blank>this article</a>
in the online Stanford Encyclopedia of Philosophy.

<p><b>About the proofs.</b> Most of the proofs here closely follow
proofs in the book.  I am also experimenting with definitions of
boolean operators more directly related to truth tables, and a number
of proofs use those definitions.  In some cases more than one version
of the same proof is available, one following the book.  The sample
proofs are all created by hand and executed by machine.

<p><b>About the displays.</b> Formulas are presented here in a somewhat
different notation.  Instead of the usual use of lambda,
we have a notation somewhat resembling the Ruby
programming language brace notation for 
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous functions or Smalltalk blocks.
For example in place of <b>&lambda;x.p x</b> you will see <code><b>{x.
p x}</b></code>.  This notation also resembles common notation for sets,
and can be read that way for functions with boolean values &mdash;
"<i>the set of x such that p of x</i>".
The displays also use symbols more like programming
language symbols for "and" and "or", and infix syntax where
applicable.

<p>When the mouse is over a line, that line and lines it uses
are highlighted.  For Rule R and a lambda reductions ("apply"), key
parts of the lines are also highlighted for quicker identification.

<p>Click on the name of the rule of inference or theorem
mentioned on a line and see the proof worked out in detail below
the current proof.

<p><b>About the project.</b> This software is under development
and is currently hosted as
<a href="http://code.google.com/p/jlogic" target=_blank><b>jLogic</b></a>
at Google Code.  Requests and suggestions are welcome.  Please use
<a href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion"
target="_blank">
this template</a> for your input.

<p>Thanks
<br>Cris Perdue

<script>
// Remove "filter" to load minified JavaScript.
YUI({filter: 'raw', insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  // Map from example name to example configuration info, each of
  // which is also a map.  Configuration properties are:
  //
  // ruleName: name of the rule to run, defaults to the example name.
  // args: array of arguments to pass to the rule.  If a function, the
  //   function computes the arguments.
  // level: if 1 then offer this example in the dropdown control.
  var proofs = {

    // PROOFS

    eqSelf: {
      args: [call(p, x)],
      level: 1
    },

    applyBoth: {
      args: [call('=', f, g), x],
      level: 1
    },

    replaceWhole: {
      args: [call(p, x), call('=', call(p, x), call(q, x))],
    },

    eqnSwap: {
      args: [call('=', p, q)],
      level: 1
    },

    eqnChain: {
      args: [call('=', p, q), call('=', q, r)],
    },

    applyBySides: {
      args: [call('=', p, q), call('=', 'a', 'b')]
    },
    
    applyBoth: {
      args: [call('=', p, q), r],
      level: 1
    },
    
    applyToBoth: {
      args: [p, call('=', q, r)]
    },

    useDefinition: {
      args: [call('not', equal(p, call('not', p))), '/fn'],
      level: 1
    },
    
    apply: {
      args: [equal(p, call(lambda(x, T), y)), '/right'],
      level: 1
    },

    changeVar: {
      args: [equal(lambda(z, z), lambda(z, z)), '/right', y],
      level: 1
    },

    bindEqn: {
      args: [call('=', f, g), x],
    },
    
    instEqn: {
      args: [call('=', call(g, y), z),
             call(f, x),
             y],
    },
    
    eqT: {
      args: [p]
    },
    
    r5211: {},

    r5211Book: {},
    
    t: {},
    
    r5212: {},
    
    toTIsEquation: {
      args: [call('=', p, q)]
    },
    
    r5213: {
      args: [call('=', p, q),
             call('=', q, r)]
    },
    
    instForall: {
      args: [call('forall', lambda(y, call(p, y))),
             call(f, y)],
      level: 1
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    equationCases: {
      args: [equal(T, T), equal(F, F), 'z'],
      level: 1
    },

    r5218a: {},

    r5218: {
      args: [call(p, y)]
    },
    
    toTIsA: {
      args: [p],
      level: 1
    },
    
    fromTIsA: {
      args: [call('=', T, p)],
      level: 1
    },
    
    forallT: {
      args: [_var('v')]
    },

    addForall: {
      args: [call(p, y), y],
      level: 1
    },
    
    instVar: {
      args: [call(p, y), call(f, x), y],
      level: 1
    },
    
    instMultiVars: {
      args: [implies(p, call('||', T, q)),
             ({p: Y.parse('forall {x : T || b}'),
               q: Y.parse('forall {x : b}')
             })
            ],
      level: 1
    },

    cases: {
      args: function() {
        var step1 = Y.rules.assume('p T');
        var step2 = Y.rules.assume('p F');
        return [step1, step2, 'x'];
      },
      level: 1
    },
    
    r5223: {},
    
    modusPonens: {
      args: [p, implies(p, q)],
      level: 1
    },
    
    modusPonensHyps: {
      ruleName: 'modusPonens',
      args: function() {
        var step1 = Y.rules.assume('p');
        var step2 = Y.rules.assume('p --> q');
        return [step1, step2];
      },
      level: 1
    },

    r5230TF: {},
    
    r5230FT: {},
    
    r5230FT_alternate: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))],
      level: 1
    },
    
    applyFunc: {
      args: [equal(call('-->', T), lambda(x, x)), F]
    },
    
    tautology: {
      /* This tautology is already an equation, let's test one that is not.
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))],
      */
      args: [Y.parse('(p --> q) && (not p --> q) --> q')],
      level: 1
    },
    
    tautInst: {
      args: [Y.parse('p --> T || q'), ({
        p: Y.parse('forall {x : T || p x}'),
        q: Y.parse('forall {x : p x}')
      })],
      level: 1
    },


    r5235: {
      args: [x, p, call(q, x)]
    },

    implyForallThm: {
      args: [x, p, call(q, x)]
    },

    implyForall: {
      args: [x, Y.parse('p --> q x')],
      level: 1
    },

    implyForallHyps: {
      ruleName: 'implyForall',
      args: function() {
        var step1 = Y.rules.assume('y > 0');
        var step2 = Y.rules.assert('y > 0 --> (p --> q x)');
        var step3 = Y.rules.modusPonens(step1, step2);
	return [x, step3];
      },
      level: 1
    },

    implyForallBookHyps: {
      ruleName: 'implyForallBook',
      args: function() {
	var wff = Y.parse('y > 0 --> (p --> q x)');
        wff.hasHyps = true;
	return [x, wff];
      },
    },

    p: {
      args: [Y.parse('p x'),
             Y.parse('p x --> q x'),
             Y.parse('q x'),
             Y.parse('P && (P --> Q) --> Q')]
    },

    r5238a: {
      args: [y, call(p, y), call(q, y)]
    },

    r5238: {
      args: [['x1', 'x2'], call(p, _var('x1')), call(p, _var('x2'))]
    },

    r5239: {
      args: [equal(p, q), lambda(p, equal(q, p)), '/body/right'],
      level: 1
    },

    replace: {
      args: function() {
        var step1 = Y.rules.assume('x > 0');
        var step2 = Y.rules.assert('x > 0 --> (x = (abs x))');
        var step3 = Y.rules.modusPonens(step1, step2);
        var step4 = Y.rules.assert('x > 0 --> (x + x) > x');
        var step5 = Y.rules.modusPonens(step1, step4);
        return [step3, step5, '/main/right'];
      },
      level: 1
    },

    appendStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      },
      level: 1
    },

    prependStepHyps: {
      args: function() {
        var step1 = Y.rules.assume('p x');
        var step2 = Y.rules.assume('q x');
        return [step1, step2];
      },
      level: 1
    },

    bubbleLeft: {
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (((b && a) && d) && a)'), less];
      },
    },

    mergeConj: {
      args: function() {
        function less(a, b) {
          return a.toString() < b.toString();
        }
        return [Y.rules.assert('lhs = (a && b) && (c && d)'), less];
      },
      level: 1
    }

  };

  function selectorChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    displayProof(ruleName);
  }

  /**
   * Runs and displays a proof of the named rule (or theorem).
   * If there is no such rule, notifies the user that there is none.
   */
  function displayProof(name) {
    var ruleInfo = proofs[name];
    if (ruleInfo == undefined) {
      alert('No example "' + name + '"');
    } else {
      var startMillis = new Date().getTime();
      var result;
      var ruleName = ruleInfo.ruleName || name;
      var args = ruleInfo.args;
      if (typeof args == 'function') {
	args = args();
      } else {
        for (var i = 0; i < args.length; i++) {
          // Give the args current stepCounter values.
          var arg = args[i];
          if (arg instanceof Y.Expr && arg.isStep()) {
            args[i] = arg.freshen();
          }
        }
      }
      try {
	result = Y.rules[ruleName].apply(null, args || []);
      } catch(e) {}
      var elapsed = new Date().getTime() - startMillis;
      // For debugging.
      window.proved = result;
      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      if (result) {
	Y.renderInference(result, proofNode, editable, elapsed);
      } else if (Y.errors.length) {
	var last = Y.errors[Y.errors.length - 1];
	proofNode.append('<p><b>Errors: (' + Y.errors.length
			 + ') ' + last.message + '</b></p>');
	if (last.step) {
	  proofNode.append(Y.renderProof(last.step).node);
	}
      }
      document.title = 'Proof display -- ' + ruleName;
    }
  }

  // Do we want sample proofs to be editable?
  // Controllable through the query string.
  var editable;

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      // You can control which rule is displayed by including
      // "rule=<ruleName>" in the query string.
      var ruleName = queryData.rule;
      // You can make the displays label steps with their ordinals
      // using ordinals=1 in the query string.
      Y.showOrdinals = queryData.ordinals;
      editable = queryData.edit != undefined;
      if (ruleName == undefined) {
        // Default to displaying instForall.
        ruleName = 'instForall';
      }
      displayProof(ruleName);
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        if (proofs[name].level == 1) {
          if (name == ruleName) {
            selector += '<option selected>' + name + '\n';
          } else {
            selector += '<option>' + name + '\n';
          }
        }
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.addBottomPanel();
      Y.one('#selector').on('change', selectorChanged);

      // Create an interactive proof editor for the user.
      var controller = new Y.ProofControl();
      controller.setEditable(true);
      Y.one('#proofEditor').append(controller.node);
      // For debugging:
      window.proofBuilder = controller;
    });

  // For debugging.
  window.Y = Y;
  window.db = Y.debugString;
});

// Debugging helpers.

/**
 * Returns a string of N spaces.
 */
function spaces(n) {
  var result = '';
  for (var i = 0; i < n; i++) {
    result += ' ';
  }
  return result;
}

</script>
</body>
</html>
