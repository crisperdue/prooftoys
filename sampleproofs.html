<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<!-- Uses "almost standards mode", all but some table cell sizing. -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Proof Display</title>
   <!-- TODO: deploy with yui-min.js rather than yui.js -->
  <script src="http://yui.yahooapis.com/combo?3.3.0/build/yui/yui.js"></script>
  <link id=styles type="text/css" rel="stylesheet" href="logic.css">
  <script src="expr.js"></script>
  <script src="proof.js"></script>
  <script src="theorems.js"></script>

<style type="text/css">

  h1 { color: black }

   body { background-color: #beb }

</style>
  
</head>
<body style="margin-left: .5em; text-align: left; font-family: sans-serif">

<h1>Proof Display</h1>

<p><b>Introduction.</b>  The connection between computers and logic has
fascinated me ever since I was a boy, and Peter Andrews' system Q0 is
especially notable. It uses such an exceptionally small base of simple
concepts to build sophisticated reasoning capabilities and a
foundation suitable for mathematics in general, comparable to first
order logic plus set theory.  Also, by taking functions as fundamental
concepts it shows off the parallels between programming languages and
higher-order logics.

<p>As I started working on an interactive proof assistant based on
Andrews' system, I wanted to build up higher concepts such as theorems
and derived rules of inference from the basic building blocks rather
than building them in with code, and this meant building his
elementary theorems and rules from his base, or a very similar base.
This gave me a set of theorems proven by the core proof-building
machinery.  I wanted a more convenient way to view them, and wanted to
start trying out ideas for supporting human readers of proofs.

<p>The theorems and derived rules of inference here tend to be just
building blocks rather than completed tools for serious proof
development, but they demonstrate Andrews' core concepts, and how
proofs are built from them.  Examples of some practical rules of
inference are here though, such as universal generalization (uGen),
universal instantiation (forallInst), and reasoning by cases (cases).

<p>This page is supported in recent versions of Firefox and Chrome.

<p id=selectDiv style="margin: 1.5em">
<b>Select a rule or theorem to prove:</b>
</p>
<div id=proofs></div>

<p><b>About the logic.</b>  This page can derive and show derivations
of many of the theorems and examples of rules of inference of Chapter
5 of Peter Andrews' book,
<a href="http://gtps.math.cmu.edu/tttp.html" target="_blank">
An Introduction to Mathematical Logic and Type Theory: To Truth
Through Proof</a>.  The order of theorems is essentially the same as
in the book.  Some of the numbered theorems have been given names here
in the hope of helping me remember which is which.  His system is
summarized in
<a href="http://plato.stanford.edu/entries/type-theory-church/#ForBasEqu"
target=_blank>this article</a>
in the online Stanford Encyclopedia of Philosophy.

<p><b>About the proofs.</b> Most of the proofs here closely follow
proofs in the book.  I am also experimenting with definitions of
boolean operators more directly related to truth tables, and a number
of proofs use those definitions.  In some cases more than one version
of the same proof is available, one following the book.  The sample
proofs are all created by hand and executed by machine.

<p><b>About the displays.</b> Formulas are presented here in a somewhat
different notation.  Instead of the usual use of lambda,
we have a notation somewhat resembling the Ruby
programming language brace notation for 
<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Blocks_and_iterators"
 target="_blank">blocks</a>/anonymous functions or Smalltalk blocks.
For example in place of <b>&lambda;x.p x</b> you will see <code><b>{x |
p x}</b></code>.  This notation also resembles common notation for sets,
and can be read that way for functions with boolean values &mdash;
"<i>the set of x such that p of x</i>".
The displays also use symbols more like programming
language symbols for "and" and "or", and infix syntax where
applicable.  Note that even these very basic proofs use derived rules
of inference that you can also view.

<p>When the mouse is over a line, that line and lines it uses
are highlighted.  For Rule R and a lambda reductions ("reduce"), key
parts of the lines are also highlighted for quicker identification.

<p>New! (2011/06/01) Click on the name of the rule of inference or theorem
mentioned on a line and see the proof worked out in detail below
the current proof.

<p><b>About the project.</b> The project is in an early stage,
and is currently hosted as
<a href="http://code.google.com/p/jlogic" target=_blank><b>jLogic</b></a>
at Google Code.  Requests and suggestions are welcome.  Please use
<a href="http://code.google.com/p/jlogic/issues/entry?template=Comment/suggestion"
target="_blank">
this template</a> for your input.

<p>Thanks
<br>Cris Perdue


<script>
YUI({filter: null, insertBefore: 'styles'})
   .use('node', 'event', 'json', 'expr', 'theorems', 'test', 'console',
        'proof', 'collection', 'querystring-parse', 'json',
        // querystring-parse requires "collection" (?!)
   function(Y) {

  // Set up some useful constants and functions.

  Y.Expr.utils.import();

  // Query string data.
  var queryData;

  var proofs = {

    // DEFINITIONS

    axioms: {
      level: 1
    },

    definitions: {
      level: 1
    },

    // PROOFS

    applyBoth: {
      args: [call('=', f, g), x],
      level: 1
    },

    eqSelf: {
      args: [call(p, x)],
      level: 1
    },

    replaceWhole: {
      args: [call(p, x), call('=', call(p, x), call(q, x))],
      level: 1
    },

    eqnSwap: {
      args: [call('=', p, q)],
      level: 1
    },

    eqnChain: {
      args: [call('=', p, q), call('=', q, r)],
      level: 1
    },

    applyBySides: {
      args: [call('=', p, q), call('=', 'a', 'b')]
    },
    
    applyBoth: {
      args: [call('=', p, q), r],
      level: 1
    },
    
    applyToBoth: {
      args: [p, call('=', q, r)]
    },

    useDefinition: {
      args: ['not', call('not', equal(p, call('not', p))), '/fn'],
      level: 1
    },
    
    reduce: {
      args: [equal(p, call(lambda(x, T), y)), '/right'],
      level: 1
    },

    bindEqn: {
      args: [call('=', f, g), x],
    },
    
    instEqn: {
      args: [call('=', call(g, y), z),
             call(f, x),
             y],
    },
    
    eqT: {
      args: [p]
    },
    
    r5211: {},

    r5211Book: {},
    
    t: {
      level: 1
    },
    
    r5212: {},
    
    eqnIsTrue: {
      args: [call('=', p, q)]
    },
    
    r5213: {
      args: [call('=', p, q),
             call('=', q, r)]
    },
    
    forallInst: {
      args: [call('forall', lambda(y, call(p, y))),
             call(f, y)],
      level: 1
    },
    
    andTBook: {
      args: [p]
    },
    
    andT: {
      args: [p]
    },
    
    r5217Book: {},
    
    boolFnsEqual: {
      level: 1
    },

    r5218a: {},

    r5218: {
      args: [p]
    },
    
    toTIsA: {
      args: [p],
      level: 1
    },
    
    fromTIsA: {
      args: [call('=', T, p)],
      level: 1
    },
    
    forallT: {
      args: [_var('v')]
    },

    uGen: {
      args: [call(p, y), y],
      level: 1
    },
    
    sub: {
      args: [call(p, y), call(f, x), y],
      level: 1
    },
    
    cases: {
      args: [z, call('=', call(p, z), z)],
      level: 1
    },
    
    r5223: {},
    
    modusPonens: {
      args: [p, q],
      level: 1
    },
    
    r5230TF: {},
    
    r5230FT: {},
    
    r5230FT_alternate: {},
    
    r5231T: {},
    
    r5231F: {},
    
    falseEquals: {},
    
    trueEquals: {},
    
    evalBool: {
      args: [call('-->',
                  call('-->', F, call('not', F)),
                  call('not', F))],
      level: 1
    },
    
    applyFunc: {
      args: [equal(call('-->', T), lambda(x, x)), F]
    },
    
    tautology: {
      args: [equal(call('-->', call('&&', p, q), r),
                   call('-->', p, call('-->', q, r)))],
      level: 1
    },
    
  };

  function proofChanged() {
    var selectorNode = Y.one('#selector');
    var selector = Y.Node.getDOMNode(selectorNode);
    var options = selector.options;
    var ruleName = options[selector.selectedIndex].text;
    if (ruleName) {
      var ruleInfo = proofs[ruleName];
      if (ruleInfo == undefined) {
        alert('No rule "' + ruleName + '"');
      }
      var inference = Y.makeInference(ruleName, ruleInfo.args || []);
      var proofNode = Y.one('#proofs');
      proofNode.setContent('');
      Y.renderSteps(inference, proofNode);
    }
  }

  Y.on('domready', function() {
      queryData = Y.QueryString.parse(location.search.substring(1));
      var ruleName = queryData.rule;
      var inference = null;
      if (!location.search) {
        // Default to displaying instEqn.
        ruleName = 'instEqn';
      }
      if (ruleName) {
        var ruleInfo = proofs[ruleName];
        if (ruleInfo == undefined) {
          alert('No rule "' + ruleName + '"');
        } else {
          inference = Y.makeInference(ruleName, ruleInfo.args || []);
        }
      }
      var selector = '<select id=selector>\n<option value="">-- choose --';
      for (var name in proofs) {
        if (proofs[name].level == 1) {
          selector += '<option>' + name + '\n';
        }
      }
      selector += '</select>';
      Y.one('#selectDiv').appendChild(selector);
      Y.one('#selector').on('change', proofChanged);
      if (inference) {
        var proofNode = Y.one('#proofs');
        Y.renderSteps(inference, proofNode);
        // For debugging.
        window.winf = inference;
      }
    });

  // For debugging.
  window.Y = Y;
});

// Debugging helpers.

/**
 * Returns a string of N spaces.
 */
function spaces(n) {
  var result = '';
  for (var i = 0; i < n; i++) {
    result += ' ';
  }
  return result;
}

/**
 * Assumption dumper.  Finds steps of an inference that depend on
 * a wff representable as the target string.  The index and depth
 * default to 0, and get nonzero values in recursive calls, indicating
 * the zero-based step number in proof, and depth from top-level.
 * Logs occurrences of the given assumption at all proof levels,
 * with indentation per level.
 */
function sumpDump(inf, target, index, depth) {
  index = index || 0;
  depth = depth || 0;
  if (inf._assumes[target]) {
    Y.log(spaces(depth) + index + ': ' + inf.name + ' = ' + inf.result);
    var proof = inf.proof;
    var steps = proof.steps;
    for (var i = 0; i < steps.length; i++) {
      sumpDump(steps[i], target, i, depth + 1);
    }
  }
};

/**
 * Finds steps in a proof that produce a result representable as
 * the target string and logs them with the index of the step(s).
 */
function cancellations(proof, target) {
  var steps = proof.steps;
  for (var i = 0; i < steps.length; i++) {
    var inf = steps[i];
    if (inf.result.asString() == target) {
      Y.log(i + ': ' + inf.name + ' = ' + inf.result);
    }
  }
}

</script>
</body>
</html>
